<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-touch-fullscreen" content="yes">
  <title>Chat - Vynix</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- FIXED: Removed trailing spaces from Firebase URLs -->
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js"></script>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
    :root {
      --bg: #ffffff;
      --card-bg: #f7f9fa;
      --text-primary: #0f1419;
      --text-secondary: #536471;
      --border: #e1e8ed;
      --accent: #ff2a6d;
      --header-bg: #ffffff;
      --chat-bubble-sent: #ff2a6d;
      --chat-bubble-received: #f7f9fa;
      --status-online: #128c7e;
      --offline-dot: #9ca3af;
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.1);
      --glow: 0 0 10px rgba(255, 42, 109, .35);
    }
    body.dark {
      --bg: #000000;
      --card-bg: #16181c;
      --text-primary: #ffffff;
      --text-secondary: #71767b;
      --border: #2f3336;
      --header-bg: #000000;
      --chat-bubble-received: #16181c;
      --offline-dot: #4b5563;
    }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text-primary);
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      touch-action: manipulation;
      line-height: 1.4;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: var(--header-bg);
      z-index: 100;
      padding: 12px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 64px;
      box-shadow: var(--shadow-sm);
      transition: background-color 0.3s ease;
    }
    .header-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .back-btn {
      background: none;
      border: none;
      color: var(--text-primary);
      font-size: 24px;
      cursor: pointer;
      padding: 8px;
      border-radius: 50%;
      transition: background 0.2s ease;
    }
    .back-btn:hover {
      background: rgba(255, 42, 109, 0.1);
    }
    .profile-header {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
    }
    .avatar-wrapper {
      position: relative;
    }
    .profile-pic-header {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      object-fit: cover;
      background: var(--accent);
      color: #ffffff;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: var(--shadow-sm);
    }
    .profile-pic-header img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 50%;
    }
    .status-dot-header {
      position: absolute;
      bottom: 2px;
      right: 2px;
      width: 12px;
      height: 12px;
      background: var(--status-online);
      border-radius: 50%;
      border: 2px solid var(--header-bg);
      display: none;
      animation: pulse 2s infinite;
    }
    .status-dot-header.offline {
      background: var(--offline-dot);
      animation: none;
    }
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.8; }
      100% { transform: scale(1); opacity: 1; }
    }
    .profile-details {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .profile-name-header {
      font-weight: 700;
      font-size: 16px;
      color: var(--text-primary);
    }
    .profile-timestamp-header {
      font-size: 12px;
      color: var(--text-secondary);
    }
    .main-content {
      padding: 84px 20px 120px;
      max-width: 600px;
      margin: 0 auto;
    }
    .messages-container {
      flex: 1;
      overflow-y: auto;
      padding-bottom: 20px;
      max-height: calc(100vh - 200px);
    }
    .message-date {
      text-align: center;
      margin: 20px 0;
      color: var(--text-secondary);
      font-size: 13px;
    }
    .message-item {
      display: flex;
      margin-bottom: 4px;
      animation: fadeIn 0.3s ease;
      position: relative;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      -webkit-user-drag: none;
    }
    .message-received {
      flex-direction: row;
      align-items: flex-end;
      margin-left: 8px;
    }
    .message-sent {
      flex-direction: row-reverse;
      align-items: flex-end;
      margin-right: 8px;
    }
    .message-avatar {
      width: 35px;
      height: 35px;
      border-radius: 50%;
      object-fit: cover;
      margin: 0 8px;
      flex-shrink: 0;
      visibility: hidden;
    }
    .message-received .message-avatar {
      visibility: visible;
    }
    .message-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 50%;
    }
    .message-bubble {
      max-width: 65%;
      padding: 8px 12px;
      border-radius: 18px;
      word-wrap: break-word;
      line-height: 1.4;
      position: relative;
      cursor: pointer;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      -webkit-user-drag: none;
    }
    .message-received .message-bubble {
      background: var(--chat-bubble-received);
      color: var(--text-primary);
      border-bottom-left-radius: 4px;
      margin-left: 8px;
    }
    .message-sent .message-bubble {
      background: var(--chat-bubble-sent);
      color: #ffffff;
      border-bottom-right-radius: 4px;
      margin-right: 8px;
      box-shadow: var(--glow);
    }
    .message-time {
      font-size: 11px;
      color: var(--text-secondary);
      margin-top: 4px;
      text-align: right;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 4px;
      user-select: none;
      -webkit-user-select: none;
    }
    .message-sent .message-time {
      color: rgba(255, 255, 255, 0.8);
    }
    .message-status {
      font-size: 16px;
      margin-left: 4px;
      vertical-align: middle;
      user-select: none;
      -webkit-user-select: none;
    }
    .status-sent {
      color: var(--text-secondary);
    }
    .status-delivered {
      color: var(--text-secondary);
    }
    .status-read {
      color: #4fc3f7;
    }
    .input-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--card-bg);
      border-top: 1px solid var(--border);
      padding: 12px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 10;
      box-shadow: var(--shadow-sm);
    }
    .input-group {
      flex: 1;
      display: flex;
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 24px;
      overflow: hidden;
    }
    .input-group textarea {
      flex: 1;
      background: none;
      border: none;
      outline: none;
      padding: 12px 20px;
      color: var(--text-primary);
      font-size: 16px;
      resize: none;
      max-height: 120px;
      font-family: inherit;
    }
    .input-group textarea::placeholder {
      color: var(--text-secondary);
    }
    .input-icon {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 20px;
      cursor: pointer;
      padding: 12px;
      transition: color 0.2s ease;
      min-width: 44px;
    }
    .input-icon:hover {
      color: var(--accent);
    }
    .send-btn {
      background: var(--accent);
      color: #ffffff;
      border: none;
      border-radius: 50%;
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 20px;
      font-weight: bold;
      transition: all 0.2s ease;
      box-shadow: var(--glow);
    }
    .send-btn:hover {
      transform: scale(1.05);
    }
    .typing-indicator {
      display: flex;
      gap: 4px;
      padding: 12px 16px;
      background: var(--chat-bubble-received);
      border-radius: 18px;
      max-width: 70%;
      margin-left: 52px;
      border-bottom-left-radius: 4px;
    }
    .typing-dot {
      width: 8px;
      height: 8px;
      background: var(--text-secondary);
      border-radius: 50%;
      animation: typing 1.4s infinite;
    }
    .typing-dot:nth-child(2) {
      animation-delay: 0.2s;
    }
    .typing-dot:nth-child(3) {
      animation-delay: 0.4s;
    }
    @keyframes typing {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-10px); }
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    #horizontal-spinner {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
    }
    #horizontal-spinner.active {
      display: block;
    }
    #spinner-segment {
      width: 40px;
      height: 4px;
      background: var(--accent);
      border-radius: 2px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    #alert-message {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--card-bg);
      color: var(--text-primary);
      padding: 12px 16px;
      border-radius: 20px;
      border: 1px solid var(--border);
      transform: translateX(100%);
      transition: transform 0.3s ease;
      z-index: 1000;
      max-width: 300px;
    }
    #alert-message.active {
      transform: translateX(0);
    }
    #media-progress {
      width: 100%;
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      overflow: hidden;
      margin: 8px 0;
    }
    #media-progress-bar {
      height: 100%;
      background: var(--accent);
      width: 0%;
      transition: width 0.3s ease;
    }
    
    /* Context Menu - FIXED POSITIONING */
    .context-menu {
      position: fixed;
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px 0;
      box-shadow: var(--shadow-md);
      z-index: 1002; /* Above header */
      min-width: 180px;
      display: none;
      transform: translateY(-10px);
      opacity: 0;
      transition: all 0.2s ease;
      max-height: 80vh;
      overflow-y: auto;
    }
    .context-menu.active {
      display: block;
      transform: translateY(0);
      opacity: 1;
    }
    .context-menu-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      color: var(--text-primary);
      cursor: pointer;
      transition: background 0.2s ease;
      font-size: 14px;
      white-space: nowrap;
    }
    .context-menu-item:hover {
      background: rgba(255, 42, 109, 0.1);
    }
    .context-menu-item.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .context-menu-icon {
      font-size: 18px;
      width: 20px;
    }
    
    /* Forward Modal */
    .forward-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1003;
      backdrop-filter: blur(4px);
    }
    .forward-modal.active {
      display: flex;
    }
    .forward-content {
      background: var(--card-bg);
      border-radius: 16px;
      width: 90%;
      max-width: 400px;
      max-height: 70vh;
      overflow: hidden;
      border: 1px solid var(--border);
      box-shadow: var(--shadow-md);
    }
    .forward-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-weight: 600;
    }
    .forward-list {
      padding: 8px 0;
      overflow-y: auto;
      max-height: 50vh;
    }
    .forward-friend-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 20px;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    .forward-friend-item:hover {
      background: rgba(255, 42, 109, 0.1);
    }
    
    @media (max-width: 768px) {
      .main-content {
        padding: 84px 16px 120px;
      }
      .input-bar {
        padding: 12px 16px;
        gap: 8px;
      }
      .header {
        padding: 12px 16px;
      }
    }
  </style>
</head>
<body class="light">
  <header class="header">
    <div class="header-left">
      <button class="back-btn material-icons" onclick="history.back()">arrow_back</button>
      <div class="profile-header">
        <div class="avatar-wrapper">
          <div class="profile-pic-header" id="chat-profile-pic"></div>
          <span class="status-dot-header" id="status-dot-header"></span>
        </div>
        <div class="profile-details">
          <div class="profile-name-header" id="chat-profile-name">Loading...</div>
          <div class="profile-timestamp-header" id="chat-timestamp"></div>
        </div>
      </div>
    </div>
    <button class="input-icon material-icons" id="header-menu-btn" title="More options">more_vert</button>
  </header>
  <main class="main-content" id="main-content">
    <div class="messages-container" id="messages-container"></div>
  </main>
  <div class="input-bar">
    <button class="input-icon material-icons" title="Attach" onclick="attachFile()">attach_file</button>
    <div class="input-group">
      <textarea id="message-input" placeholder="Message" onkeypress="handleKeyPress(event)"></textarea>
    </div>
    <button class="send-btn material-icons" id="send-btn" title="Voice">mic</button>
  </div>
  <div id="horizontal-spinner">
    <div id="spinner-segment"></div>
  </div>
  <div id="alert-message" class="alert" role="alert" aria-live="polite"></div>
  
  <!-- FIXED: Header context menu with viewport bounds checking -->
  <div id="header-context-menu" class="context-menu">
    <div class="context-menu-item" id="delete-chat-item">
      <span class="material-icons context-menu-icon">delete</span>
      <span>Delete Chat</span>
    </div>
    <div class="context-menu-item" id="view-once-menu-item">
      <span class="material-icons context-menu-icon">visibility_off</span>
      <span>View Once</span>
    </div>
    <div class="context-menu-item" id="disappearing-menu-item">
      <span class="material-icons context-menu-icon">timer_off</span>
      <span>Disappearing</span>
    </div>
  </div>
  
  <!-- NEW: Message context menu -->
  <div id="message-context-menu" class="context-menu">
    <div class="context-menu-item" id="copy-message-item">
      <span class="material-icons context-menu-icon">content_copy</span>
      <span>Copy</span>
    </div>
    <div class="context-menu-item" id="forward-message-item">
      <span class="material-icons context-menu-icon">forward</span>
      <span>Forward</span>
    </div>
    <div class="context-menu-item" id="delete-message-item" style="display: none;">
      <span class="material-icons context-menu-icon">delete</span>
      <span>Delete</span>
    </div>
  </div>
  
  <!-- NEW: Forward message modal -->
  <div id="forward-modal" class="forward-modal">
    <div class="forward-content">
      <div class="forward-header">
        <span>Forward to Friend</span>
        <button id="close-forward-modal" class="material-icons">close</button>
      </div>
      <div class="forward-list" id="forward-friends-list"></div>
    </div>
  </div>
  
  <script type="module">
    // FIXED: Removed trailing spaces from import URLs
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js';
    import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js';
    import { getDatabase, ref, onValue, get, set, push, update, off, query, orderByChild, limitToLast, remove, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js';
   
    const firebaseConfig = {
      apiKey: "AIzaSyBOyZ3As4GTuNvjemvPF_SpsC6m6vqtNhc",
      authDomain: "fire-b-a8878.firebaseapp.com",
      // FIXED: Removed space in database URL
      databaseURL: "https://fire-b-a8878.firebaseio.com",
      projectId: "fire-b-a8878",
      storageBucket: "fire-b-a8878.firebasestorage.app",
      messagingSenderId: "658673187627",
      appId: "1:658673187627:web:6e4c29af661785f0afa36e"
    };
   
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getDatabase(app);
   
    let currentUser;
    let otherUserId;
    let chatId;
    let messagesListener;
    let userListener;
    let statusListener;
    let lastSeenListener;
    let allMessages = [];
    let otherUser = {};
   
    const verifiedIcon = `<span class="material-icons" style="font-size: 20px; color: var(--accent); vertical-align: middle;">verified</span>`;
   
    // SHARED: Encryption functions (same as main page)
    const decrypt = async (enc, chatId) => {
      try {
        const { iv, ciphertext } = JSON.parse(enc);
        const ivBuf = Uint8Array.from(atob(iv), c => c.charCodeAt(0));
        const cipherBuf = Uint8Array.from(atob(ciphertext), c => c.charCodeAt(0));
        const encoder = new TextEncoder();
        const keyMat = await crypto.subtle.importKey('raw', encoder.encode('vynix-2025'), { name: 'PBKDF2' }, false, ['deriveKey']);
        const key = await crypto.subtle.deriveKey(
          { name: 'PBKDF2', salt: encoder.encode(chatId), iterations: 100000, hash: 'SHA-256' },
          keyMat, { name: 'AES-GCM', length: 256 }, true, ['decrypt']
        );
        const dec = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: ivBuf }, key, cipherBuf);
        return new TextDecoder().decode(dec);
      } catch { return '…'; }
    };
   
    const encrypt = async (message, chatId) => {
      try {
        const encoder = new TextEncoder();
        const keyMat = await crypto.subtle.importKey('raw', encoder.encode('vynix-2025'), { name: 'PBKDF2' }, false, ['deriveKey']);
        const key = await crypto.subtle.deriveKey(
          { name: 'PBKDF2', salt: encoder.encode(chatId), iterations: 100000, hash: 'SHA-256' },
          keyMat, { name: 'AES-GCM', length: 256 }, true, ['encrypt']
        );
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const data = encoder.encode(message);
        const encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, key, data);
        const ivB64 = btoa(String.fromCharCode(...iv));
        const ciphertextB64 = btoa(String.fromCharCode(...new Uint8Array(encrypted)));
        return JSON.stringify({ iv: ivB64, ciphertext: ciphertextB64 });
      } catch (error) {
        console.error('Encryption failed:', error);
        throw error;
      }
    };
   
    const showSpinner = () => document.getElementById('horizontal-spinner').classList.add('active');
    const hideSpinner = () => document.getElementById('horizontal-spinner').classList.remove('active');
    const showAlert = (message) => {
      const alert = document.getElementById('alert-message');
      alert.textContent = message;
      alert.classList.add('active');
      setTimeout(() => alert.classList.remove('active'), 3000);
    };
   
    // WhatsApp-style timestamp formatting
    const formatTime = (timestamp) => {
      return new Date(timestamp).toLocaleTimeString('en-US', { 
        hour: 'numeric', 
        minute: '2-digit',
        hour12: true 
      });
    };

    const formatDateHeader = (timestamp) => {
      const date = new Date(timestamp);
      const today = new Date();
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);
      
      if (date.toDateString() === today.toDateString()) {
        return 'Today';
      } else if (date.toDateString() === yesterday.toDateString()) {
        return 'Yesterday';
      } else {
        return date.toLocaleDateString('en-US', { 
          weekday: 'long', 
          month: 'long', 
          day: 'numeric' 
        });
      }
    };
    
    // NEW: Format last seen like WhatsApp
    const formatLastSeen = (timestamp) => {
      const now = Date.now();
      const diff = now - timestamp;
      const minutes = Math.floor(diff / 60000);
      const hours = Math.floor(diff / 3600000);
      const days = Math.floor(diff / 86400000);
      
      if (minutes < 1) return 'just now';
      if (minutes < 60) return `${minutes} minutes ago`;
      if (hours < 24) return `${hours} hours ago`;
      if (days === 1) return 'yesterday';
      if (days < 7) return `${days} days ago`;
      
      const date = new Date(timestamp);
      return `on ${date.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric' 
      })} at ${formatTime(timestamp)}`;
    };
   
    const loadProfileInfo = async () => {
      if (!otherUserId) {
        showAlert('No user ID provided');
        return;
      }
     
      showSpinner();
     
      try {
        const userRef = ref(db, `users/${otherUserId}`);
        const initialSnap = await get(userRef);
       
        if (initialSnap.exists()) {
          const userData = initialSnap.val();
          otherUser = userData;
          updateProfileUI(userData);
        } else {
          console.warn(`User document not found for UID: ${otherUserId}`);
          updateProfileUI({ displayName: 'User', email: 'Unknown' });
        }
       
        // Real-time user updates
        userListener = onValue(userRef, (snap) => {
          if (snap.exists()) {
            otherUser = snap.val();
            updateProfileUI(snap.val());
          }
        });
       
        // NEW: Enhanced online status with last seen
        setupOnlineStatus();
       
      } catch (error) {
        console.error('Failed to load profile:', error);
        showAlert('Failed to load chat info');
        updateProfileUI({ displayName: 'User', email: 'Unknown' });
      } finally {
        hideSpinner();
      }
    };
   
    const updateProfileUI = (userInfo) => {
      const displayName = userInfo.displayName || userInfo.email || 'User';
      const nameEl = document.getElementById('chat-profile-name');
      nameEl.innerHTML = userInfo.verified ? displayName + verifiedIcon : displayName;
     
      // Timestamp will be updated by online status listener
    };
    
    // NEW: Real-time online/last-seen status
    const setupOnlineStatus = () => {
      // Online status listener
      statusListener = onValue(ref(db, `users/${otherUserId}/status`), (snap) => {
        const status = snap.val() || 'offline';
        const dot = document.getElementById('status-dot-header');
        const tsEl = document.getElementById('chat-timestamp');
        
        if (status === 'online') {
          dot.style.display = 'block';
          dot.classList.remove('offline');
          tsEl.textContent = 'online';
        } else {
          dot.style.display = 'block';
          dot.classList.add('offline');
          // Show last seen if available
          if (otherUser.lastSeen) {
            tsEl.textContent = `last seen ${formatLastSeen(otherUser.lastSeen)}`;
          } else {
            tsEl.textContent = 'offline';
          }
        }
      });
      
      // Last seen listener
      lastSeenListener = onValue(ref(db, `users/${otherUserId}/lastSeen`), (snap) => {
        const lastSeen = snap.val();
        if (lastSeen) {
          otherUser.lastSeen = lastSeen;
          const dot = document.getElementById('status-dot-header');
          // Only update if currently offline
          if (dot.classList.contains('offline')) {
            document.getElementById('chat-timestamp').textContent = 
              `last seen ${formatLastSeen(lastSeen)}`;
          }
        }
      });
    };
   
    const renderMessage = (message, isSent) => {
      let displayContent;
      const isViewOnce = message.viewOnce;
      const isViewed = isViewOnce && !isSent && message.viewedBy?.[currentUser.uid];
     
      if (isViewOnce && isViewed) {
        const placeholder = message.type === 'image' ? 'Photo' : message.type === 'video' ? 'Video' : 'Message';
        displayContent = `<div style="padding:12px 16px; font-style:italic; color:var(--text-secondary);">${placeholder} viewed</div>`;
      } else {
        if (message.type === 'text') {
          displayContent = message.decrypted;
          if (message.edited) displayContent += `<div class="edit-indicator" style="font-size:10px; opacity:0.7; margin-top:4px;">edited</div>`;
        } else if (message.type === 'image') {
          displayContent = `<img src="${message.message}" alt="Photo" style="max-width: 250px; border-radius: 12px; cursor: pointer;" onclick="window.open('${message.message}')">`;
        } else if (message.type === 'video') {
          displayContent = `<video src="${message.message}" controls style="max-width: 250px; border-radius: 12px;"></video>`;
        } else {
          displayContent = message.decrypted || 'Media';
        }
      }
     
      const bubbleClass = isSent ? 'message-sent' : 'message-received';
      
      // WhatsApp-style time with AM/PM
      const time = formatTime(message.timestamp);
      
      // Message status checkmarks
      let statusIcon = '';
      let statusClass = '';
      if (isSent) {
        if (message.readBy && message.readBy[otherUserId]) {
          statusIcon = '✓✓';
          statusClass = 'status-read';
        } else if (message.delivered) {
          statusIcon = '✓✓';
          statusClass = 'status-delivered';
        } else {
          statusIcon = '✓';
          statusClass = 'status-sent';
        }
      }
      
      // Avatar for received messages only
      const avatarHtml = !isSent ? `
        <div class="message-avatar">
          <img src="${otherUser.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(otherUser.displayName || 'U')}&background=05d9e8&color=fff`}" 
               alt="Profile" loading="lazy">
        </div>
      ` : '';
     
      // NEW: Add context menu data attributes
      return `
        <div class="message-item ${bubbleClass}" 
             data-message-id="${message.id}" 
             data-is-sent="${isSent}"
             data-message-type="${message.type}"
             oncontextmenu="return false;">
          ${avatarHtml}
          <div class="message-bubble" onselectstart="return false;" data-message-id="${message.id}">
            ${displayContent}
            <div class="message-time">
              ${time}
              ${isSent ? `<span class="message-status ${statusClass}">${statusIcon}</span>` : ''}
            </div>
          </div>
        </div>
      `;
    };
   
    const updateMessages = (messages) => {
      const container = document.getElementById('messages-container');
      container.innerHTML = '';
      let lastDate = null;
     
      messages.forEach(msg => {
        const msgDate = formatDateHeader(msg.timestamp);
        if (msgDate !== lastDate) {
          container.innerHTML += `<div class="message-date">${msgDate}</div>`;
          lastDate = msgDate;
        }
        const isSent = msg.senderId === currentUser.uid;
        container.innerHTML += renderMessage(msg, isSent);
      });
     
      if (messages.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">No messages yet. Start the conversation!</p>';
      }
      container.scrollTop = container.scrollHeight;
      
      // NEW: Setup message context menu listeners
      setupMessageContextMenu();
    };
   
    const markMessagesAsRead = async () => {
      const updates = {};
      allMessages.forEach(msg => {
        if (msg.senderId !== currentUser.uid && !msg.readBy?.[currentUser.uid]) {
          updates[`chats/${chatId}/messages/${msg.id}/readBy/${currentUser.uid}`] = Date.now();
          updates[`users/${currentUser.uid}/chats/${otherUserId}/unreadCount`] = 0;
        }
      });
      if (Object.keys(updates).length) await update(ref(db), updates);
    };
   
    const setupMessagesListener = () => {
      if (messagesListener) off(messagesListener);
     
      const messagesRef = ref(db, `chats/${chatId}/messages`);
      const orderedRef = query(messagesRef, orderByChild('timestamp'), limitToLast(100));
     
      messagesListener = onValue(orderedRef, async (snapshot) => {
        if (snapshot.exists()) {
          allMessages = Object.entries(snapshot.val())
            .map(([id, m]) => ({ id, ...m }))
            .sort((a, b) => a.timestamp - b.timestamp);
         
          for (const msg of allMessages) {
            if (msg.type === 'text' && !msg.decrypted) {
              msg.decrypted = await decrypt(msg.message, chatId);
            }
          }
         
          await markMessagesAsRead();
          updateMessages(allMessages);
        } else {
          allMessages = [];
          document.getElementById('messages-container').innerHTML = '<p style="text-align: center; color: var(--text-secondary);">No messages yet. Start the conversation!</p>';
        }
      });
    };
   
    window.sendMessage = async () => {
      const input = document.getElementById('message-input');
      const text = input.value.trim();
      if (!text) return;
     
      try {
        showSpinner();
        const encrypted = await encrypt(text, chatId);
        const messagesRef = ref(db, `chats/${chatId}/messages`);
        const newMessageRef = push(messagesRef);
        const timestamp = Date.now();
       
        await set(newMessageRef, {
          senderId: currentUser.uid,
          message: encrypted,
          type: 'text',
          timestamp: timestamp,
          status: 'sent',
          delivered: false
        });
       
        const chatUpdate = {
          lastMessage: encrypted,
          lastMessageType: 'text',
          lastMessageTime: timestamp
        };
       
        await update(ref(db, `users/${currentUser.uid}/chats/${otherUserId}`), chatUpdate);
        
        // Increment unread count for recipient
        const unreadRef = ref(db, `users/${otherUserId}/chats/${currentUser.uid}/unreadCount`);
        const currentCount = (await get(unreadRef)).val() || 0;
        await set(unreadRef, currentCount + 1);
       
        input.value = '';
        input.style.height = 'auto';
      } catch (error) {
        console.error('Failed to send message:', error);
        showAlert('Failed to send message.');
      } finally {
        hideSpinner();
      }
    };
   
    window.attachFile = async () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*,video/*';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
       
        showSpinner();
        const progressDiv = document.getElementById('media-progress');
        const progressBar = document.getElementById('media-progress-bar');
        progressDiv.style.display = 'block';
       
        try {
          // FIXED: Use configured Cloudinary endpoint
          const xhr = new XMLHttpRequest();
          xhr.open('POST', `https://api.cloudinary.com/v1_1/dqkujefxj/upload`);
          const formData = new FormData();
          formData.append('file', file);
          formData.append('upload_preset', 'banter_box');
         
          await new Promise((resolve, reject) => {
            xhr.upload.addEventListener('progress', (ev) => {
              if (ev.lengthComputable) {
                progressBar.style.width = Math.round((ev.loaded / ev.total) * 100) + '%';
              }
            });
            xhr.onload = () => {
              if (xhr.status === 200) resolve(JSON.parse(xhr.responseText));
              else reject(new Error(`Upload failed: ${xhr.statusText}`));
            };
            xhr.onerror = reject;
            xhr.send(formData);
          });
         
          const { secure_url } = JSON.parse(xhr.responseText);
          const type = file.type.startsWith('image/') ? 'image' : 'video';
          await sendMediaMessage(secure_url, type);
        } catch (error) {
          console.error('Failed to send media:', error);
          showAlert('Failed to send media.');
        } finally {
          hideSpinner();
          progressDiv.style.display = 'none';
          progressBar.style.width = '0%';
        }
      };
      input.click();
    };
   
    async function sendMediaMessage(url, type) {
      try {
        const messagesRef = ref(db, `chats/${chatId}/messages`);
        const newMessageRef = push(messagesRef);
        const timestamp = Date.now();
       
        await set(newMessageRef, {
          senderId: currentUser.uid,
          message: url,
          type: type,
          timestamp: timestamp,
          status: 'sent',
          delivered: false
        });
       
        const chatUpdate = {
          lastMessage: `[${type === 'image' ? 'Photo' : 'Video'}]`,
          lastMessageType: type,
          lastMessageTime: timestamp
        };
       
        await update(ref(db, `users/${currentUser.uid}/chats/${otherUserId}`), chatUpdate);
        
        const unreadRef = ref(db, `users/${otherUserId}/chats/${currentUser.uid}/unreadCount`);
        const currentCount = (await get(unreadRef)).val() || 0;
        await set(unreadRef, currentCount + 1);
      } catch (error) {
        console.error('Failed to send media message:', error);
        showAlert('Failed to send media message.');
      }
    }
   
    window.handleKeyPress = (event) => {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
      }
    };
   
    const setupSendButton = () => {
      const input = document.getElementById('message-input');
      const sendBtn = document.getElementById('send-btn');
     
      input.addEventListener('focus', () => {
        sendBtn.innerHTML = 'send';
        sendBtn.title = 'Send';
        sendBtn.onclick = sendMessage;
      });
     
      input.addEventListener('blur', () => {
        if (!input.value.trim()) {
          sendBtn.innerHTML = 'mic';
          sendBtn.title = 'Voice';
          sendBtn.onclick = () => showAlert('Voice recording coming soon!');
        }
      });
     
      input.addEventListener('input', () => {
        input.style.height = 'auto';
        input.style.height = Math.min(input.scrollHeight, 120) + 'px';
      });
     
      sendBtn.onclick = () => showAlert('Voice recording coming soon!');
    };
    
    // FIXED: Header menu with viewport bounds checking
    document.getElementById('header-menu-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      const menu = document.getElementById('header-context-menu');
      const rect = e.target.getBoundingClientRect();
      
      // Calculate initial position
      let left = rect.left;
      let top = rect.bottom + 8;
      
      // Force render to get dimensions
      menu.style.visibility = 'hidden';
      menu.classList.add('active');
      const menuRect = menu.getBoundingClientRect();
      menu.classList.remove('active');
      menu.style.visibility = 'visible';
      
      // Adjust for viewport bounds
      if (left + menuRect.width > window.innerWidth - 8) {
        left = window.innerWidth - menuRect.width - 8;
      }
      if (top + menuRect.height > window.innerHeight - 8) {
        top = rect.top - menuRect.height - 8;
      }
      if (left < 8) left = 8;
      if (top < 8) top = 8;
      
      menu.style.left = `${left}px`;
      menu.style.top = `${top}px`;
      menu.classList.add('active');
      
      // Close on outside click
      setTimeout(() => {
        const close = (ev) => {
          if (!menu.contains(ev.target) && ev.target !== document.getElementById('header-menu-btn')) {
            menu.classList.remove('active');
            document.removeEventListener('click', close);
          }
        };
        document.addEventListener('click', close);
      }, 10);
    });
    
    // NEW: Delete chat functionality
    document.getElementById('delete-chat-item').addEventListener('click', () => {
      const menu = document.getElementById('header-context-menu');
      menu.classList.remove('active');
      
      showCustomAlert('Delete Chat', 'Delete this entire chat? This cannot be undone.', async () => {
        try {
          // Remove chat metadata for both users
          await remove(ref(db, `users/${currentUser.uid}/chats/${otherUserId}`));
          await remove(ref(db, `users/${otherUserId}/chats/${currentUser.uid}`));
          
          // Note: Messages are kept in chats/chatId for privacy
          // To delete messages too, uncomment:
          // await remove(ref(db, `chats/${chatId}`));
          
          showAlert('Chat deleted');
          history.back();
        } catch (error) {
          console.error('Delete chat error:', error);
          showAlert('Failed to delete chat');
        }
      });
    });
    
    // NEW: Message context menu setup
    let contextMenuMessage = null;
    
    function setupMessageContextMenu() {
      // Long press for mobile
      let longPressTimer;
      document.querySelectorAll('.message-bubble').forEach(bubble => {
        bubble.addEventListener('touchstart', (e) => {
          longPressTimer = setTimeout(() => {
            showMessageContextMenu(e, bubble);
          }, 500);
        });
        
        bubble.addEventListener('touchend', () => {
          clearTimeout(longPressTimer);
        });
        
        bubble.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          showMessageContextMenu(e, bubble);
        });
      });
    }
    
    function showMessageContextMenu(e, bubble) {
      const menu = document.getElementById('message-context-menu');
      const messageItem = bubble.closest('.message-item');
      const isSent = messageItem.dataset.isSent === 'true';
      const messageId = messageItem.dataset.messageId;
      
      // Store context
      contextMenuMessage = {
        id: messageId,
        type: messageItem.dataset.messageType,
        isSent: isSent,
        text: bubble.textContent.replace(/✓.*$/, '').trim(), // Remove checkmarks
        element: messageItem
      };
      
      // Show/hide delete option
      document.getElementById('delete-message-item').style.display = 
        isSent ? 'flex' : 'none';
      
      // Position menu
      let left = e.clientX || e.targetTouches[0].clientX;
      let top = e.clientY || e.targetTouches[0].clientY;
      
      // Viewport bounds check
      const menuRect = menu.getBoundingClientRect();
      if (left + menuRect.width > window.innerWidth - 8) {
        left = window.innerWidth - menuRect.width - 8;
      }
      if (top + menuRect.height > window.innerHeight - 8) {
        top = window.innerHeight - menuRect.height - 8;
      }
      
      menu.style.left = `${left}px`;
      menu.style.top = `${top}px`;
      menu.classList.add('active');
      
      // Close on outside click
      setTimeout(() => {
        const close = (ev) => {
          if (!menu.contains(ev.target)) {
            menu.classList.remove('active');
            document.removeEventListener('click', close);
          }
        };
        document.addEventListener('click', close);
      }, 10);
    }
    
    // NEW: Copy message
    document.getElementById('copy-message-item').addEventListener('click', () => {
      if (contextMenuMessage && contextMenuMessage.type === 'text') {
        navigator.clipboard.writeText(contextMenuMessage.text).then(() => {
          showAlert('Copied to clipboard');
        }).catch(err => {
          console.error('Copy failed:', err);
          showAlert('Copy failed');
        });
      }
      document.getElementById('message-context-menu').classList.remove('active');
    });
    
    // NEW: Delete message
    document.getElementById('delete-message-item').addEventListener('click', () => {
      if (!contextMenuMessage || !contextMenuMessage.isSent) return;
      
      document.getElementById('message-context-menu').classList.remove('active');
      
      showCustomAlert('Delete Message', 'Delete this message for everyone?', async () => {
        try {
          await remove(ref(db, `chats/${chatId}/messages/${contextMenuMessage.id}`));
          showAlert('Message deleted');
        } catch (error) {
          showAlert('Failed to delete message');
        }
      });
    });
    
    // NEW: Forward message
    document.getElementById('forward-message-item').addEventListener('click', async () => {
      if (!contextMenuMessage) return;
      
      const modal = document.getElementById('forward-modal');
      const list = document.getElementById('forward-friends-list');
      
      // Load followed friends
      showSpinner();
      try {
        const followingSnap = await get(ref(db, `users/${currentUser.uid}/following`));
        const following = followingSnap.val() || {};
        
        list.innerHTML = '';
        let hasFriends = false;
        
        for (const friendId of Object.keys(following)) {
          if (friendId === otherUserId) continue; // Skip current chat
          
          const userSnap = await get(ref(db, `users/${friendId}`));
          const user = userSnap.val();
          if (!user) continue;
          
          hasFriends = true;
          const item = document.createElement('div');
          item.className = 'forward-friend-item';
          item.innerHTML = `
            <img src="${user.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(user.displayName || 'U')}&background=05d9e8&color=fff`}" 
                 class="w-10 h-10 rounded-full" alt="${user.displayName}">
            <div class="flex-1">
              <div class="font-medium">${user.displayName || user.email}</div>
              <div class="text-sm text-gray-500">${user.verified ? 'Verified' : ''}</div>
            </div>
          `;
          item.addEventListener('click', () => forwardMessageTo(friendId));
          list.appendChild(item);
        }
        
        if (!hasFriends) {
          list.innerHTML = '<p class="text-center py-4 text-gray-500">No other friends to forward to</p>';
        }
        
        modal.classList.add('active');
      } catch (error) {
        console.error('Load friends error:', error);
        showAlert('Failed to load friends');
      } finally {
        hideSpinner();
      }
      
      document.getElementById('message-context-menu').classList.remove('active');
    });
    
    async function forwardMessageTo(friendId) {
      if (!contextMenuMessage) return;
      
      const targetChatId = [currentUser.uid, friendId].sort().join('_');
      
      try {
        // Get original message
        const originalMsg = allMessages.find(m => m.id === contextMenuMessage.id);
        if (!originalMsg) return;
        
        let forwardContent = '';
        if (originalMsg.type === 'text') {
          forwardContent = `Forwarded: ${originalMsg.decrypted}`;
        } else {
          forwardContent = `Forwarded ${originalMsg.type}: [${originalMsg.type === 'image' ? 'Photo' : 'Video'}]`;
        }
        
        const encrypted = await encrypt(forwardContent, targetChatId);
        
        const newMsgRef = push(ref(db, `chats/${targetChatId}/messages`));
        await set(newMsgRef, {
          senderId: currentUser.uid,
          message: encrypted,
          type: 'text',
          timestamp: Date.now(),
          isForwarded: true
        });
        
        showAlert('Message forwarded');
      } catch (error) {
        console.error('Forward error:', error);
        showAlert('Failed to forward message');
      }
      
      document.getElementById('forward-modal').classList.remove('active');
    }
    
    // Close forward modal
    document.getElementById('close-forward-modal').addEventListener('click', () => {
      document.getElementById('forward-modal').classList.remove('active');
    });
    
    // Custom alert helper
    function showCustomAlert(title, message, onConfirm) {
      const alertBox = document.createElement('div');
      alertBox.className = 'fixed inset-0 bg-black/50 flex items-center justify-center z-[2000]';
      alertBox.innerHTML = `
        <div class="bg-card-bg rounded-2xl p-6 m-4 max-w-sm w-full border border-border">
          <h3 class="text-lg font-bold mb-2">${title}</h3>
          <p class="text-text-secondary mb-4">${message}</p>
          <div class="flex gap-3 justify-end">
            <button class="px-4 py-2 rounded-full bg-border text-text-primary" id="alert-cancel">Cancel</button>
            <button class="px-4 py-2 rounded-full bg-accent text-white" id="alert-confirm">Confirm</button>
          </div>
        </div>
      `;
      document.body.appendChild(alertBox);
      
      alertBox.querySelector('#alert-cancel').onclick = () => alertBox.remove();
      alertBox.querySelector('#alert-confirm').onclick = () => {
        onConfirm();
        alertBox.remove();
      };
    }
   
    onAuthStateChanged(auth, async (user) => {
      currentUser = user;
      if (!user) {
        location.href = 'login.html';
        return;
      }
     
      const urlParams = new URLSearchParams(window.location.search);
      chatId = urlParams.get('chatId');
      otherUserId = urlParams.get('userId');
     
      if (!chatId || !otherUserId) {
        showAlert('Invalid chat link.');
        history.back();
        return;
      }
     
      loadProfileInfo();
      setupMessagesListener();
      setupSendButton();
    });
   
    // FIXED: Cleanup all listeners on unload
    window.addEventListener('beforeunload', () => {
      if (messagesListener) off(messagesListener);
      if (userListener) off(userListener);
      if (statusListener) off(statusListener);
      if (lastSeenListener) off(lastSeenListener);
    });
  </script>
</body>
</html>
