<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-touch-fullscreen" content="yes">
  <title>BBM 2025 - Chat</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-analytics.js"></script>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0a0a0a;
      --card-bg: #1a1a1a;
      --text-primary: #ffffff;
      --text-secondary: #b0b0b0;
      --border: #333333;
      --accent: #d40000;
      --bbm-red: #d40000;
      --header-bg: #000000;
      --chat-bubble-sent: #3d3d3d;
      --chat-bubble-received: #212121;
      --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 8px 24px rgba(0, 0, 0, 0.4);
      --glow: 0 0 20px rgba(212, 0, 0, 0.5);
    }
    body.light {
      --bg: #f8f8f8;
      --card-bg: #ffffff;
      --text-primary: #000000;
      --text-secondary: #666666;
      --border: #e0e0e0;
      --header-bg: #ffffff;
      --chat-bubble-sent: #e6f3ff;
      --chat-bubble-received: #ffffff;
    }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      background: var(--bg);
      color: var(--text-primary);
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      line-height: 1.6;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    * {
      -webkit-touch-callout: none !important;
    }
    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: var(--header-bg);
      z-index: 100;
      padding: 12px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 64px;
      box-shadow: var(--shadow-sm);
      transition: background-color 0.3s ease;
    }
    body.light .header {
      background: var(--header-bg);
    }
    .header-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .back-btn {
      background: none;
      border: none;
      color: var(--text-primary);
      font-size: 24px;
      cursor: pointer;
      padding: 8px;
      border-radius: 50%;
      transition: all 0.3s ease;
    }
    .back-btn:hover {
      background: rgba(212, 0, 0, 0.1);
      color: var(--bbm-red);
    }
    .chat-header-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .chat-avatar {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      object-fit: cover;
      flex-shrink: 0;
      box-shadow: var(--shadow-sm);
    }
    .chat-name {
      font-weight: 700;
      font-size: 17px;
      color: var(--text-primary);
    }
    .status-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 13px;
      color: var(--text-secondary);
    }
    .online-dot {
      width: 8px;
      height: 8px;
      background: #00ff88;
      border-radius: 50%;
    }
    .offline-dot {
      width: 8px;
      height: 8px;
      background: #666;
      border-radius: 50%;
    }
    .header-right {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .header-actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .header-actions button {
      background: var(--card-bg);
      border: 1px solid var(--border);
      color: var(--text-primary);
      border-radius: 50%;
      padding: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 44px;
      min-width: 44px;
      box-shadow: var(--shadow-sm);
      position: relative;
      transition: all 0.3s ease;
    }
    .header-actions button:hover {
      border-color: var(--bbm-red);
      box-shadow: var(--glow);
      transform: scale(1.05);
    }
    .main-content {
      padding: 84px 20px 120px;
      min-height: calc(100vh - 160px);
      transition: padding 0.3s ease;
      display: flex;
      flex-direction: column;
    }
    .messages-container {
      flex: 1;
      overflow-y: auto;
      padding: 20px 0;
      display: flex;
      flex-direction: column;
      gap: 12px;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    .messages-container::-webkit-scrollbar {
      display: none;
    }
    .message-bubble {
      max-width: 80%;
      padding: 12px 16px;
      border-radius: 20px;
      word-wrap: break-word;
      font-size: 15px;
      line-height: 1.4;
      position: relative;
      margin-bottom: 4px;
    }
    .message-bubble.sent {
      background: var(--chat-bubble-sent);
      color: var(--text-primary);
      align-self: flex-end;
      border-bottom-right-radius: 4px;
    }
    .message-bubble.received {
      background: var(--chat-bubble-received);
      color: var(--text-primary);
      align-self: flex-start;
      border-bottom-left-radius: 4px;
    }
    body.light .message-bubble.sent {
      background: var(--chat-bubble-sent);
    }
    body.light .message-bubble.received {
      background: var(--chat-bubble-received);
    }
    .message-time {
      font-size: 12px;
      color: var(--text-secondary);
      margin-top: 4px;
    }
    .message-bubble.sent .message-time {
      text-align: right;
    }
    .message-bubble.received .message-time {
      text-align: left;
    }
    .message-status {
      display: flex;
      align-items: center;
      gap: 2px;
      font-size: 12px;
      color: var(--text-secondary);
      margin-top: 4px;
    }
    .status-icon {
      font-size: 14px;
    }
    .read-icon {
      color: #00ff88;
    }
    .delivered-icon {
      color: #b0b0b0;
    }
    .media-message {
      max-width: 100%;
      margin: 8px 0;
    }
    .media-message img {
      max-width: 100%;
      border-radius: 12px;
      cursor: pointer;
    }
    .document-message {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      background: var(--card-bg);
      border-radius: 8px;
      border: 1px solid var(--border);
    }
    .document-icon {
      font-size: 24px;
      color: var(--bbm-red);
    }
    .document-info {
      flex: 1;
    }
    .document-name {
      font-size: 14px;
      color: var(--text-primary);
      word-break: break-word;
    }
    .document-download {
      color: var(--text-secondary);
      font-size: 12px;
      text-decoration: underline;
      cursor: pointer;
    }
    .audio-message {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      margin: 8px 0;
    }
    .audio-message audio {
      width: 100%;
      max-width: 250px;
    }
    .audio-message canvas {
      width: 100%;
      max-width: 250px;
      height: 40px;
      border-radius: 20px;
      background: rgba(0,0,0,0.1);
      margin-top: 5px;
    }
    .audio-duration {
      font-size: 12px;
      color: var(--text-secondary);
      text-align: center;
      margin-top: 2px;
    }
    .typing-indicator {
      align-self: flex-start;
      font-style: italic;
      color: var(--bbm-red);
      font-size: 15px;
      padding: 12px 16px;
      background: var(--chat-bubble-received);
      border-radius: 20px;
      border-bottom-left-radius: 4px;
      max-width: 80%;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .typing-dots {
      display: flex;
      gap: 4px;
    }
    .typing-dot {
      width: 6px;
      height: 6px;
      background: var(--bbm-red);
      border-radius: 50%;
      animation: typing 1.4s ease-in-out infinite;
    }
    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }
    @keyframes typing {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-10px); }
    }
    .input-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--card-bg);
      border-top: 1px solid var(--border);
      padding: 12px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 100;
      box-shadow: var(--shadow-sm);
      transition: all 0.3s ease;
    }
    .attach-btn, .record-btn {
      background: var(--card-bg);
      border: 1px solid var(--border);
      color: var(--text-primary);
      border-radius: 50%;
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 20px;
    }
    .attach-btn:hover, .record-btn:hover:not(.recording) {
      border-color: var(--bbm-red);
      box-shadow: var(--glow);
    }
    .record-btn.recording {
      background: var(--bbm-red);
      color: white;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    #recording-waveform {
      display: none;
      margin-left: 10px;
    }
    #recording-waveform canvas {
      border-radius: 20px;
      background: var(--card-bg);
    }
    .input-pill {
      flex: 1;
      display: flex;
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 28px;
      overflow: hidden;
      box-shadow: var(--shadow-sm);
      transition: border-color 0.3s ease;
    }
    .input-pill:focus-within {
      border-color: var(--bbm-red);
      box-shadow: 0 0 0 3px rgba(212, 0, 0, 0.1);
    }
    .message-input {
      flex: 1;
      background: none;
      border: none;
      outline: none;
      padding: 14px 20px;
      color: var(--text-primary);
      font-size: 16px;
      resize: none;
      max-height: 120px;
      min-height: 20px;
      line-height: 1.4;
    }
    .message-input:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .send-btn {
      background: var(--bbm-red);
      color: white;
      border: none;
      padding: 14px 20px;
      cursor: pointer;
      font-weight: 700;
      border-radius: 50%;
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: var(--shadow-sm);
      transition: all 0.3s ease;
    }
    .send-btn:hover:not(:disabled) {
      background: #b30000;
      box-shadow: var(--glow);
      transform: scale(1.1);
    }
    .send-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .call-buttons {
      display: flex;
      gap: 8px;
    }
    .call-btn {
      background: var(--card-bg);
      border: 1px solid var(--border);
      color: var(--text-primary);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 20px;
    }
    .call-btn:hover {
      border-color: var(--bbm-red);
      box-shadow: var(--glow);
    }
    .video-call-btn {
      color: #00ff88;
    }
    .voice-call-btn {
      color: #ff00ff;
    }
    .verified-icon-container {
      display: inline-flex;
      align-items: center;
    }
    .verified-badge {
      position: relative;
      width: 18px;
      height: 18px;
      display: inline-block;
    }
    .circle {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 10.8px;
      height: 10.8px;
      background: #1DA1F2;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      z-index: 2;
    }
    .checkmark {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(45deg);
      width: 3.6px;
      height: 1.8px;
      border: solid white;
      border-width: 0 0.9px 0.9px 0;
      z-index: 3;
    }
    .checkmark::after {
      content: '';
      position: absolute;
      left: -2.25px;
      top: 0.9px;
      width: 0.9px;
      height: 3.6px;
      border: solid white;
      border-width: 0 0.9px 0.9px 0;
      transform: rotate(-90deg);
    }
    .star-point {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-left: 1.35px solid transparent;
      border-right: 1.35px solid transparent;
      border-bottom: 5.4px solid #1DA1F2;
      transform: translate(-50%, -50%) rotate(0deg);
      z-index: 1;
    }
    .point-0 { transform: translate(-50%, -50%) rotate(0deg); }
    .point-1 { transform: translate(-50%, -50%) rotate(45deg); }
    .point-2 { transform: translate(-50%, -50%) rotate(90deg); }
    .point-3 { transform: translate(-50%, -50%) rotate(135deg); }
    .point-4 { transform: translate(-50%, -50%) rotate(180deg); }
    .point-5 { transform: translate(-50%, -50%) rotate(225deg); }
    .point-6 { transform: translate(-50%, -50%) rotate(270deg); }
    .point-7 { transform: translate(-50%, -50%) rotate(315deg); }
    @media (min-width: 768px) {
      .main-content {
        padding: 84px 60px 120px;
      }
      .input-bar {
        padding: 12px 60px;
      }
    }
    .alert {
      position: fixed;
      top: 84px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bbm-red);
      color: #000000;
      padding: 16px 28px;
      border-radius: 28px;
      display: none;
      z-index: 1000;
      box-shadow: var(--shadow-md), var(--glow);
      font-weight: 700;
      font-size: 15px;
      animation: slideDown 0.3s ease;
    }
    @keyframes slideDown {
      from { transform: translateX(-50%) translateY(-100%); opacity: 0; }
      to { transform: translateX(-50%) translateY(0); opacity: 1; }
    }
    .alert.active {
      display: block;
    }
  </style>
</head>
<body class="dark">
  <header class="header">
    <div class="header-left">
      <button class="back-btn material-icons" onclick="window.location.href='index.html'" aria-label="Back">arrow_back</button>
      <div class="chat-header-info" id="chat-header-info">
        <!-- User info loaded here -->
      </div>
    </div>
    <div class="header-right">
      <div class="header-actions">
        <button id="voice-call-btn" class="call-btn material-icons voice-call-btn" title="Voice Call" aria-label="Voice Call">call</button>
        <button id="video-call-btn" class="call-btn material-icons video-call-btn" title="Video Call" aria-label="Video Call">videocam</button>
      </div>
    </div>
  </header>

  <main class="main-content">
    <div class="messages-container" id="messages-container">
      <!-- Messages loaded here -->
    </div>
  </main>

  <div class="input-bar">
    <button id="attach-btn" class="attach-btn material-icons" title="Attach file" aria-label="Attach file">attach_file</button>
    <button id="record-btn" class="record-btn material-icons" title="Record voice message" aria-label="Record voice message">mic</button>
    <div id="recording-waveform">
      <canvas id="wave-canvas" width="100" height="40"></canvas>
    </div>
    <div class="input-pill">
      <textarea id="message-input" class="message-input" placeholder="Type a message..." rows="1" aria-label="Message input"></textarea>
    </div>
    <button id="send-btn" class="send-btn material-icons" disabled>send</button>
  </div>
  <input type="file" id="file-input" accept="image/*,.pdf,.doc,.docx" style="display: none;" onchange="handleFileUpload(event)">

  <div id="alert-message" class="alert" role="alert" aria-live="polite"></div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js';
    import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js';
    import { getDatabase, ref, onValue, get, push, set, update, off, onDisconnect } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js';
    import { getAnalytics, logEvent, setUserId } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-analytics.js';

    const firebaseConfig = {
      apiKey: "AIzaSyBOyZ3As4GTuNvjemvPF_SpsC6m6vqtNhc",
      authDomain: "fire-b-a8878.firebaseapp.com",
      databaseURL: "https://fire-b-a8878.firebaseio.com",
      projectId: "fire-b-a8878",
      storageBucket: "fire-b-a8878.firebasestorage.app",
      messagingSenderId: "658673187627",
      appId: "1:658673187627:web:6e4c29af661785f0afa36e",
      measurementId: "G-V4W97VMSKL"
    };

    const cloudinaryConfig = {
      cloudName: 'dqkujefxj',
      uploadPreset: 'banter_box'
    };

    const verifiedIcon = `<div class="verified-badge">
      <div class="circle">
        <div class="checkmark"></div>
      </div>
      <div class="star-point point-0"></div>
      <div class="star-point point-1"></div>
      <div class="star-point point-2"></div>
      <div class="star-point point-3"></div>
      <div class="star-point point-4"></div>
      <div class="star-point point-5"></div>
      <div class="star-point point-6"></div>
      <div class="star-point point-7"></div>
    </div>`;

    let app, auth, db, analytics, currentUser;
    let currentChatId, currentOtherUid;
    let messagesListener = null;
    let typingTimeout = null;
    let isTyping = false;
    let mediaRecorder = null;
    let recordedChunks = [];
    let audioStream = null;
    let isRecording = false;
    let isInitialLoad = true;
    let lastLoadedTimestamp = 0;
    let recorderCtx = null;
    let recorderSource = null;
    let recorderAnalyser = null;
    let recorderDataArray = null;
    let recorderRafId = null;
    let presenceListener = null;
    let otherUserPresence = { online: false, lastSeen: null };

    const showAlert = (message) => {
      const alert = document.getElementById('alert-message');
      if (alert) {
        alert.textContent = message;
        alert.classList.add('active');
        setTimeout(() => alert.classList.remove('active'), 4000);
      }
    };

    function formatTimestamp(timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const diffMs = now - date;
      const diffSec = Math.floor(diffMs / 1000);
      const diffMin = Math.floor(diffSec / 60);
      if (diffSec < 60) return `${diffSec}s`;
      if (diffMin < 60) return `${diffMin}m`;
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    function formatLastSeen(timestamp) {
      if (!timestamp) return 'Never';
      const date = new Date(timestamp);
      const now = new Date();
      const diffMs = now - date;
      const diffSec = Math.floor(diffMs / 1000);
      const diffMin = Math.floor(diffSec / 60);
      const diffHours = Math.floor(diffMin / 60);
      const diffDays = Math.floor(diffHours / 24);
      if (diffSec < 60) return 'Just now';
      if (diffMin < 60) return `${diffMin}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      if (diffDays < 7) return `${diffDays}d ago`;
      return date.toLocaleDateString();
    }

    function updatePresenceStatus() {
      const statusDiv = document.querySelector('#chat-header-info .status-indicator');
      if (!statusDiv) return;
      if (otherUserPresence.online) {
        statusDiv.innerHTML = `<div class="online-dot"></div> online`;
      } else {
        statusDiv.innerHTML = `<div class="offline-dot"></div> Last seen ${formatLastSeen(otherUserPresence.lastSeen)}`;
      }
    }

    async function setupPresenceListener() {
      if (!currentOtherUid) return;
      const otherPresenceRef = ref(db, `users/${currentOtherUid}/presence`);
      presenceListener = onValue(otherPresenceRef, (snapshot) => {
        const presence = snapshot.val() || { online: false, lastSeen: null };
        otherUserPresence = presence;
        updatePresenceStatus();
      });
    }

    function setupUserPresence() {
      if (!currentUser) return;
      const connectedRef = ref(db, '.info/connected');
      const userPresenceRef = ref(db, `users/${currentUser.uid}/presence`);
      onValue(connectedRef, (snap) => {
        if (snap.val() === true) {
          // Online
          set(userPresenceRef, { online: true, lastSeen: Date.now() });
          onDisconnect(userPresenceRef).set({ online: false, lastSeen: Date.now() });
        }
      });
    }

    async function markMessageAsRead(msgId) {
      if (!currentUser || !currentChatId) return;
      const messageRef = ref(db, `chats/${currentChatId}/messages/${msgId}/readBy`);
      await update(messageRef, { [currentUser.uid]: true });
    }

    async function encryptMessage(message, chatId) {
      try {
        const encoder = new TextEncoder();
        const keyMaterial = await crypto.subtle.importKey(
          "raw",
          encoder.encode("grochat-secret-key-2025"),
          { name: "PBKDF2" },
          false,
          ["deriveBits", "deriveKey"]
        );
        const salt = encoder.encode(chatId);
        const key = await crypto.subtle.deriveKey(
          {
            name: "PBKDF2",
            salt: salt,
            iterations: 100000,
            hash: "SHA-256"
          },
          keyMaterial,
          { name: "AES-GCM", length: 256 },
          true,
          ["encrypt"]
        );
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const data = encoder.encode(message);
        const encrypted = await crypto.subtle.encrypt(
          { name: "AES-GCM", iv: iv },
          key,
          data
        );
        const ivB64 = btoa(String.fromCharCode(...iv));
        const ciphertextB64 = btoa(String.fromCharCode(...new Uint8Array(encrypted)));
        return JSON.stringify({ iv: ivB64, ciphertext: ciphertextB64 });
      } catch (error) {
        console.error('Encryption failed:', error);
        throw error;
      }
    }

    async function decryptMessage(encryptedStr, chatId) {
      try {
        const { iv, ciphertext } = JSON.parse(encryptedStr);
        const encoder = new TextEncoder();
        const keyMaterial = await crypto.subtle.importKey(
          "raw",
          encoder.encode("grochat-secret-key-2025"),
          { name: "PBKDF2" },
          false,
          ["deriveBits", "deriveKey"]
        );
        const salt = encoder.encode(chatId);
        const key = await crypto.subtle.deriveKey(
          {
            name: "PBKDF2",
            salt: salt,
            iterations: 100000,
            hash: "SHA-256"
          },
          keyMaterial,
          { name: "AES-GCM", length: 256 },
          true,
          ["decrypt"]
        );
        const ivData = Uint8Array.from(atob(iv), c => c.charCodeAt(0));
        const data = Uint8Array.from(atob(ciphertext), c => c.charCodeAt(0));
        const decrypted = await crypto.subtle.decrypt(
          { name: "AES-GCM", iv: ivData },
          key,
          data
        );
        return new TextDecoder().decode(decrypted);
      } catch (error) {
        console.error('Decryption failed:', error);
        return encryptedStr;
      }
    }

    async function uploadFile(file) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', `https://api.cloudinary.com/v1_1/${cloudinaryConfig.cloudName}/upload`);
        const formData = new FormData();
        formData.append('file', file);
        formData.append('upload_preset', cloudinaryConfig.uploadPreset);
        xhr.onload = () => {
          if (xhr.status === 200) {
            const data = JSON.parse(xhr.responseText);
            resolve(data.secure_url);
          } else {
            reject(new Error(`Upload failed: ${xhr.statusText}`));
          }
        };
        xhr.onerror = () => reject(new Error('Upload error'));
        xhr.send(formData);
      });
    }

    window.handleFileUpload = async (event) => {
      const file = event.target.files[0];
      if (!file) return;
      try {
        showAlert(`Uploading ${file.name}...`);
        const mediaUrl = await uploadFile(file);
        const mediaType = file.type.startsWith('image/') ? 'image' : 'document';
        const filename = mediaType === 'document' ? file.name : null;
        await sendMediaMessage(mediaUrl, mediaType, filename);
        event.target.value = '';
      } catch (error) {
        console.error('Upload failed:', error);
        showAlert('Failed to upload file.');
      }
    };

    async function sendMediaMessage(mediaUrl, mediaType, filename = null) {
      if (!currentUser || !currentChatId) return;
      try {
        let text = '';
        if (mediaType === 'document') {
          text = `Sent a document: ${filename}`;
        } else if (mediaType === 'audio') {
          text = 'Voice message';
        }
        const messageData = {
          senderId: currentUser.uid,
          mediaUrl,
          mediaType,
          filename,
          timestamp: Date.now(),
          deliveredBy: { [currentOtherUid]: false },
          readBy: {}
        };
        if (text) {
          messageData.text = text;
        }
        const messagesRef = ref(db, `chats/${currentChatId}/messages`);
        const newMessageRef = push(messagesRef);
        await set(newMessageRef, messageData);
        // Update last message for both users
        const currentUserChatRef = ref(db, `users/${currentUser.uid}/chats/${currentOtherUid}`);
        await update(currentUserChatRef, {
          lastMessage: JSON.stringify(messageData),
          lastMessageTime: Date.now()
        });
        const otherUserChatRef = ref(db, `users/${currentOtherUid}/chats/${currentUser.uid}`);
        const otherUnreadRef = ref(db, `users/${currentOtherUid}/chats/${currentUser.uid}/unreadCount`);
        const otherUnreadSnap = await get(otherUnreadRef);
        const otherUnread = (otherUnreadSnap.val() || 0) + 1;
        await update(otherUserChatRef, {
          lastMessage: JSON.stringify(messageData),
          lastMessageTime: Date.now(),
          unreadCount: otherUnread
        });
      } catch (error) {
        console.error('Error sending media:', error);
        showAlert('Failed to send media.');
      }
    }

    async function startRecording() {
      try {
        audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(audioStream, { mimeType: 'audio/webm' });
        recordedChunks = [];
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            recordedChunks.push(event.data);
          }
        };
        mediaRecorder.onstop = async () => {
          const blob = new Blob(recordedChunks, { type: 'audio/webm' });
          const file = new File([blob], `voice_${Date.now()}.webm`, { type: 'audio/webm' });
          try {
            showAlert('Uploading voice message...');
            const mediaUrl = await uploadFile(file);
            await sendMediaMessage(mediaUrl, 'audio');
          } catch (error) {
            console.error('Upload failed:', error);
            showAlert('Failed to upload voice message.');
          }
          stopRecording();
        };
        mediaRecorder.start();
        isRecording = true;
        document.getElementById('record-btn').classList.add('recording');
        document.getElementById('record-btn').innerHTML = 'stop';
        document.getElementById('message-input').disabled = true;
        document.getElementById('send-btn').disabled = true;
        document.getElementById('recording-waveform').style.display = 'block';

        // Setup live waveform for recording
        recorderCtx = new AudioContext();
        recorderSource = recorderCtx.createMediaStreamSource(audioStream);
        recorderAnalyser = recorderCtx.createAnalyser();
        recorderAnalyser.fftSize = 256;
        const recorderBufferLength = recorderAnalyser.frequencyBinCount;
        recorderDataArray = new Uint8Array(recorderBufferLength);
        recorderSource.connect(recorderAnalyser);

        function drawRecorder() {
          recorderRafId = requestAnimationFrame(drawRecorder);
          recorderAnalyser.getByteFrequencyData(recorderDataArray);
          const canvas = document.getElementById('wave-canvas');
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = 'rgb(0, 0, 0)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          const barWidth = (canvas.width / recorderBufferLength) * 2.5;
          let barHeight;
          let x = 0;
          for(let i = 0; i < recorderBufferLength; i++) {
            barHeight = recorderDataArray[i];
            ctx.fillStyle = `rgb(${barHeight + 100},50,50)`;
            ctx.fillRect(x, canvas.height - barHeight / 2, barWidth, barHeight / 2);
            x += barWidth + 1;
          }
        }
        drawRecorder();
      } catch (error) {
        console.error('Error starting recording:', error);
        showAlert('Failed to start recording. Please check microphone permissions.');
      }
    }

    function stopRecording() {
      if (mediaRecorder && isRecording) {
        mediaRecorder.stop();
        isRecording = false;
        document.getElementById('record-btn').classList.remove('recording');
        document.getElementById('record-btn').innerHTML = 'mic';
        document.getElementById('message-input').disabled = false;
        updateSendButton();
        document.getElementById('recording-waveform').style.display = 'none';
        if (recorderRafId) {
          cancelAnimationFrame(recorderRafId);
        }
        if (recorderCtx) {
          recorderCtx.close();
        }
        if (audioStream) {
          audioStream.getTracks().forEach(track => track.stop());
          audioStream = null;
        }
        recorderCtx = null;
        recorderSource = null;
        recorderAnalyser = null;
        recorderDataArray = null;
      }
    }

    async function loadChatInfo() {
      const urlParams = new URLSearchParams(window.location.search);
      currentChatId = urlParams.get('chatId');
      currentOtherUid = urlParams.get('userId');
      if (!currentChatId || !currentOtherUid) {
        showAlert('Invalid chat parameters.');
        window.location.href = 'index.html';
        return;
      }
      const otherUserRef = ref(db, `users/${currentOtherUid}`);
      const snapshot = await get(otherUserRef);
      if (snapshot.exists()) {
        const otherUser = snapshot.val();
        const initial = otherUser.displayName ? otherUser.displayName[0].toUpperCase() : 'U';
        let avatarHtml = '';
        if (otherUser.photoURL) {
          avatarHtml = `<img src="${otherUser.photoURL}" alt="${otherUser.displayName} avatar" class="chat-avatar" loading="lazy">`;
        } else {
          avatarHtml = `<div class="chat-avatar" style="background: var(--bbm-red); color: #000000; font-size: 20px; display: flex; align-items: center; justify-content: center; font-weight: bold;">${initial}</div>`;
        }
        let nameHtml = otherUser.displayName || 'User';
        if (otherUser.verified) {
          nameHtml += verifiedIcon;
        }
        const headerInfo = document.getElementById('chat-header-info');
        headerInfo.innerHTML = `
          ${avatarHtml}
          <div>
            <div class="chat-name">${nameHtml}</div>
            <div class="status-indicator" id="status-indicator">
              <div class="online-dot"></div> online
            </div>
          </div>
        `;
        await setupPresenceListener();
      }
    }

    function scrollToBottom() {
      const container = document.getElementById('messages-container');
      container.scrollTop = container.scrollHeight;
    }

    async function loadMessages() {
      const messagesRef = ref(db, `chats/${currentChatId}/messages`);
      messagesListener = onValue(messagesRef, async (snapshot) => {
        const container = document.getElementById('messages-container');
        const previousScrollHeight = container.scrollHeight;
        const previousScrollTop = container.scrollTop;
        const wasAtBottom = (previousScrollHeight - previousScrollTop) < 10;
        let newMessages = [];
        if (snapshot.exists()) {
          const allData = snapshot.val();
          const timestamps = Object.values(allData).map(m => m.timestamp || 0);
          const maxTimestamp = Math.max(...timestamps);
          if (isInitialLoad) {
            newMessages = Object.entries(allData)
              .map(([msgId, msg]) => ({ msgId, ...msg }))
              .sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
            container.innerHTML = '';
            isInitialLoad = false;
          } else {
            newMessages = Object.entries(allData)
              .filter(([msgId, msg]) => (msg.timestamp || 0) > lastLoadedTimestamp)
              .map(([msgId, msg]) => ({ msgId, ...msg }))
              .sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
          }
          lastLoadedTimestamp = maxTimestamp;
          for (const msg of newMessages) {
            const isSent = msg.senderId === currentUser.uid;
            // Mark received messages as read if not already
            if (!isSent && !msg.readBy?.[currentUser.uid]) {
              await markMessageAsRead(msg.msgId);
            }
            const bubble = document.createElement('div');
            bubble.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
            let contentHtml = '';
            let decryptedText = msg.text || '';
            if (msg.text) {
              try {
                decryptedText = await decryptMessage(msg.text, currentChatId);
              } catch (error) {
                console.error('Failed to decrypt message:', error);
              }
            }
            if (msg.mediaUrl) {
              if (msg.mediaType === 'image') {
                contentHtml = `
                  <div class="media-message">
                    <img src="${msg.mediaUrl}" alt="Sent image" loading="lazy" onclick="this.style.maxHeight='none'; this.style.cursor='zoom-out';">
                  </div>
                `;
              } else if (msg.mediaType === 'document') {
                contentHtml = `
                  <div class="media-message">
                    <div class="document-message">
                      <span class="document-icon material-icons">description</span>
                      <div class="document-info">
                        <div class="document-name">${msg.filename || 'Document'}</div>
                        <a href="${msg.mediaUrl}" download class="document-download">Download</a>
                      </div>
                    </div>
                  </div>
                `;
              } else if (msg.mediaType === 'audio') {
                contentHtml = `
                  <div class="media-message audio-message">
                    <audio controls src="${msg.mediaUrl}" id="audio-${msg.msgId}"></audio>
                    <canvas id="wave-canvas-${msg.msgId}" width="200" height="40"></canvas>
                    <div class="audio-duration" id="duration-${msg.msgId}">00:00</div>
                  </div>
                `;
              }
            }
            if (decryptedText) {
              contentHtml += `<div>${decryptedText}</div>`;
            }
            let statusHtml = `<div class="message-time">${formatTimestamp(msg.timestamp)}</div>`;
            if (isSent) {
              const delivered = msg.deliveredBy?.[currentOtherUid] || false;
              const read = msg.readBy?.[currentOtherUid] || false;
              let statusIcon = '';
              if (read) {
                statusIcon = '<span class="status-icon read-icon material-icons">done_all</span>';
              } else if (delivered) {
                statusIcon = '<span class="status-icon delivered-icon material-icons">done_all</span>';
              } else {
                statusIcon = '<span class="status-icon material-icons">schedule</span>';
              }
              statusHtml = `
                <div class="message-status">
                  ${statusIcon}
                </div>
                <div class="message-time">${formatTimestamp(msg.timestamp)}</div>
              `;
            }
            bubble.innerHTML = `
              ${contentHtml}
              ${statusHtml}
            `;
            container.appendChild(bubble);
            if (msg.mediaType === 'audio') {
              const audioEl = bubble.querySelector(`#audio-${msg.msgId}`);
              const canvasEl = bubble.querySelector(`#wave-canvas-${msg.msgId}`);
              const durationEl = bubble.querySelector(`#duration-${msg.msgId}`);
              if (audioEl && canvasEl && durationEl) {
                // Duration
                audioEl.addEventListener('loadedmetadata', () => {
                  const duration = audioEl.duration;
                  if (!isNaN(duration)) {
                    const mins = Math.floor(duration / 60);
                    const secs = Math.floor(duration % 60);
                    const durationStr = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                    durationEl.textContent = durationStr;
                  }
                }, { once: true });

                // Waveform
                let playbackCtx = null;
                let playbackAnalyser = null;
                let playbackDataArray = null;
                let playbackRafId = null;
                function drawPlayback() {
                  playbackRafId = requestAnimationFrame(drawPlayback);
                  if (playbackAnalyser) {
                    playbackAnalyser.getByteFrequencyData(playbackDataArray);
                    const ctx = canvasEl.getContext('2d');
                    ctx.fillStyle = 'rgb(0, 0, 0)';
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
                    const barWidth = (canvasEl.width / playbackDataArray.length) * 2.5;
                    let barHeight;
                    let x = 0;
                    for(let i = 0; i < playbackDataArray.length; i++) {
                      barHeight = playbackDataArray[i];
                      ctx.fillStyle = `rgb(${barHeight + 100},50,50)`;
                      ctx.fillRect(x, canvasEl.height - barHeight / 2, barWidth, barHeight / 2);
                      x += barWidth + 1;
                    }
                  }
                }
                audioEl.addEventListener('play', () => {
                  if (!playbackCtx) {
                    playbackCtx = new AudioContext();
                    const source = playbackCtx.createMediaElementSource(audioEl);
                    playbackAnalyser = playbackCtx.createAnalyser();
                    playbackAnalyser.fftSize = 256;
                    const bufferLength = playbackAnalyser.frequencyBinCount;
                    playbackDataArray = new Uint8Array(bufferLength);
                    source.connect(playbackAnalyser);
                    playbackAnalyser.connect(playbackCtx.destination);
                  }
                  drawPlayback();
                });
                audioEl.addEventListener('pause', () => {
                  if (playbackRafId) {
                    cancelAnimationFrame(playbackRafId);
                  }
                });
                audioEl.addEventListener('ended', () => {
                  if (playbackRafId) {
                    cancelAnimationFrame(playbackRafId);
                  }
                });
              }
            }
          }
        }
        if (isInitialLoad || (newMessages.length > 0 && wasAtBottom)) {
          scrollToBottom();
        }
      }, (error) => {
        console.error('Error loading messages:', error);
        showAlert('Failed to load messages.');
      });
    }

    async function sendMessage() {
      const input = document.getElementById('message-input');
      const text = input.value.trim();
      if (!text || !currentUser || !currentChatId) return;
      try {
        const encrypted = await encryptMessage(text, currentChatId);
        const messagesRef = ref(db, `chats/${currentChatId}/messages`);
        const newMessageRef = push(messagesRef);
        const messageData = {
          senderId: currentUser.uid,
          text: encrypted,
          timestamp: Date.now(),
          deliveredBy: { [currentOtherUid]: false },
          readBy: {}
        };
        await set(newMessageRef, messageData);
        // Update last message for both users
        const currentUserChatRef = ref(db, `users/${currentUser.uid}/chats/${currentOtherUid}`);
        await update(currentUserChatRef, {
          lastMessage: encrypted,
          lastMessageTime: Date.now()
        });
        const otherUserChatRef = ref(db, `users/${currentOtherUid}/chats/${currentUser.uid}`);
        const otherUnreadRef = ref(db, `users/${currentOtherUid}/chats/${currentUser.uid}/unreadCount`);
        const otherUnreadSnap = await get(otherUnreadRef);
        const otherUnread = (otherUnreadSnap.val() || 0) + 1;
        await update(otherUserChatRef, {
          lastMessage: encrypted,
          lastMessageTime: Date.now(),
          unreadCount: otherUnread
        });
        input.value = '';
        updateSendButton();
      } catch (error) {
        console.error('Error sending message:', error);
        showAlert('Failed to send message.');
      }
    }

    function updateSendButton() {
      const input = document.getElementById('message-input');
      const sendBtn = document.getElementById('send-btn');
      const text = input.value.trim();
      sendBtn.disabled = !text || isRecording;
    }

    function handleTyping() {
      if (!currentChatId || !currentOtherUid || isRecording) return;
      const typingRef = ref(db, `chats/${currentChatId}/typing`);
      const input = document.getElementById('message-input');
      const text = input.value.trim();
      if (text && !isTyping) {
        isTyping = true;
        set(typingRef, { [currentUser.uid]: true });
      } else if (!text && isTyping) {
        isTyping = false;
        set(typingRef, { [currentUser.uid]: false });
      }
      if (typingTimeout) clearTimeout(typingTimeout);
      typingTimeout = setTimeout(() => {
        if (isTyping) {
          isTyping = false;
          set(typingRef, { [currentUser.uid]: false });
        }
      }, 2000);
    }

    function setupTypingListener() {
      const typingRef = ref(db, `chats/${currentChatId}/typing`);
      onValue(typingRef, (snapshot) => {
        const typing = snapshot.val() || {};
        let typingIndicator = document.querySelector('.typing-indicator');
        if (typing[currentOtherUid] && !typing[currentUser.uid]) {
          if (!typingIndicator) {
            typingIndicator = document.createElement('div');
            typingIndicator.className = 'typing-indicator';
            typingIndicator.innerHTML = `
              <span>Typing...</span>
              <div class="typing-dots">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
              </div>
            `;
            document.getElementById('messages-container').appendChild(typingIndicator);
            scrollToBottom();
          }
        } else {
          if (typingIndicator) {
            typingIndicator.remove();
          }
        }
      });
    }

    function setupCallButtons() {
      document.getElementById('voice-call-btn').onclick = () => {
        window.location.href = `call.html?chatId=${currentChatId}&userId=${currentOtherUid}&type=voice`;
      };
      document.getElementById('video-call-btn').onclick = () => {
        window.location.href = `call.html?chatId=${currentChatId}&userId=${currentOtherUid}&type=video`;
      };
    }

    function setupAttachButton() {
      document.getElementById('attach-btn').onclick = () => {
        document.getElementById('file-input').click();
      };
    }

    function setupRecordButton() {
      const recordBtn = document.getElementById('record-btn');
      recordBtn.onclick = () => {
        if (!isRecording) {
          startRecording();
        } else {
          stopRecording();
        }
      };
    }

    function initializeFirebase() {
      app = initializeApp(firebaseConfig);
      auth = getAuth(app);
      db = getDatabase(app);
      analytics = getAnalytics(app);
      onAuthStateChanged(auth, async (user) => {
        currentUser = user;
        if (user) {
          setUserId(analytics, user.uid);
          setupUserPresence();
          await loadChatInfo();
          await loadMessages();
          setupTypingListener();
          setupCallButtons();
          setupAttachButton();
          setupRecordButton();
          // Mark as read
          const chatRef = ref(db, `users/${currentUser.uid}/chats/${currentOtherUid}`);
          await update(chatRef, { unreadCount: 0 });
        } else {
          window.location.href = 'login.html';
        }
      });
    }

    function setupEventListeners() {
      const input = document.getElementById('message-input');
      const sendBtn = document.getElementById('send-btn');
      input.addEventListener('input', () => {
        updateSendButton();
        handleTyping();
      });
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });
      sendBtn.addEventListener('click', sendMessage);
      // Auto-resize textarea
      input.addEventListener('input', () => {
        input.style.height = 'auto';
        input.style.height = Math.min(input.scrollHeight, 120) + 'px';
      });
    }

    // Cleanup on unload
    window.addEventListener('beforeunload', () => {
      if (typingTimeout) clearTimeout(typingTimeout);
      if (messagesListener) off(messagesListener);
      if (presenceListener) off(presenceListener);
      if (currentUser && currentChatId) {
        const typingRef = ref(db, `chats/${currentChatId}/typing`);
        set(typingRef, { [currentUser.uid]: false });
      }
      stopRecording();
    });

    document.addEventListener('DOMContentLoaded', () => {
      initializeFirebase();
      setupEventListeners();
    });
  </script>
</body>
</html>
