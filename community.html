<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vynix Chat</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Symbols+Rounded" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        :root {
            --accent-blue: #3a76f0;
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --bg-color: #f8f9fa;
            --glass-white: rgba(255, 255, 255, 0.85);
            --online-green: #10b981;
            --received-bg: #e5e5ea;
        }
        @media (prefers-color-scheme: dark) {
            :root {
                --text-primary: #f9f9f9;
                --text-secondary: #a0a0a0;
                --bg-color: #000000;
                --glass-white: rgba(20, 20, 20, 0.85);
                --received-bg: #2c2c2e;
            }
        }
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        body { font-family: 'Poppins', sans-serif; background: var(--bg-color); color: var(--text-primary); min-height: 100vh; padding-bottom: 100px; position: relative; }
        header {
            position: fixed; top: 0; left: 0; right: 0; height: 75px; background: var(--glass-white);
            display: flex; align-items: center; justify-content: space-between; padding: 0 20px;
            z-index: 1000; backdrop-filter: blur(20px); border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        .app-title { font-size: 24px; font-weight: 700; color: var(--accent-blue); }
        .search-container { padding: 90px 16px 20px; }
        .search-input {
            width: 100%; padding: 14px 20px; border-radius: 25px; border: 2px solid #f3f4f6;
            background: var(--glass-white); font-size: 16px;
        }
        .search-input:focus { outline: none; border-color: var(--accent-blue); }
        #chatList { padding: 0 16px; }
        .chat-card {
            display: flex; align-items: center; padding: 12px 0; cursor: pointer;
            transition: background 0.2s;
        }
        .chat-card:hover { background: rgba(0,0,0,0.05); }
        .avatar { width: 58px; height: 58px; border-radius: 50%; object-fit: cover; margin-right: 15px; }
        .online-indicator {
            position: absolute; bottom: 2px; right: 12px; width: 16px; height: 16px;
            background: var(--online-green); border: 3px solid var(--bg-color); border-radius: 50%;
        }
        .chat-info { flex: 1; overflow: hidden; }
        .chat-name { font-weight: 600; font-size: 17px; }
        .chat-msg { font-size: 14px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .chat-time { font-size: 13px; color: var(--text-secondary); }
        .unread-badge {
            background: var(--accent-blue); color: white; min-width: 20px; height: 20px;
            border-radius: 10px; padding: 0 6px; font-size: 12px; font-weight: 700;
            display: flex; align-items: center; justify-content: center;
        }
        #fullChatView {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-color);
            display: none; flex-direction: column; z-index: 2000;
        }
        #chatHeader {
            height: 75px; background: var(--glass-white); display: flex; align-items: center;
            padding: 0 20px; backdrop-filter: blur(20px); border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        #chatBackBtn { font-size: 28px; cursor: pointer; color: var(--accent-blue); margin-right: 15px; }
        #chatFriendAvatar { width: 42px; height: 42px; border-radius: 50%; object-fit: cover; margin-right: 12px; }
        #chatFriendName { font-weight: 600; font-size: 18px; }
        #chatStatusInfo { font-size: 13px; color: var(--text-secondary); }
        #messageList {
            flex: 1; padding: 10px 16px; overflow-y: auto; display: flex; flex-direction: column; gap: 8px;
        }
        .message {
            max-width: 80%; padding: 10px 14px; border-radius: 18px; line-height: 1.4;
            word-wrap: break-word;
        }
        .message.sent { align-self: flex-end; background: var(--accent-blue); color: #fff; border-bottom-right-radius: 4px; }
        .message.received { align-self: flex-start; background: var(--received-bg); color: var(--text-primary); border-bottom-left-radius: 4px; }
        .message-time { font-size: 12px; opacity: 0.7; margin-top: 4px; text-align: right; }
        #chatInputArea {
            background: var(--glass-white); padding: 10px 16px; display: flex; align-items: center; gap: 10px;
            backdrop-filter: blur(20px); border-top: 1px solid rgba(0,0,0,0.05);
        }
        #messageInput {
            flex: 1; padding: 12px 50px 12px 16px; border-radius: 28px; background: rgba(128,128,128,0.15);
            border: none; font-size: 16px; resize: none; max-height: 120px; overflow-y: auto;
        }
        #micBtn, #sendBtn {
            width: 44px; height: 44px; border-radius: 50%; display: flex; align-items: center;
            justify-content: center; font-size: 24px; cursor: pointer;
        }
        #sendBtn { background: var(--accent-blue); color: #fff; display: none; }
        #sendBtn.visible { display: flex; }
        #toast {
            position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%);
            background: #111; color: #fff; padding: 12px 25px; border-radius: 50px; z-index: 9999; display: none;
        }
        .shimmer {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%; animation: shimmer 1.5s infinite linear;
        }
        @keyframes shimmer { 0% { background-position: -200% 0; } 100% { background-position: 200% 0; } }
        #pageLoader {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: var(--bg-color);
            z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #pageLoader.fade-out { opacity: 0; transition: opacity 0.4s; }
        .overlay { position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);display:none;z-index:2500; }
        .bottom-sheet {
            position:fixed;bottom:-100%;left:0;width:100%;background:var(--glass-white);
            border-radius:35px 35px 0 0;padding:35px 25px;transition:0.4s;z-index:2600;
            backdrop-filter: blur(20px); max-height: 80vh; overflow-y: auto;
        }
        .bottom-sheet.active { bottom:0; }
        .v-input {
            width:100%;padding:18px;border:2px solid #f3f4f6;border-radius:20px;
            margin-bottom:15px;font-size:15px;background:var(--glass-white);
        }
        .btn-primary {
            width:100%;background:var(--accent-blue);color:#fff;border:none;
            padding:18px;border-radius:20px;font-weight:700;cursor:pointer;font-size:15px;
        }
        /* Floating Action Button */
        #fabAddFriend {
            position: fixed;
            bottom: 30px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: var(--accent-blue);
            color: #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            box-shadow: 0 6px 20px rgba(58,118,240,0.4);
            z-index: 1500;
            cursor: pointer;
            transition: transform 0.2s;
        }
        #fabAddFriend:active { transform: scale(0.9); }
        /* Friends list in sheet */
        .friend-item {
            display: flex;
            align-items: center;
            padding: 12px 0;
            cursor: pointer;
        }
        .friend-item .avatar {
            width: 50px;
            height: 50px;
            margin-right: 15px;
        }
        .friend-item .chat-name {
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div id="pageLoader">
        <div class="app-title shimmer" style="width:120px;height:28px;margin-bottom:20px;"></div>
        <div class="shimmer" style="width:58px;height:58px;border-radius:50%;margin-bottom:20px;"></div>
        <div class="shimmer" style="width:80%;height:20px;border-radius:8px;"></div>
    </div>

    <div id="toast"></div>

    <header>
        <img id="myAvatar" class="avatar shimmer" src="" style="width:42px;height:42px;">
        <div class="app-title">Vynix Chat</div>
    </header>

    <main>
        <div class="search-container">
            <input type="text" class="search-input" id="friendSearch" placeholder="Search chats..." onkeyup="searchFriends()">
        </div>
        <div id="chatList"></div>
    </main>

    <!-- Full Chat View -->
    <div id="fullChatView">
        <div id="chatHeader">
            <span class="material-symbols-rounded" id="chatBackBtn" onclick="closeFullChat()">arrow_back</span>
            <img id="chatFriendAvatar" class="avatar" src="">
            <div>
                <div id="chatFriendName"></div>
                <div id="chatStatusInfo">Loading...</div>
            </div>
        </div>
        <div id="messageList"></div>
        <div id="chatInputArea">
            <div style="position:relative;flex:1;">
                <input type="text" id="messageInput" placeholder="Type a messageâ€¦" oninput="updateInputButtons()" onkeypress="handleEnter(event)">
                <span class="material-symbols-rounded" id="micBtn" style="position:absolute;right:8px;top:50%;transform:translateY(-50%);color:var(--text-secondary);">mic</span>
            </div>
            <div id="sendBtn"><span class="material-symbols-rounded">send</span></div>
        </div>
    </div>

    <!-- Overlay & Friends Sheet -->
    <div class="overlay" id="overlay" onclick="closeAll()"></div>
    <div class="bottom-sheet" id="friendsSheet">
        <h2 style="margin-bottom:20px;">Your Friends</h2>
        <div id="friendsList"></div>
        <div style="margin-top:20px;">
            <input type="text" id="friendVynixId" class="v-input" placeholder="Enter Vynix ID (e.g. vnx_789)">
            <button class="btn-primary" onclick="addFriendLogic()">Add Friend</button>
        </div>
    </div>

    <!-- Floating Action Button -->
    <div id="fabAddFriend" onclick="openFriendsSheet()">
        <span class="material-symbols-rounded">person_add</span>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyBOyZ3As4GTuNvjemvPF_SpsC6m6vqtNhc",
            authDomain: "fire-b-a8878.firebaseapp.com",
            databaseURL: "https://fire-b-a8878.firebaseio.com/",
            projectId: "fire-b-a8878",
            storageBucket: "fire-b-a8878.firebasestorage.app",
            messagingSenderId: "658673187627",
            appId: "1:658673187627:web:6e4c29af661785f0afa36e"
        };
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.database();

        let currentUser = null;
        let myProfile = { name: "", photo: "" };
        let myVId = "";
        let currentFriendUid = null;
        let currentRoomId = null;
        let messagesListener = null;
        let sharedKeys = JSON.parse(localStorage.getItem('sharedKeys') || '{}');

        auth.onAuthStateChanged(user => {
            if (user) {
                currentUser = user;
                initApp();
            } else {
                window.location.href = "login.html";
            }
        });

        function toast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.style.display = 'block';
            setTimeout(() => t.style.display = 'none', 2800);
        }

        function generateLetterAvatar(name) {
            if (!name) name = 'U';
            const initials = name.trim().split(/\s+/).map(w => w[0]).slice(0,2).join('').toUpperCase();
            const colors = ['#3a76f0','#10b981','#f59e0b','#ef4444','#8b5cf6','#ec4899'];
            const hash = name.split('').reduce((a,b) => a + b.charCodeAt(0), 0);
            const bg = colors[hash % colors.length];
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = 58;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = bg;
            ctx.fillRect(0,0,58,58);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px Poppins';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(initials, 29, 29);
            return canvas.toDataURL();
        }

        async function generateKeyPair() {
            const keyPair = await crypto.subtle.generateKey(
                { name: "ECDH", namedCurve: "P-256" },
                true,
                ["deriveBits"]
            );
            const publicKeyJwk = await crypto.subtle.exportKey("jwk", keyPair.publicKey);
            const privateKeyJwk = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
            localStorage.setItem('privateKey', JSON.stringify(privateKeyJwk));
            return publicKeyJwk;
        }

        async function deriveSharedSecret(friendPublicJwk) {
            const privateKeyJwk = JSON.parse(localStorage.getItem('privateKey'));
            const privateKey = await crypto.subtle.importKey(
                "jwk",
                privateKeyJwk,
                { name: "ECDH", namedCurve: "P-256" },
                false,
                ["deriveBits"]
            );
            const friendPublicKey = await crypto.subtle.importKey(
                "jwk",
                friendPublicJwk,
                { name: "ECDH", namedCurve: "P-256" },
                false,
                []
            );
            const sharedSecret = await crypto.subtle.deriveBits(
                { name: "ECDH", public: friendPublicKey },
                privateKey,
                256
            );
            return Array.from(new Uint8Array(sharedSecret)).map(b => b.toString(16).padStart(2,'0')).join('');
        }

        async function initApp() {
            listenToMyProfile();

            const snap = await db.ref(`users/${currentUser.uid}/profile`).once('value');
            const data = snap.val() || {};
            if (!data.vynixId) {
                toast('Generating your unique Vynix ID...');
                const newId = await generateAndAssignVynixId();
                if (newId) {
                    myVId = newId;
                    await db.ref(`users/${currentUser.uid}/profile`).update({ vynixId: newId });
                    await db.ref(`vynix_ids/${newId}`).set(currentUser.uid);
                    toast(`Your Vynix ID: @${newId}`);
                }
            } else {
                myVId = data.vynixId;
            }

            if (!localStorage.getItem('privateKey')) {
                toast('Generating encryption keys...');
                const publicJwk = await generateKeyPair();
                await db.ref(`users/${currentUser.uid}/profile`).update({ publicKey: JSON.stringify(publicJwk) });
            }

            loadChats();
            hidePageLoader();
        }

        async function hidePageLoader() {
            await new Promise(r => setTimeout(r, 800));
            document.getElementById('pageLoader').classList.add('fade-out');
            setTimeout(() => document.getElementById('pageLoader').style.display = 'none', 400);
        }

        function listenToMyProfile() {
            db.ref(`users/${currentUser.uid}/profile`).on('value', snap => {
                const data = snap.val() || {};
                myProfile.name = data.name || "You";
                myProfile.photo = data.photo || generateLetterAvatar(myProfile.name);
                document.getElementById('myAvatar').src = myProfile.photo;
                document.getElementById('myAvatar').classList.remove('shimmer');
            });
        }

        async function loadChats() {
            db.ref(`users/${currentUser.uid}/chats`).on('value', async snap => {
                const list = document.getElementById('chatList');
                list.innerHTML = '';
                const chats = [];
                snap.forEach(child => chats.push({ uid: child.key, data: child.val() }));
                chats.sort((a,b) => (b.data.ts || 0) - (a.data.ts || 0));

                for (const chat of chats) {
                    const profileSnap = await db.ref(`users/${chat.uid}/profile`).once('value');
                    const profile = profileSnap.val() || { name: "User", photo: "" };
                    const lastMsg = chat.data.lastMsg ? await decrypt(chat.data.lastMsg, chat.uid) || "[Media]" : "You are now connected ðŸ”’";
                    const time = formatTimeAgo(chat.data.ts);
                    const unread = chat.data.unreadCount || 0;

                    list.innerHTML += `
                        <div class="chat-card" onclick="openFullChat('${chat.uid}')">
                            <div style="position:relative;">
                                <img class="avatar" src="${profile.photo || generateLetterAvatar(profile.name)}">
                                <div class="online-indicator" id="online_${chat.uid}"></div>
                            </div>
                            <div class="chat-info">
                                <div class="chat-name">${profile.name}</div>
                                <div class="chat-msg">${lastMsg}</div>
                            </div>
                            ${time ? `<div class="chat-time">${time}</div>` : ''}
                            ${unread > 0 ? `<div class="unread-badge">${unread > 99 ? '99+' : unread}</div>` : ''}
                        </div>`;

                    db.ref(`users/${chat.uid}/online`).on('value', s => {
                        document.getElementById(`online_${chat.uid}`).style.display = s.val() === true ? 'block' : 'none';
                    });
                }
            });
        }

        // Load friends list for the sheet
        async function loadFriendsList() {
            const list = document.getElementById('friendsList');
            list.innerHTML = '';
            const snap = await db.ref(`users/${currentUser.uid}/chats`).once('value');
            if (!snap.exists()) {
                list.innerHTML = '<p style="text-align:center;color:var(--text-secondary);">No friends yet. Add one below!</p>';
                return;
            }
            const friends = [];
            snap.forEach(child => friends.push(child.key));
            for (const uid of friends) {
                const profileSnap = await db.ref(`users/${uid}/profile`).once('value');
                const profile = profileSnap.val() || { name: "User", photo: "" };
                list.innerHTML += `
                    <div class="friend-item" onclick="startChatWith('${uid}')">
                        <img class="avatar" src="${profile.photo || generateLetterAvatar(profile.name)}">
                        <div class="chat-name">${profile.name}</div>
                    </div>`;
            }
        }

        function openFriendsSheet() {
            loadFriendsList();
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('friendsSheet').classList.add('active');
        }

        function closeAll() {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('friendsSheet').classList.remove('active');
        }

        async function startChatWith(friendUid) {
            closeAll();
            openFullChat(friendUid);
        }

        async function openFullChat(friendUid) {
            currentFriendUid = friendUid;
            currentRoomId = currentUser.uid < friendUid ? currentUser.uid + "_" + friendUid : friendUid + "_" + currentUser.uid;

            const profileSnap = await db.ref(`users/${friendUid}/profile`).once('value');
            const profile = profileSnap.val() || { name: "User", photo: "" };

            document.getElementById('chatFriendName').textContent = profile.name;
            document.getElementById('chatFriendAvatar').src = profile.photo || generateLetterAvatar(profile.name);
            document.getElementById('fullChatView').style.display = 'flex';

            if (!sharedKeys[friendUid] && profile.publicKey) {
                const friendPublicJwk = JSON.parse(profile.publicKey);
                const secret = await deriveSharedSecret(friendPublicJwk);
                sharedKeys[friendUid] = secret;
                localStorage.setItem('sharedKeys', JSON.stringify(sharedKeys));
            }

            loadMessages();
            markAsRead(friendUid);
        }

        function closeFullChat() {
            document.getElementById('fullChatView').style.display = 'none';
            if (messagesListener) messagesListener.off();
            currentFriendUid = null;
            currentRoomId = null;
        }

        function loadMessages() {
            if (messagesListener) messagesListener.off();
            messagesListener = db.ref(`messages/${currentRoomId}`).limitToLast(50).on('value', snap => {
                const list = document.getElementById('messageList');
                list.innerHTML = '';
                if (!snap.exists()) {
                    list.innerHTML = '<div style="text-align:center;color:#999;padding:40px;">Start the conversation!</div>';
                    return;
                }
                const msgs = [];
                snap.forEach(child => msgs.push({key: child.key, ...child.val()}));
                msgs.sort((a,b) => a.ts - b.ts);
                msgs.forEach(m => {
                    const isSent = m.sender === currentUser.uid;
                    const time = formatMessageTime(m.ts);
                    const text = m.deleted ? '<i>This message was deleted</i>' : decrypt(m.text || '', currentFriendUid);
                    const msgEl = document.createElement('div');
                    msgEl.className = `message ${isSent ? 'sent' : 'received'}`;
                    msgEl.innerHTML = `${text}<div class="message-time">${time}</div>`;
                    list.appendChild(msgEl);
                });
                list.scrollTop = list.scrollHeight;
            });
        }

        function updateInputButtons() {
            const hasText = document.getElementById('messageInput').value.trim().length > 0;
            document.getElementById('sendBtn').classList.toggle('visible', hasText);
        }

        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const text = input.value.trim();
            if (!text || !currentRoomId || !currentFriendUid) return;

            const key = sharedKeys[currentFriendUid];
            if (!key) {
                toast('Encryption not ready â€“ please reopen the chat');
                return;
            }

            const encrypted = CryptoJS.AES.encrypt(text, key).toString();

            try {
                const msgRef = db.ref(`messages/${currentRoomId}`).push();
                await msgRef.set({
                    type: 'text',
                    text: encrypted,
                    sender: currentUser.uid,
                    ts: Date.now(),
                    reactions: {}
                });

                const updates = {};
                updates[`users/${currentUser.uid}/chats/${currentFriendUid}/lastMsg`] = encrypted;
                updates[`users/${currentUser.uid}/chats/${currentFriendUid}/ts`] = Date.now();
                updates[`users/${currentFriendUid}/chats/${currentUser.uid}/lastMsg`] = encrypted;
                updates[`users/${currentFriendUid}/chats/${currentUser.uid}/ts`] = Date.now();
                updates[`users/${currentFriendUid}/chats/${currentUser.uid}/unreadCount`] = firebase.database.ServerValue.increment(1);

                await db.ref().update(updates);

                input.value = '';
                updateInputButtons();
            } catch (error) {
                console.error("Send failed:", error);
                toast('Failed to send message â€“ check your connection');
            }
        }

        document.getElementById('sendBtn').addEventListener('click', sendMessage);

        function handleEnter(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        }

        async function decrypt(ciphertext, friendUid) {
            if (!ciphertext) return "[Message]";
            try {
                const key = sharedKeys[friendUid];
                if (!key) return "ðŸ”’ Encrypted message";
                const bytes = CryptoJS.AES.decrypt(ciphertext, key);
                return bytes.toString(CryptoJS.enc.Utf8) || "ðŸ”’ Message";
            } catch (e) {
                return "ðŸ”’ Message";
            }
        }

        async function addFriendLogic() {
            const rawId = document.getElementById('friendVynixId').value.trim().toLowerCase();
            const vid = rawId.startsWith('@') ? rawId.substring(1) : rawId;
            if (!vid || vid === myVId) {
                toast(vid === myVId ? "That's your own ID!" : "Enter a valid ID");
                return;
            }
            const idSnap = await db.ref(`vynix_ids/${vid}`).once('value');
            if (!idSnap.exists()) {
                toast("User not found");
                return;
            }
            const targetUid = idSnap.val();
            const existing = await db.ref(`users/${currentUser.uid}/chats/${targetUid}`).once('value');
            if (existing.exists()) {
                toast("Already friends!");
                closeAll();
                return;
            }
            await db.ref(`users/${currentUser.uid}/chats/${targetUid}`).set({
                lastMsg: "You are now connected ðŸ”’",
                ts: Date.now(),
                unreadCount: 0
            });
            toast("Friend added! Start chatting from the list.");
            closeAll();
            document.getElementById('friendVynixId').value = "";
        }

        async function markAsRead(friendUid) {
            await db.ref(`users/${currentUser.uid}/chats/${friendUid}`).update({ unreadCount: 0 });
        }

        function searchFriends() {
            const term = document.getElementById('friendSearch').value.toLowerCase();
            document.querySelectorAll('.chat-card').forEach(card => {
                const name = card.querySelector('.chat-name')?.textContent.toLowerCase() || '';
                const msg = card.querySelector('.chat-msg')?.textContent.toLowerCase() || '';
                card.style.display = (name.includes(term) || msg.includes(term)) ? 'flex' : 'none';
            });
        }

        async function generateAndAssignVynixId() {
            const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
            let attempts = 0;
            const maxAttempts = 30;
            while (attempts < maxAttempts) {
                const candidate = 'vnx_' + Array.from(crypto.getRandomValues(new Uint32Array(6))).map(n => chars[n % chars.length]).join('');
                const snap = await db.ref(`vynix_ids/${candidate}`).once('value');
                if (!snap.exists()) return candidate;
                attempts++;
            }
            toast("Failed to generate unique ID. Try again.");
            return null;
        }

        function formatTimeAgo(timestamp) {
            if (!timestamp) return '';
            const now = Date.now();
            const diff = now - timestamp;
            if (diff < 60000) return 'now';
            if (diff < 3600000) return `${Math.floor(diff / 60000)}m`;
            if (diff < 86400000) return `${Math.floor(diff / 3600000)}h`;
            if (diff < 604800000) return `${Math.floor(diff / 86400000)}d`;
            const date = new Date(timestamp);
            return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
        }

        function formatMessageTime(ts) {
            const date = new Date(ts);
            const hours = date.getHours() % 12 || 12;
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const ampm = date.getHours() >= 12 ? 'PM' : 'AM';
            return `${hours}:${minutes} ${ampm}`;
        }
    </script>
</body>
</html>
