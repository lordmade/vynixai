<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Vynix AI</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked@4.0.0/marked.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/brain.js@2.0.0-beta.2/dist/brain-browser.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #F7F7F8;
      --card-bg: #1C2526;
      --text-primary: #FFFFFF;
      --text-secondary: #4B5EAA;
      --border: #4A5568;
      --highlight: #38B2AC;
      --user-msg-bg: #E0E7FF;
      --ai-msg-bg: #1C2526;
    }

    body {
      font-family: 'Inter', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text-secondary);
      min-height: 100vh;
      margin: 0;
      transition: background 0.3s ease;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }

    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid var(--highlight);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .welcome-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      margin-top: 3rem;
    }

    .welcome-container h1 {
      font-size: 1.25rem;
      font-weight: 600;
      color: #1E1E1E;
    }

    .hidden {
      display: none;
    }

    .chat-input-container {
      position: fixed;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      width: 90%;
      max-width: 600px;
      background: var(--card-bg);
      border-radius: 1.5rem;
      padding: 0.5rem 0.75rem;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    #chat-input {
      flex: 1;
      background: transparent;
      color: var(--text-primary);
      border: none;
      padding: 0.75rem 0.5rem;
      outline: none;
      font-size: 1rem;
    }

    #send-button, #image-upload-button {
      background: transparent;
      border: none;
      padding: 0.5rem;
      cursor: pointer;
      border-radius: 0.5rem;
      transition: background 0.2s;
    }

    #send-button:hover, #image-upload-button:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    #send-button svg, #image-upload-button svg {
      width: 1.5rem;
      height: 1.5rem;
      stroke: var(--text-primary);
    }

    #chat-messages {
      margin: 1rem;
      padding: 1rem;
      overflow-y: auto;
      max-height: calc(100vh - 11rem);
    }

    .message {
      max-width: 70%;
      padding: 0.75rem 1.25rem;
      border-radius: 1.5rem;
      margin: 0.5rem 1rem;
      word-wrap: break-word;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
      animation: slideIn 0.3s ease-out;
      position: relative;
      display: inline-block;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }

    .message.user {
      background: linear-gradient(135deg, var(--user-msg-bg), #C7D2FE);
      color: #1E1E1E;
      margin-left: auto;
      border-bottom-right-radius: 0.25rem;
    }

    .message.ai {
      background: linear-gradient(135deg, var(--ai-msg-bg), #2D3748);
      color: var(--text-primary);
      margin-right: auto;
      border-bottom-left-radius: 0.25rem;
    }

    .message.processing {
      background: var(--ai-msg-bg);
      color: var(--text-primary);
      font-style: italic;
      opacity: 0.7;
    }

    .message img {
      max-width: 100%;
      border-radius: 0.5rem;
      margin-top: 0.5rem;
    }

    .typing-indicator {
      display: inline-flex;
      gap: 0.25rem;
      align-items: center;
    }

    .typing-dot {
      width: 0.5rem;
      height: 0.5rem;
      background: var(--text-primary);
      border-radius: 50%;
      animation: typing 1.2s infinite;
    }

    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }

    @keyframes typing {
      0%, 100% { opacity: 0.3; transform: translateY(0); }
      50% { opacity: 1; transform: translateY(-3px); }
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes vibrate {
      0% { transform: translateX(0); }
      20% { transform: translateX(-2px); }
      40% { transform: translateX(2px); }
      60% { transform: translateX(-2px); }
      80% { transform: translateX(2px); }
      100% { transform: translateX(0); }
    }

    .vibrate {
      animation: vibrate 0.2s ease-in-out;
    }

    .feedback-container {
      display: flex;
      justify-content: flex-end;
      margin-top: 0.5rem;
      font-size: 0.875rem;
    }

    .feedback-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 0.25rem;
      margin: 0 0.25rem;
      border-radius: 0.25rem;
      transition: opacity 0.2s, transform 0.2s;
      opacity: 0.7;
      width: 1.5rem;
      height: 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }

    .feedback-btn:hover { opacity: 1; }
    .feedback-btn.up { color: #10B981; } /* Green */
    .feedback-btn.down { color: #EF4444; } /* Red */
    .feedback-btn.voted { transform: scale(1.1); opacity: 1; }
    .feedback-btn:disabled { opacity: 0.5; cursor: not-allowed; }

    @media (min-width: 1024px) {
      .chat-input-container {
        left: 50%;
        max-width: 800px;
      }

      #chat-messages {
        margin-left: 1rem;
        margin-top: 1rem;
        margin-bottom: 6rem;
        max-height: calc(100vh - 7rem);
      }

      .welcome-container {
        margin-left: 1rem;
      }
    }
  </style>
</head>
<body>
  <div id="loading-overlay">
    <div class="spinner"></div>
  </div>
  <main class="flex flex-col h-screen">
    <div class="welcome-container" id="welcome-container">
      <h1>Hey there, friend!</h1>
    </div>
    <div id="chat-messages" class="flex-1 overflow-y-auto"></div>
    <div class="chat-input-container">
      <button id="image-upload-button" class="p-2">
        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
          <path d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
        </svg>
      </button>
      <input type="text" id="chat-input" placeholder="What's on your mind?" aria-label="Type your prompt" disabled>
      <button id="send-button" disabled>
        <svg class="w-6 h-6 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M5 12h14M5 12l6-6m-6 6l6 6"/>
        </svg>
      </button>
    </div>
  </main>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js";
    import { getDatabase, ref, push, onValue, get, set, runTransaction } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBOyZ3As4GTuNvjemvPF_SpsC6m6vqtNhc",
      authDomain: "fire-b-a8878.firebaseapp.com",
      databaseURL: "https://fire-b-a8878.firebaseio.com",
      projectId: "fire-b-a8878",
      storageBucket: "fire-b-a8878.firebasestorage.app",
      messagingSenderId: "658673187627",
      appId: "1:658673187627:web:6e4c29af661785f0afa36e",
      measurementId: "G-V4W97VMSKL"
    };

    // New: NewsAPI Key (Get free at https://newsapi.org/ - replace with your key)
    const NEWS_API_KEY = 'YOUR_NEWSAPI_KEY_HERE';  // TODO: Replace with actual key

    const state = {
      messages: [],
      hasChatted: false,
      conversationId: null,
      isReady: false,
      lastQuoteSnapshot: null,  // For quote dedup
      lastJokeSnapshot: null,   // For joke dedup
      lastNewsSnapshot: null    // New: For news dedup
    };

    const elements = {
      loadingOverlay: document.getElementById('loading-overlay'),
      chatMessages: document.getElementById('chat-messages'),
      chatInput: document.getElementById('chat-input'),
      sendButton: document.getElementById('send-button'),
      welcomeContainer: document.getElementById('welcome-container'),
      imageUploadButton: document.getElementById('image-upload-button')
    };

    let app, auth, db, net = new brain.recurrent.LSTM(), lastTrainingSnapshot = null;
    let pendingFeedback = [];
    let currentModelVersion = 0;  // Track local version

    const defaultTrainingData = [
      { input: "hello", output: "Hey there!" },
      { input: "how are you", output: "I'm doing great, thanks for asking!" },
      { input: "what's up", output: "Just chilling in the cloud, you?" },
      { input: "tell me a joke", output: "Why did the computer go to art school? It wanted to learn how to draw a better 'byte'!" },
      { input: "goodbye", output: "Catch you later, pal!" },
      { input: "what's your name", output: "I'm Vynix AI, your friendly chat buddy!" },
      { input: "how's the weather", output: "No clue, I'm in the cloud! What's it like where you are?" },
      { input: "who made you", output: "Katlego from Mokopane, South Africa, brought me to life!" },
      { input: "help me", output: "Sure thing! What's on your mind?" },
      { input: "latest news", output: "Stay tuned—I'll fetch some headlines soon!" }
    ];

    // SVG Icons for Thumbs
    const THUMB_UP_SVG = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M7 10V7C7 5.939 7.403 4.932 8.091 4.151C8.779 3.369 9.671 3 10.6 3H14C15.1046 3 16 3.89543 16 5V15C16 16.1046 15.1046 17 14 17H10.5C9.94768 17 9.40432 16.7373 9.06066 16.2928C8.717 15.8483 8.58152 15.3037 8.67123 14.75L9.17123 12.75C9.26094 12.1967 9.39642 11.6521 9.740 11.2077C10.0837 10.7632 10.627 10.5 11.18 10.5H13C13.5523 10.5 14 10.1046 14 9.5C14 8.89543 13.5523 8.5 13 8.5H10.6C10.268 8.5 9.94 8.589 9.646 8.774C9.352 8.959 9.121 9.23 9.03 9.55L8.53 11.55C8.44029 12.1033 8.30481 12.6479 7.96115 13.0923C7.61749 13.5368 7.07418 13.8 6.52 13.8H2C1.44772 13.8 1 13.4046 1 12.8V10.8C1 10.2046 1.44772 9.8 2 9.8H5V10H7Z" fill="currentColor"/>
    </svg>`;

    const THUMB_DOWN_SVG = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M17 14V17C17 18.061 16.597 19.068 15.909 19.849C15.221 20.631 14.329 21 13.4 21H9.99999C8.89543 21 8 20.1046 8 19V9C8 7.89543 8.89543 7 9.99999 7H13.4C14.329 7 15.221 6.369 15.909 5.587C16.597 4.805 17 3.798 17 2.757V2.8C17 1.69543 16.1046 1 15 1H10.5C9.94768 1 9.40432 1.26274 9.06066 1.70727C8.717 2.1518 8.58152 2.69635 8.67123 3.24965L9.17123 5.24965C9.26094 5.80295 9.39642 6.3475 9.740 6.79183C10.0837 7.23616 10.627 7.5 11.18 7.5H13C13.5523 7.5 14 7.89543 14 8.5C14 9.10457 13.5523 9.5 13 9.5H10.6C10.268 9.5 9.94 9.411 9.646 9.226C9.352 9.041 9.121 8.77 9.03 8.45L8.53 6.45C8.44029 5.8967 8.30481 5.35215 7.96115 4.90782C7.61749 4.46349 7.07418 4.2 6.52 4.2H2C1.44772 4.2 1 4.59544 1 5.2V7.2C1 7.80457 1.44772 8.2 2 8.2H5V7.2H2V14H7V14.2H17Z" fill="currentColor"/>
    </svg>`;

    function hideLoading() {
      if (!state.isReady) {
        state.isReady = true;
        elements.loadingOverlay.style.display = 'none';
      }
    }

    function normalizeText(text) {
      text = text.toLowerCase().trim();
      const synonyms = {
        "hi": "hello",
        "hey": "hello",
        "whats up": "what's up",
        "joke": "tell me a joke",
        "news": "latest news"
      };
      return synonyms[text] || text;
    }

    function getClosestMatch(prompt, trainingData) {
      const words = prompt.split(' ');
      let bestMatch = null;
      let maxOverlap = 0;

      trainingData.forEach(({ input }) => {
        const inputWords = input.split(' ');
        const overlap = words.filter(word => inputWords.includes(word)).length;
        if (overlap > maxOverlap) {
          maxOverlap = overlap;
          bestMatch = input;
        }
      });

      return bestMatch;
    }

    function anonymizeContent(content) {
      if (!content) return '';
      
      // Basic PII patterns (expand as needed)
      const piiPatterns = [
        /\b[A-Z][a-z]+ [A-Z][a-z]+\b/g,  // Full names (e.g., John Doe)
        /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g,  // Emails
        /\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/g,  // US phones (adapt for SA)
        /\b\d{1,2}[/-]\d{1,2}[/-]\d{2,4}\b/g,  // Dates (potential DOB)
        /\b(Street|Rd|Ave|Ln|Dr|Pretoria|Johannesburg|Mokopane)\b/gi  // Locations/keywords
      ];
      
      let anonymized = content;
      piiPatterns.forEach(pattern => {
        anonymized = anonymized.replace(pattern, '[REDACTED]');
      });
      
      // Generalize sensitive topics
      anonymized = anonymized.replace(/\b(my|our|personal|private)\s+\w+/gi, '[SENSITIVE]');
      
      return anonymized.trim();
    }

    function serializeModel() {
      return {
        json: net.toJSON(),
        version: currentModelVersion,
        trainedAt: Date.now()
      };
    }

    function deserializeModel(modelData) {
      if (modelData && modelData.json) {
        net.fromJSON(modelData.json);
        currentModelVersion = modelData.version || 0;
        console.log(`Deserialized model v${currentModelVersion}, trained at ${new Date(modelData.trainedAt).toLocaleString()}`);
      }
    }

    async function updateSharedModel() {
      if (!auth.currentUser) return;  // Only authenticated users can contribute
      
      const modelRef = ref(db, 'sharedModel/latest');
      const newModelData = serializeModel();
      
      // Use transaction for atomicity: Only update if our version is newer or equal (with tiebreak on timestamp)
      await runTransaction(modelRef, (currentData) => {
        if (!currentData) {
          // No existing: Accept ours
          return newModelData;
        }
        
        if (newModelData.version > currentData.version ||
            (newModelData.version === currentData.version && newModelData.trainedAt > currentData.trainedAt)) {
          // Ours is newer: Update
          console.log('Pushing updated shared model v' + newModelData.version);
          return newModelData;
        }
        
        // Existing is newer: Reject
        console.log('Shared model is already newer; skipping push');
        return currentData;  // No change
      });
      
      // If successful, bump version for next local train
      currentModelVersion++;
    }

    function addTrainingData(input, output) {
      if (!input || !output || input.length > 100 || output.length > 200) {
        console.error('Invalid input/output: must be non-empty and within length limits');
        return;
      }
      const patternsRef = ref(db, 'chatPatterns');
      push(patternsRef, [{ input: normalizeText(input), output }]);
      console.log('Added new training data:', { input, output });
    }

    async function trainOnStatuses() {
      const statusesRef = ref(db, 'statuses');
      const snapshot = await get(statusesRef);
      if (!snapshot.exists()) return;

      let rawStatuses = [];
      snapshot.forEach(child => rawStatuses.push({ id: child.key, ...child.val() }));

      // Filter + ANONYMIZE
      const now = Date.now();
      const filtered = rawStatuses
        .filter(s => 
          s.content && s.content.length > 20 &&
          (s.impressions || 0) > 1 &&
          (now - s.timestamp) < (30 * 24 * 60 * 60 * 1000) &&
          !s.content.match(/spam|buy now|click here/i)
        )
        .map(s => ({ ...s, content: anonymizeContent(s.content) }));  // Anonymize here

      if (filtered.length === 0) return;

      // Generate training pairs: input = status.content, output = derived response (mock based on sentiment)
      const trainingData = filtered.map(s => ({
        input: normalizeText(s.content),
        output: `That's interesting! ${s.content.includes('happy') || s.content.includes('great') ? "Sounds positive—what's making you smile?" : "Tell me more about that."}`
      })).slice(-100); // Cap at 100

      // Incremental training
      const newData = lastTrainingSnapshot 
        ? trainingData.filter(item => !lastTrainingSnapshot.some(prev => prev.input === item.input))
        : trainingData;

      if (newData.length > 0) {
        net.train([...defaultTrainingData, ...newData], {
          iterations: 100, // Increased for better convergence
          errorThresh: 0.01, // Tighter threshold to reduce gibberish
          log: true,
          logPeriod: 10
        });
        console.log(`Trained on ${newData.length} new statuses from ${filtered.length} filtered`);
        lastTrainingSnapshot = trainingData;
        await updateSharedModel();  // Push if newer
      }
    }

    async function trainOnFeedback() {
      const feedbackRef = ref(db, 'userFeedback');
      const snapshot = await get(feedbackRef);
      if (!snapshot.exists()) return;

      let feedbackData = [];
      snapshot.forEach(userSnap => {
        userSnap.forEach(fbSnap => {
          const fb = fbSnap.val();
          if (fb.isUp && fb.prompt && fb.response) {
            // Weight: Duplicate up-votes (e.g., 2x for strong signal)
            feedbackData.push({ input: fb.prompt, output: fb.response });
            if (Math.random() < 0.5) feedbackData.push({ input: fb.prompt, output: fb.response });  // 50% dupe
          }
          // Down-votes: Optionally add negative examples or ignore for now
        });
      });

      if (feedbackData.length > 0) {
        net.train([...defaultTrainingData, ...feedbackData.slice(-50)], {  // Cap to avoid bloat
          iterations: 200,
          errorThresh: 0.005  // Tighter for precision
        });
        console.log(`Retrained on ${feedbackData.length} feedback samples`);
        await updateSharedModel();  // Push if newer
      }
    }

    // Train on internet quotes (Quotable.io)
    async function trainOnQuotes() {
      try {
        const response = await fetch('https://api.quotable.io/quotes?limit=20&tags=inspirational');
        if (!response.ok) throw new Error('Fetch failed');
        const data = await response.json();
        const quotes = data.results || [];

        // Generate training pairs: Map to chat-like inputs/outputs
        const trainingData = quotes.slice(-10).map(q => ({  // Cap at 10 to avoid bloat
          input: normalizeText(`give me a quote about ${q.tags?.[0] || 'life'}`),
          output: anonymizeContent(`${q.content} — ${q.author}`)  // Use your anonymizer
        }));

        if (trainingData.length > 0) {
          // Incremental: Only new/unseen (simple check vs last snapshot)
          const newData = state.lastQuoteSnapshot 
            ? trainingData.filter(item => !state.lastQuoteSnapshot.some(prev => prev.input === item.input))
            : trainingData;
          
          if (newData.length > 0) {
            net.train([...defaultTrainingData, ...newData], {
              iterations: 80,  // Balanced for text quality
              errorThresh: 0.008,  // Tighter for coherent outputs
              log: true,
              logPeriod: 20
            });
            console.log(`Trained on ${newData.length} new quotes from ${quotes.length} fetched`);
            state.lastQuoteSnapshot = trainingData;  // Track for dedup
            await updateSharedModel();  // Share if improved
          }
        }
      } catch (error) {
        console.error('Quotes training failed:', error);
      }
    }

    // Train on internet jokes (Official Joke API)
    async function trainOnJokes() {
      try {
        const response = await fetch('https://official-joke-api.appspot.com/jokes/random/15');
        if (!response.ok) throw new Error('Fetch failed');
        const jokes = await response.json();

        // Generate pairs: e.g., input triggers joke output
        const trainingData = jokes.slice(-8).map(j => ({  // Cap at 8
          input: normalizeText('tell me a joke'),
          output: anonymizeContent(`${j.setup ? `${j.setup} ${j.punchline}` : j.joke}`)  // Handle setup/punchline
        }));

        if (trainingData.length > 0) {
          const newData = state.lastJokeSnapshot 
            ? trainingData.filter(item => !state.lastJokeSnapshot.some(prev => prev.output.includes(item.output.substring(0, 50))))
            : trainingData;  // Rough dedup by content prefix
          
          if (newData.length > 0) {
            net.train([...defaultTrainingData, ...newData], {
              iterations: 60,
              errorThresh: 0.01,
              log: true,
              logPeriod: 15
            });
            console.log(`Trained on ${newData.length} new jokes from ${jokes.length} fetched`);
            state.lastJokeSnapshot = trainingData;
            await updateSharedModel();
          }
        }
      } catch (error) {
        console.error('Jokes training failed:', error);
      }
    }

    // New: Train on internet news (NewsAPI.org)
    async function trainOnNews() {
      if (!NEWS_API_KEY || NEWS_API_KEY === 'YOUR_NEWSAPI_KEY_HERE') {
        console.warn('NewsAPI key not set; skipping news training');
        return;
      }
      try {
        const response = await fetch(`https://newsapi.org/v2/top-headlines?country=us&apiKey=${NEWS_API_KEY}`);
        if (!response.ok) throw new Error('Fetch failed');
        const data = await response.json();
        const articles = data.articles || [];

        // Filter for engaging/non-sensitive news (e.g., tech/science, avoid politics/war)
        const filteredArticles = articles.filter(a => 
          a.title && a.description && 
          (a.title.toLowerCase().includes('tech') || a.title.toLowerCase().includes('science') || 
           a.title.toLowerCase().includes('health') || a.title.toLowerCase().includes('environment')) &&
          !a.title.toLowerCase().match(/war|conflict|politics|election|crime/)
        ).slice(0, 15);  // Limit fetch

        // Generate training pairs: input = news query, output = headline + snippet
        const trainingData = filteredArticles.slice(-10).map(a => ({  // Cap at 10
          input: normalizeText(`latest news on ${a.source.name.toLowerCase() || 'world'}`),
          output: anonymizeContent(`${a.title}. ${a.description.substring(0, 100)}... — ${a.source.name}`)
        }));

        if (trainingData.length > 0) {
          // Incremental: Dedup by title prefix
          const newData = state.lastNewsSnapshot 
            ? trainingData.filter(item => !state.lastNewsSnapshot.some(prev => prev.output.includes(item.output.substring(0, 50))))
            : trainingData;
          
          if (newData.length > 0) {
            net.train([...defaultTrainingData, ...newData], {
              iterations: 70,  // Moderate for factual content
              errorThresh: 0.009,  // Balanced coherence
              log: true,
              logPeriod: 18
            });
            console.log(`Trained on ${newData.length} new news items from ${filteredArticles.length} filtered`);
            state.lastNewsSnapshot = trainingData;
            await updateSharedModel();  // Share if improved
          }
        }
      } catch (error) {
        console.error('News training failed:', error);
      }
    }

    async function initializeBrainJS() {
      const modelRef = ref(db, 'sharedModel/latest');
      
      try {
        // Load shared model
        const snapshot = await get(modelRef);
        if (snapshot.exists()) {
          const modelData = snapshot.val();
          deserializeModel(modelData);
          
          // Optional: Quick fine-tune on user's personal feedback (lightweight, 10 iterations)
          if (auth.currentUser) {
            const userFeedbackRef = ref(db, `userFeedback/${auth.currentUser.uid}`);
            const fbSnapshot = await get(userFeedbackRef);
            if (fbSnapshot.exists()) {
              let userFbData = [];
              fbSnapshot.forEach(snap => {
                const fb = snap.val();
                if (fb.isUp && fb.prompt && fb.response) {
                  userFbData.push({ input: fb.prompt, output: fb.response });
                }
              });
              if (userFbData.length > 0) {
                net.train(userFbData.slice(-10), { iterations: 10, errorThresh: 0.02 });  // Personal delta
                currentModelVersion += 0.1;  // Minor bump for personal tweaks
                console.log(`Fine-tuned on ${userFbData.length} personal samples`);
              }
            }
          }
        } else {
          console.warn('No shared model found; training defaults locally');
        }
      } catch (error) {
        console.error('Failed to load shared model:', error);
      }
      
      // Always ensure basics are trained (fallback)
      net.train(defaultTrainingData, { iterations: 50, errorThresh: 0.015 });
      
      // Periodic: Check for updates every 5min (pull if newer)
      setInterval(async () => {
        try {
          const snapshot = await get(modelRef);
          if (snapshot.exists()) {
            const remoteData = snapshot.val();
            if (remoteData.version > currentModelVersion) {
              deserializeModel(remoteData);
              console.log('Pulled newer shared model!');
            }
          }
        } catch (error) {
          console.error('Periodic model check failed:', error);
        }
      }, 300000);
      
      // Train on statuses and feedback intervals
      setInterval(trainOnStatuses, 300000);
      setInterval(trainOnFeedback, 600000);
      
      // Internet training intervals (staggered to avoid rate limits)
      setInterval(trainOnQuotes, 600000);  // Every 10 min
      setInterval(trainOnJokes, 900000);   // Every 15 min
      setInterval(trainOnNews, 1200000);   // Every 20 min (news updates slower)
      
      if (!state.isReady) hideLoading();
    }

    async function initializeFirebase() {
      app = initializeApp(firebaseConfig);
      auth = getAuth(app);
      db = getDatabase(app);
      const patternsRef = ref(db, 'chatPatterns');
      onValue(patternsRef, (snapshot) => {
        if (!snapshot.exists()) {
          push(ref(db, 'chatPatterns'), defaultTrainingData);
          console.log('Initialized chatPatterns with default data');
        }
      }, { onlyOnce: true });

      onAuthStateChanged(auth, (user) => {
        if (user) {
          elements.chatInput.disabled = false;
          elements.sendButton.disabled = false;
          elements.welcomeContainer.querySelector('h1').textContent = `Hey there, ${user.displayName || 'friend'}!`;
          initializeBrainJS();
        } else {
          setTimeout(() => {
            hideLoading();
            window.location.href = 'signup.html';
          }, 1000);
        }
      });
    }

    function appendMessage(content, sender, isTyping = false, isImage = false, messageId = null) {
      const div = document.createElement('div');
      div.className = `message ${sender}${isTyping ? ' processing' : ''}`;
      if (messageId) div.dataset.messageId = messageId;

      if (isTyping) {
        div.innerHTML = '<div class="typing-indicator"><span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span></div>';
      } else if (isImage) {
        const img = document.createElement('img');
        img.src = content;
        img.alt = 'Uploaded image';
        div.appendChild(img);
      } else {
        div.textContent = content;
      }
      state.messages.push({ content, sender, isImage, timestamp: Date.now(), messageId });
      if (sender === 'ai' && !isTyping) {
        div.classList.add('vibrate');
        if ('vibrate' in navigator) {
          navigator.vibrate(100);
        }
      }
      div.style.opacity = '0';
      setTimeout(() => div.style.opacity = '1', 10);
      elements.chatMessages.appendChild(div);
      elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
      return div;
    }

    async function handleFeedback(event, messageId, isUp) {
      if (!auth.currentUser) return;

      const feedbackRef = ref(db, `feedback/${messageId}`);
      const userId = auth.currentUser.uid;

      // Check if already voted (simple: store per user)
      const snapshot = await get(feedbackRef);
      const existing = snapshot.val() || {};
      if (existing[userId]) {
        console.log('Already voted!');
        return;
      }

      // Store
      await push(ref(db, `userFeedback/${userId}`), { 
        messageId, 
        isUp, 
        prompt: state.messages.find(m => m.messageId === messageId)?.prompt || '',  // On AI msg
        response: state.messages.find(m => m.messageId === messageId)?.content || '',
        timestamp: Date.now() 
      });  // Per-user log
      existing[userId] = isUp ? 'up' : 'down';
      await set(ref(db, feedbackRef), existing);

      // Visual feedback
      const btn = event.target.closest('.feedback-btn');
      btn.classList.add('voted');
      btn.disabled = true;
      // Disable sibling
      const container = btn.closest('.feedback-container');
      const otherBtn = container.querySelector('.feedback-btn:not([disabled])');
      if (otherBtn) {
        otherBtn.disabled = true;
        otherBtn.style.opacity = '0.5';
      }

      console.log(`Feedback: ${isUp ? 'Up' : 'Down'} on ${messageId}`);
      
      // Trigger retrain (debounced)
      pendingFeedback.push({ messageId, isUp });
      if (pendingFeedback.length >= 10) {
        trainOnFeedback();
        pendingFeedback = [];
      }
    }

    async function getAIResponse(prompt) {
      if (!state.hasChatted) {
        state.hasChatted = true;
        elements.welcomeContainer.classList.add('hidden');
      }
      const messageId = Date.now() + Math.random().toString(36);
      const tempMsg = appendMessage('', 'ai', true, false, messageId);
      try {
        const normalizedPrompt = normalizeText(prompt);
        
        // Fix: Set prompt on the AI message for easy lookup in feedback
        state.messages[state.messages.length - 1].prompt = normalizedPrompt;
        
        let response = net.run(normalizedPrompt);

        // If prompt matches quote/joke/news triggers, boost with fresh data (10% chance for variety)
        if ((normalizedPrompt.includes('quote') || normalizedPrompt.includes('inspir')) && Math.random() < 0.1) {
          try {
            const quickQuote = await (await fetch('https://api.quotable.io/random')).json();
            response = `${response} P.S. "${quickQuote.content}" — ${quickQuote.author}`;
          } catch (e) {
            console.error('Quick quote fetch failed:', e);
          }
        } else if (normalizedPrompt.includes('joke') && Math.random() < 0.1) {
          try {
            const quickJoke = await (await fetch('https://official-joke-api.appspot.com/jokes/random')).json();
            response = `${response} Here's a quick one: ${quickJoke.setup ? `${quickJoke.setup} ${quickJoke.punchline}` : quickJoke.joke}`;
          } catch (e) {
            console.error('Quick joke fetch failed:', e);
          }
        } else if (normalizedPrompt.includes('news') && Math.random() < 0.1 && NEWS_API_KEY !== 'YOUR_NEWSAPI_KEY_HERE') {
          try {
            const quickNews = await (await fetch(`https://newsapi.org/v2/top-headlines?country=us&apiKey=${NEWS_API_KEY}`)).json();
            const topArticle = quickNews.articles?.[0];
            if (topArticle) {
              response = `${response} Breaking: "${topArticle.title}" from ${topArticle.source.name}. ${topArticle.description.substring(0, 80)}...`;
            }
          } catch (e) {
            console.error('Quick news fetch failed:', e);
          }
        }

        // Anti-gibberish: Check length, coherence (simple heuristic), fallback if bad
        if (!response || response.length < 5 || response.includes('undefined') || Math.random() < 0.1) { // 10% fallback rate
          // Fallback to closest match from defaults
          const fallbackData = [...defaultTrainingData];
          const closestInput = getClosestMatch(normalizedPrompt, fallbackData);
          response = closestInput
            ? fallbackData.find(item => item.input === closestInput).output
            : 'Hmm, not sure what to say—teach me more!';
        }

        // Ensure response is coherent: Cap length, no repeats
        response = response.substring(0, 200).replace(/(.)\1{2,}/g, '$1$1'); // Remove triple repeats

        tempMsg.textContent = response;
        tempMsg.classList.remove('processing');
        state.messages[state.messages.length - 1].content = response;  // Update AI msg
      } catch (error) {
        const fallback = 'Whoops, my circuits got tangled! Try rephrasing.';
        tempMsg.textContent = fallback;
        tempMsg.classList.remove('processing');
        state.messages[state.messages.length - 1].content = fallback;
        console.error('Brain.js Error:', error);
      }

      // Add feedback buttons after render
      setTimeout(() => {
        if (tempMsg.querySelector('.feedback-container')) return;  // Already added
        const feedbackContainer = document.createElement('div');
        feedbackContainer.className = 'feedback-container';

        const upBtn = document.createElement('button');
        upBtn.className = 'feedback-btn up';
        upBtn.innerHTML = THUMB_UP_SVG;
        upBtn.title = 'Helpful!';
        upBtn.addEventListener('click', (e) => handleFeedback(e, messageId, true));

        const downBtn = document.createElement('button');
        downBtn.className = 'feedback-btn down';
        downBtn.innerHTML = THUMB_DOWN_SVG;
        downBtn.title = 'Not helpful';
        downBtn.addEventListener('click', (e) => handleFeedback(e, messageId, false));

        feedbackContainer.append(upBtn, downBtn);
        tempMsg.appendChild(feedbackContainer);
      }, 100);
    }

    // Image Upload Listener
    elements.imageUploadButton.addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (ev) => {
            const imgUrl = ev.target.result;
            appendMessage(imgUrl, 'user', false, true);  // isImage: true
            // Optional: Upload to Firebase Storage and get public URL
          };
          reader.readAsDataURL(file);
        }
      };
      input.click();
    });

    elements.sendButton.addEventListener('click', async () => {
      const prompt = elements.chatInput.value.trim();
      if (!prompt) return;
      elements.chatInput.value = '';
      appendMessage(prompt, 'user');
      await getAIResponse(prompt);
    });

    elements.chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        elements.sendButton.click();
      }
    });

    document.addEventListener('DOMContentLoaded', initializeFirebase);
  </script>
</body>
</html>
