<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vynix - Trivia & Chat Room</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
  <script src="https://unpkg.com/idb@7/build/umd.js"></script>
  <style>
    :root {
      --background: #FFFFFF;
      --chat-bg: #F5F7FB;
      --text-primary: #111B21;
      --text-secondary: #667781;
      --border: #E9ECEF;
      --accent: #00A884;
    }
    body {
      background: var(--background);
      color: var(--text-primary);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      margin: 0;
      overscroll-behavior: none;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    .header {
      padding: 1rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--background);
    }
    .chat-profile {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    .avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--accent);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 500;
      overflow: hidden;
    }
    .header-actions {
      display: flex;
      gap: 1rem;
    }
    .icon-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 0.5rem;
      color: var(--text-primary);
    }
    .icon-btn svg {
      width: 20px;
      height: 20px;
    }
    .message-list {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .message {
      max-width: 70%;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-size: 0.95rem;
      position: relative;
    }
    .message.sent {
      background: var(--accent);
      color: #FFFFFF;
      align-self: flex-end;
      border-bottom-right-radius: 2px;
    }
    .message.received {
      background: var(--chat-bg);
      color: var(--text-primary);
      align-self: flex-start;
      border-bottom-left-radius: 2px;
    }
    .message.media {
      padding: 0.25rem;
      background: var(--chat-bg);
    }
    .message.sent.media {
      background: var(--accent);
    }
    .message img, .message video {
      max-width: 100%;
      max-height: 200px;
      border-radius: 8px;
      display: block;
    }
    .message audio {
      width: 100%;
      max-width: 200px;
    }
    .message-time {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-top: 0.25rem;
      text-align: right;
    }
    .message-sender {
      font-size: 0.8rem;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 0.25rem;
    }
    .message-input-container {
      padding: 0.75rem;
      border-top: 1px solid var(--border);
      background: var(--background);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .message-input {
      flex: 1;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      border: 1px solid var(--border);
      background: var(--chat-bg);
      color: var(--text-primary);
      outline: none;
      font-size: 0.95rem;
    }
    .fab {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      background: var(--accent);
      border-radius: 16px;
      width: 80px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      cursor: pointer;
      z-index: 20;
    }
    .fab svg {
      width: 20px;
      height: 20px;
      fill: #FFFFFF;
    }
    .fab-tooltip {
      position: absolute;
      background: var(--chat-bg);
      color: var(--text-primary);
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-size: 0.875rem;
      right: 90px;
      bottom: 10px;
      display: none;
    }
    .fab:hover .fab-tooltip {
      display: block;
    }
    .menu-dropdown {
      position: absolute;
      top: 60px;
      right: 1rem;
      background: var(--chat-bg);
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      display: none;
      z-index: 1000;
    }
    .menu-dropdown.active {
      display: block;
    }
    .menu-item {
      padding: 0.75rem 1.5rem;
      cursor: pointer;
      color: var(--text-primary);
      font-size: 0.875rem;
    }
    .menu-item:hover {
      background: var(--background);
    }
    .custom-alert {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.3);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .custom-alert.active {
      display: flex;
    }
    .alert-content {
      background: var(--background);
      border-radius: 12px;
      padding: 1.5rem;
      max-width: 400px;
      width: 90%;
      text-align: center;
    }
    .alert-content p {
      margin: 0 0 1rem;
      font-size: 1rem;
    }
    .alert-content input {
      width: 100%;
      padding: 0.5rem;
      margin-bottom: 1rem;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--chat-bg);
      color: var(--text-primary);
      display: none;
    }
    .alert-buttons {
      display: flex;
      gap: 1rem;
      justify-content: center;
    }
    .alert-buttons button {
      padding: 0.5rem 1.5rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.875rem;
    }
    #alert-confirm {
      background: var(--accent);
      color: #FFFFFF;
    }
    #alert-cancel {
      background: var(--border);
      color: var(--text-primary);
    }
    .spinner-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.3);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .spinner-overlay.active {
      display: flex;
    }
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid var(--accent);
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .shimmer {
      animation: shimmer 1.5s infinite;
    }
    .shimmer-item {
      display: flex;
      align-items: center;
      padding: 0.75rem;
      border-bottom: 1px solid var(--border);
    }
    .shimmer-text {
      flex: 1;
    }
    .shimmer-line {
      height: 12px;
      background: var(--border);
      margin-bottom: 0.5rem;
      border-radius: 4px;
    }
    .shimmer-line.long { width: 80%; }
    .shimmer-line.short { width: 50%; }
    @keyframes shimmer {
      0% { opacity: 0.5; }
      50% { opacity: 1; }
      100% { opacity: 0.5; }
    }
    .trivia-container, .poll-container, .leaderboard-container {
      padding: 1rem;
      background: var(--chat-bg);
      border-top: 1px solid var(--border);
    }
    .trivia-item, .poll-item, .leaderboard-item {
      padding: 0.75rem;
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-bottom: 0.5rem;
    }
    .trivia-option, .poll-option {
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 4px;
    }
    .trivia-option:hover, .trivia-option.voted, .poll-option:hover, .poll-option.voted {
      background: var(--accent);
      color: #FFFFFF;
    }
    .trivia-results, .poll-results {
      font-size: 0.8rem;
      color: var(--text-secondary);
    }
    .badge {
      background: var(--accent);
      color: #FFFFFF;
      border-radius: 12px;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      margin-left: 0.5rem;
    }
    .tip-btn {
      background: var(--accent);
      color: #FFFFFF;
      border: none;
      border-radius: 8px;
      padding: 0.25rem 0.5rem;
      font-size: 0.8rem;
      cursor: pointer;
      margin-top: 0.25rem;
    }
    .tip-btn:hover {
      background: #008a68;
    }
    @media (max-width: 640px) {
      .header { padding: 0.75rem; }
      .avatar { width: 32px; height: 32px; }
      .message-list { padding: 0.5rem; }
      .message { font-size: 0.9rem; max-width: 80%; }
      .message img, .message video { max-height: 150px; }
      .message audio { max-width: 150px; }
      .message-input { font-size: 0.9rem; padding: 0.5rem; }
      .fab { width: 70px; height: 36px; bottom: 0.75rem; right: 0.75rem; }
      .fab svg { width: 18px; height: 18px; }
      .fab-tooltip { font-size: 0.8rem; padding: 0.4rem 0.8rem; right: 80px; bottom: 8px; }
      .menu-dropdown { top: 50px; }
      .menu-item { font-size: 0.8rem; padding: 0.5rem 1rem; }
      .icon-btn svg { width: 18px; height: 18px; }
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="chat-profile">
      <button class="icon-btn" onclick="window.location.href='index.html'">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M15 18l-6-6 6-6" />
        </svg>
      </button>
      <div id="room-avatar" class="avatar"></div>
      <div>
        <span id="room-name">Loading...</span>
        <p id="room-members" class="text-sm text-[var(--text-secondary)] mt-1">0 members</p>
      </div>
    </div>
    <div class="header-actions">
      <button class="icon-btn" onclick="window.toggleMenu()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="3" y1="12" x2="21" y2="12"></line>
          <line x1="3" y1="6" x2="21" y2="6"></line>
          <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
      </button>
    </div>
  </div>
  <div id="menu-dropdown" class="menu-dropdown">
    <div class="menu-item" onclick="window.location.href='profile.html'">Profile</div>
    <div class="menu-item" onclick="window.location.href='settings.html'">Settings</div>
    <div class="menu-item" onclick="window.setRoomLanguage()">Set Room Language</div>
    <div class="menu-item" onclick="firebase.auth().signOut()">Sign Out</div>
  </div>
  <div id="message-list" class="message-list"></div>
  <div class="trivia-container" id="trivia-container">
    <button class="btn primary" onclick="window.createTrivia()">Create Trivia</button>
  </div>
  <div class="poll-container" id="poll-container">
    <button class="btn primary" onclick="window.createPoll()">Create Poll</button>
  </div>
  <div class="leaderboard-container" id="leaderboard-container">
    <h3 id="leaderboard-title">Leaderboard</h3>
  </div>
  <div class="message-input-container">
    <button id="attachment-btn" class="icon-btn">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48" />
      </svg>
    </button>
    <input id="media-upload" type="file" accept="image/jpeg,image/png,video/mp4,video/mov" style="display: none;" />
    <input id="message-input" class="message-input" type="text" placeholder="Type a message..." />
    <button id="mic-btn" class="icon-btn">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z" />
        <path d="M19 10v2a7 7 0 0 1-14 0v-2" />
        <line x1="12" y1="19" x2="12" y2="23" />
        <line x1="8" y1="23" x2="16" y2="23" />
      </svg>
    </button>
  </div>
  <div id="fab" class="fab">
    <svg id="fab-icon" viewBox="0 0 24 24">
      <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" />
    </svg>
    <span id="fab-tooltip" class="fab-tooltip">Send Message</span>
  </div>
  <div id="custom-alert" class="custom-alert">
    <div class="alert-content">
      <p id="alert-message"></p>
      <input id="alert-input" type="text" />
      <div id="alert-buttons" class="alert-buttons">
        <button id="alert-confirm">OK</button>
        <button id="alert-cancel">Cancel</button>
      </div>
    </div>
  </div>
  <div id="spinner-overlay" class="spinner-overlay">
    <div class="spinner"></div>
  </div>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { getDatabase, ref, onValue, push, get, update, set, remove } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

    // Replace with your Firebase config
    const firebaseConfig = {
      apiKey: "YOUR_API_KEY",
      authDomain: "YOUR_AUTH_DOMAIN",
      databaseURL: "YOUR_DATABASE_URL",
      projectId: "YOUR_PROJECT_ID",
      storageBucket: "YOUR_STORAGE_BUCKET",
      messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
      appId: "YOUR_APP_ID",
      measurementId: "YOUR_MEASUREMENT_ID"
    };

    const ROUTES = {
      INDEX: 'index.html',
      PROFILE: 'profile.html',
      SETTINGS: 'settings.html'
    };

    const MESSAGES = {
      en: {
        SIGN_IN_REQUIRED: 'Please sign in to view this room.',
        ROOM_NOT_FOUND: 'Room not found.',
        ROOM_ACCESS_DENIED: 'You are not a member of this room.',
        INVALID_INVITE_CODE: 'Invalid invite code.',
        MESSAGE_SEND_FAIL: 'Failed to send message.',
        ROOM_JOIN_SUCCESS: 'Joined room successfully!',
        ROOM_JOIN_FAIL: 'Failed to join room.',
        TRIVIA_CREATED: 'Trivia created!',
        TRIVIA_VOTED: 'Answer submitted!',
        TRIVIA_ALREADY_VOTED: 'You have already answered this trivia.',
        POLL_CREATED: 'Poll created!',
        POLL_VOTED: 'Voted!',
        POLL_ALREADY_VOTED: 'You have already voted in this poll.',
        TIP_PROMPT: 'Enter Vynix Coins to tip:',
        TIP_INSUFFICIENT: 'Insufficient Vynix Coins.',
        TIP_SUCCESS: 'Tipped {amount} Vynix Coins!',
        LOAD_ERROR: 'Failed to load room data.',
        NO_DATA: 'No data available.'
      },
      zu: {
        SIGN_IN_REQUIRED: 'Sicela ungene ukuze ubone leli gumbi.',
        ROOM_NOT_FOUND: 'Igumbi alitholakali.',
        ROOM_ACCESS_DENIED: 'Awulona ilungu laleli gumbi.',
        INVALID_INVITE_CODE: 'Ikhodi yesimemo ayilungile.',
        MESSAGE_SEND_FAIL: 'Kwehlulekile ukuthumela umlayezo.',
        ROOM_JOIN_SUCCESS: 'Ujoyine igumbi ngempumelelo!',
        ROOM_JOIN_FAIL: 'Kwehlulekile ukujoyina igumbi.',
        TRIVIA_CREATED: 'I-trivia idaliwe!',
        TRIVIA_VOTED: 'Impendulo ithunyelwe!',
        TRIVIA_ALREADY_VOTED: 'Usuphendule le trivia.',
        POLL_CREATED: 'Ipholisi idaliwe!',
        POLL_VOTED: 'Uvotile!',
        POLL_ALREADY_VOTED: 'Uvele wavota kule pholisi.',
        TIP_PROMPT: 'Faka ama-Vynix Coins ukuze utiphe:',
        TIP_INSUFFICIENT: 'Ama-Vynix Coins awanele.',
        TIP_SUCCESS: 'Utishwe {amount} ama-Vynix Coins!',
        LOAD_ERROR: 'Kwehlulekile ukulayisha idatha yegumbi.',
        NO_DATA: 'Ayikho idatha etholakalayo.'
      },
      xh: {
        SIGN_IN_REQUIRED: 'Nceda ungene ukuze ubone eli gumbi.',
        ROOM_NOT_FOUND: 'Igumbi alifumaneki.',
        ROOM_ACCESS_DENIED: 'Awulilo ilungu leli gumbi.',
        INVALID_INVITE_CODE: 'Ikhowudi yesimemo ayilunganga.',
        MESSAGE_SEND_FAIL: 'Kusilelwe ukuthumela umyalezo.',
        ROOM_JOIN_SUCCESS: 'Ujoyine igumbi ngempumelelo!',
        ROOM_JOIN_FAIL: 'Kusilelwe ukujoyina igumbi.',
        TRIVIA_CREATED: 'I-trivia yenziwe!',
        TRIVIA_VOTED: 'Impendulo ithunyelwe!',
        TRIVIA_ALREADY_VOTED: 'Sele uphendule le trivia.',
        POLL_CREATED: 'Ipholisi yenziwe!',
        POLL_VOTED: 'Uvote!',
        POLL_ALREADY_VOTED: 'Sele uvote kule pholisi.',
        TIP_PROMPT: 'Ngenisa ii-Vynix Coins zokutipha:',
        TIP_INSUFFICIENT: 'Ii-Vynix Coins azanelanga.',
        TIP_SUCCESS: 'Uthiphe {amount} ii-Vynix Coins!',
        LOAD_ERROR: 'Kusilelwe ukulayisha idatha yegumbi.',
        NO_DATA: 'Akukho datha ifumanekayo.'
      },
      af: {
        SIGN_IN_REQUIRED: 'Meld asseblief aan om hierdie kamer te sien.',
        ROOM_NOT_FOUND: 'Kamer nie gevind nie.',
        ROOM_ACCESS_DENIED: 'Jy is nie 'n lid van hierdie kamer nie.',
        INVALID_INVITE_CODE: 'Ongeldige uitnodigingskode.',
        MESSAGE_SEND_FAIL: 'Kon nie boodskap stuur nie.',
        ROOM_JOIN_SUCCESS: 'Het die kamer suksesvol aangesluit!',
        ROOM_JOIN_FAIL: 'Kon nie die kamer aansluit nie.',
        TRIVIA_CREATED: 'Trivia geskep!',
        TRIVIA_VOTED: 'Antwoord ingedien!',
        TRIVIA_ALREADY_VOTED: 'Jy het reeds hierdie trivia beantwoord.',
        POLL_CREATED: 'Peiling geskep!',
        POLL_VOTED: 'Gestem!',
        POLL_ALREADY_VOTED: 'Jy het reeds in hierdie peiling gestem.',
        TIP_PROMPT: 'Voer Vynix Coins in om te tip:',
        TIP_INSUFFICIENT: 'Onvoldoende Vynix Coins.',
        TIP_SUCCESS: 'Het {amount} Vynix Coins getip!',
        LOAD_ERROR: 'Kon nie kamerdata laai nie.',
        NO_DATA: 'Geen data beskikbaar nie.'
      }
    };

    const LEADERBOARD_TITLES = {
      en: "Leaderboard",
      zu: "Ibhodi Yabaholi",
      xh: "Ibhodi Yeenkokeli",
      af: "Leierbord"
    };

    const TRIVIA_QUESTIONS = [
      {
        question: {
          en: "Who won the 2023 Rugby World Cup?",
          zu: "Ngubani owawina iNdebe yoMhlaba yeRugby 2023?",
          xh: "Ngubani ophumelele iNdebe yeHlabathi yoMbhoxo ka-2023?",
          af: "Wie het die 2023 Rugby Wêreldbekers gewen?"
        },
        options: [
          { en: "South Africa", zu: "iNingizimu Afrika", xh: "uMzantsi Afrika", af: "Suid-Afrika" },
          { en: "New Zealand", zu: "iNew Zealand", xh: "iNew Zealand", af: "Nieu-Seeland" },
          { en: "Australia", zu: "i-Australia", xh: "i-Australia", af: "Australië" },
          { en: "France", zu: "i-France", xh: "i-France", af: "Frankryk" }
        ],
        answer: "South Africa"
      },
      {
        question: {
          en: "What is the capital of South Africa?",
          zu: "Yini inhlokodolobha yaseNingizimu Afrika?",
          xh: "Yiyiphi ikomkhulu loMzantsi Afrika?",
          af: "Wat is die hoofstad van Suid-Afrika?"
        },
        options: [
          { en: "Pretoria", zu: "iPitoli", xh: "iPitoli", af: "Pretoria" },
          { en: "Cape Town", zu: "iKapa", xh: "iKapa", af: "Kaapstad" },
          { en: "Johannesburg", zu: "iGoli", xh: "iRhawuti", af: "Johannesburg" },
          { en: "Durban", zu: "iTheku", xh: "iTheku", af: "Durban" }
        ],
        answer: "Pretoria"
      },
      {
        question: {
          en: "Which is South Africa's largest township?",
          zu: "Yisiphi isigodi esikhulu kunazo zonke eNingizimu Afrika?",
          xh: "Yeyiphi ilokishi enkulu kuMzantsi Afrika?",
          af: "Wat is Suid-Afrika se grootste township?"
        },
        options: [
          { en: "Soweto", zu: "iSoweto", xh: "iSoweto", af: "Soweto" },
          { en: "Khayelitsha", zu: "iKhayelitsha", xh: "iKhayelitsha", af: "Khayelitsha" },
          { en: "Tembisa", zu: "iTembisa", xh: "iTembisa", af: "Tembisa" },
          { en: "Katlehong", zu: "iKatlehong", xh: "iKatlehong", af: "Katlehong" }
        ],
        answer: "Soweto"
      }
    ];

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getDatabase(app);
    const customAlert = document.getElementById("custom-alert");
    const alertMessage = document.getElementById("alert-message");
    const alertInput = document.getElementById("alert-input");
    const alertConfirm = document.getElementById("alert-confirm");
    const alertCancel = document.getElementById("alert-cancel");
    const messageList = document.getElementById("message-list");
    const roomAvatar = document.getElementById("room-avatar");
    const roomName = document.getElementById("room-name");
    const roomMembers = document.getElementById("room-members");
    const messageInput = document.getElementById("message-input");
    const fab = document.getElementById("fab");
    const menuDropdown = document.getElementById("menu-dropdown");
    const spinnerOverlay = document.getElementById("spinner-overlay");
    let alertResolve = null;
    const ENCRYPTION_KEY = "my-secret-key-123";
    const TRIVIA_INTERVAL = 60 * 60 * 1000; // 1 hour
    let lastMessageTimestamp = 0;

    const dbPromise = openDB('VynixDB', 1, {
      upgrade(db) {
        db.createObjectStore('trivia', { keyPath: 'id' });
        db.createObjectStore('polls', { keyPath: 'id' });
        db.createObjectStore('messages', { keyPath: 'id' });
      }
    });

    async function cacheData(storeName, roomId, data) {
      try {
        const db = await dbPromise;
        const tx = db.transaction(storeName, 'readwrite');
        const store = tx.objectStore(storeName);
        Object.entries(data).forEach(([id, item]) => store.put({ id: `${roomId}_${id}`, ...item }));
        await tx.done;
        console.log(`${storeName} cached for room:`, roomId);
      } catch (error) {
        console.error(`Error caching ${storeName}:`, error);
      }
    }

    async function getCachedData(storeName, roomId) {
      try {
        const db = await dbPromise;
        const tx = db.transaction(storeName, 'readonly');
        const store = tx.objectStore(storeName);
        const items = await store.getAll();
        return items.reduce((acc, item) => {
          if (item.id.startsWith(`${roomId}_`)) acc[item.id.replace(`${roomId}_`, '')] = item;
          return acc;
        }, {});
      } catch (error) {
        console.error(`Error retrieving cached ${storeName}:`, error);
        return {};
      }
    }

    window.showAlert = function (message, autoHide = true, input = false, confirmCallback = null, cancelCallback = null) {
      return new Promise((resolve) => {
        const roomId = new URLSearchParams(window.location.search).get('roomId') || 'default';
        get(ref(db, `chatrooms/${roomId}`)).then(snapshot => {
          const room = snapshot.val() || { language: 'en' };
          alertMessage.textContent = MESSAGES[room.language][message] || message;
          alertInput.style.display = input ? "block" : "none";
          alertConfirm.style.display = confirmCallback || input ? "block" : "none";
          alertCancel.style.display = cancelCallback || input ? "block" : "none";
          customAlert.classList.add("active");
          alertResolve = resolve;

          if (input) alertInput.focus();

          if (autoHide && !confirmCallback && !cancelCallback) {
            setTimeout(window.hideAlert, 5000);
          }

          alertConfirm.onclick = () => {
            if (confirmCallback) confirmCallback(input ? alertInput.value : true);
            resolve(input ? alertInput.value : true);
            window.hideAlert();
          };

          alertCancel.onclick = () => {
            if (cancelCallback) cancelCallback();
            resolve(false);
            window.hideAlert();
          };
        }).catch(error => {
          console.error('Error fetching room language:', error);
          alertMessage.textContent = MESSAGES['en'][message] || message;
          alertInput.style.display = input ? "block" : "none";
          alertConfirm.style.display = confirmCallback || input ? "block" : "none";
          alertCancel.style.display = cancelCallback || input ? "block" : "none";
          customAlert.classList.add("active");
          alertResolve = resolve;

          if (input) alertInput.focus();

          if (autoHide && !confirmCallback && !cancelCallback) {
            setTimeout(window.hideAlert, 5000);
          }

          alertConfirm.onclick = () => {
            if (confirmCallback) confirmCallback(input ? alertInput.value : true);
            resolve(input ? alertInput.value : true);
            window.hideAlert();
          };

          alertCancel.onclick = () => {
            if (cancelCallback) cancelCallback();
            resolve(false);
            window.hideAlert();
          };
        });
      });
    };

    window.hideAlert = function () {
      customAlert.classList.remove("active");
      alertInput.style.display = "none";
      alertConfirm.style.display = "none";
      alertCancel.style.display = "none";
      alertInput.value = "";
      alertResolve = null;
    };

    window.toggleMenu = function () {
      menuDropdown.classList.toggle("active");
    };

    function showShimmer(count = 5) {
      messageList.innerHTML = '';
      for (let i = 0; i < count; i++) {
        const shimmerItem = document.createElement('div');
        shimmerItem.className = 'shimmer-item shimmer';
        shimmerItem.innerHTML = `
          <div class="shimmer-text">
            <div class="shimmer-line long"></div>
            <div class="shimmer-line short"></div>
          </div>
        `;
        messageList.appendChild(shimmerItem);
      }
    }

    function decryptMessage(ciphertext) {
      try {
        const bytes = CryptoJS.AES.decrypt(ciphertext, ENCRYPTION_KEY);
        const decrypted = bytes.toString(CryptoJS.enc.Utf8);
        return decrypted || '[Decryption Failed]';
      } catch (error) {
        console.error("Decryption error:", error);
        return '[Decryption Failed]';
      }
    }

    function formatTimestamp(timestamp) {
      try {
        const date = new Date(timestamp);
        const now = new Date();
        const diffDays = Math.floor((now - date) / (1000 * 60 * 60 * 24));
        if (diffDays === 0) {
          return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        } else if (diffDays === 1) {
          return 'Yesterday';
        } else {
          return date.toLocaleDateString();
        }
      } catch (error) {
        console.error('Error formatting timestamp:', error);
        return 'Unknown';
      }
    }

    async function uploadMedia(file) {
      try {
        const formData = new FormData();
        formData.append('file', file);
        formData.append('upload_preset', 'banter_box');
        spinnerOverlay.classList.add('active');
        const response = await fetch('https://api.cloudinary.com/v1_1/dqkujefxj/auto/upload', {
          method: 'POST',
          body: formData
        });
        const data = await response.json();
        spinnerOverlay.classList.remove('active');
        if (data.secure_url) {
          return { url: data.secure_url, type: file.type.startsWith('image/') ? 'image' : file.type.startsWith('video/') ? 'video' : 'voice' };
        } else {
          throw new Error('Upload failed');
        }
      } catch (error) {
        spinnerOverlay.classList.remove('active');
        console.error('Error uploading media:', error);
        window.showAlert('Failed to upload media.', false);
        return null;
      }
    }

    async function startRecording() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const recorder = new MediaRecorder(stream);
        const chunks = [];
        recorder.ondataavailable = (e) => chunks.push(e.data);
        recorder.onstop = async () => {
          const blob = new Blob(chunks, { type: 'audio/mp3' });
          const file = new File([blob], `voice_note_${Date.now()}.mp3`, { type: 'audio/mp3' });
          const media = await uploadMedia(file);
          if (media) {
            const userId = auth.currentUser?.uid;
            const roomId = new URLSearchParams(window.location.search).get('roomId');
            if (userId && roomId) {
              await sendMessage(userId, roomId, media.url, media.type);
            }
          }
          stream.getTracks().forEach(track => track.stop());
        };
        recorder.start();
        window.showAlert('Recording... Click OK to stop.', false, false, () => recorder.stop());
      } catch (error) {
        console.error('Error recording voice note:', error);
        window.showAlert('Failed to record voice note.', false);
      }
    }

    async function createAutoTrivia(roomId) {
      try {
        console.log('Checking for new trivia in room:', roomId);
        const roomRef = ref(db, `chatrooms/${roomId}`);
        const roomSnapshot = await get(roomRef);
        if (!roomSnapshot.exists()) {
          console.error('Room not found:', roomId);
          return;
        }
        const room = roomSnapshot.val();
        const lastTriviaTime = room.lastTriviaTime || 0;
        if (Date.now() - lastTriviaTime < TRIVIA_INTERVAL) {
          console.log('Too soon for new trivia:', lastTriviaTime);
          return;
        }

        const triviaRef = ref(db, `chatrooms/${roomId}/trivia`);
        const triviaSnapshot = await get(triviaRef);
        const usedQuestions = Object.values(triviaSnapshot.val() || {}).map(t => t.question.en);
        let availableQuestions = TRIVIA_QUESTIONS.filter(q => !usedQuestions.includes(q.question.en));

        if (availableQuestions.length === 0) {
          console.log('Resetting trivia questions as all used');
          await remove(ref(db, `chatrooms/${roomId}/trivia`));
          availableQuestions = [...TRIVIA_QUESTIONS];
        }

        const questionIndex = Math.floor(Math.random() * availableQuestions.length);
        const triviaData = {
          question: availableQuestions[questionIndex].question,
          options: availableQuestions[questionIndex].options,
          answer: availableQuestions[questionIndex].answer,
          creatorId: 'system',
          timestamp: Date.now(),
          vynixReward: 5,
          streakBonus: 2
        };
        const triviaId = push(ref(db, `chatrooms/${roomId}/trivia`)).key;
        await set(ref(db, `chatrooms/${roomId}/trivia/${triviaId}`), triviaData);
        await update(ref(db, `chatrooms/${roomId}`), { lastTriviaTime: Date.now() });
        await push(ref(db, `chatrooms/${roomId}/messages`), {
          content: CryptoJS.AES.encrypt(`New trivia: ${triviaData.question[room.language || 'en']}`, ENCRYPTION_KEY).toString(),
          senderId: 'system',
          type: 'text',
          timestamp: Date.now(),
          read: true
        });
        console.log('New trivia created:', triviaData.question.en);

        const trivia = triviaSnapshot.val() || {};
        for (const oldTriviaId in trivia) {
          await set(ref(db, `chatrooms/${roomId}/trivia/${oldTriviaId}/votes`), {});
        }
      } catch (error) {
        console.error('Error creating auto trivia:', error);
      }
    }

    window.createTrivia = async function() {
      try {
        const roomId = new URLSearchParams(window.location.search).get('roomId');
        const roomSnapshot = await get(ref(db, `chatrooms/${roomId}`));
        const room = roomSnapshot.val() || { language: 'en' };
        const question = await window.showAlert('Enter trivia question:', false, true);
        const options = await window.showAlert('Enter options (comma-separated):', false, true);
        const answer = await window.showAlert('Enter correct answer:', false, true);
        if (question && options && answer) {
          const triviaId = push(ref(db, `chatrooms/${roomId}/trivia`)).key;
          const triviaData = {
            question: { [room.language || 'en']: question },
            options: options.split(',').map(opt => ({ [room.language || 'en']: opt.trim() })),
            answer: answer.trim(),
            creatorId: auth.currentUser.uid,
            timestamp: Date.now(),
            vynixReward: 0,
            streakBonus: 0
          };
          await set(ref(db, `chatrooms/${roomId}/trivia/${triviaId}`), triviaData);
          window.showAlert('TRIVIA_CREATED', true);
          console.log('Manual trivia created:', question);
        }
      } catch (error) {
        console.error('Error creating trivia:', error);
        window.showAlert('Failed to create trivia.', false);
      }
    };

    window.createPoll = async function() {
      try {
        const roomId = new URLSearchParams(window.location.search).get('roomId');
        const roomSnapshot = await get(ref(db, `chatrooms/${roomId}`));
        const room = roomSnapshot.val() || { language: 'en' };
        const question = await window.showAlert('Enter poll question:', false, true);
        const options = await window.showAlert('Enter options (comma-separated):', false, true);
        if (question && options) {
          const pollId = push(ref(db, `chatrooms/${roomId}/polls`)).key;
          const pollData = {
            question: { [room.language || 'en']: question },
            options: options.split(',').map(opt => ({ [room.language || 'en']: opt.trim() })),
            votes: {},
            creatorId: auth.currentUser.uid,
            timestamp: Date.now(),
            vynixReward: 0
          };
          await set(ref(db, `chatrooms/${roomId}/polls/${pollId}`), pollData);
          window.showAlert('POLL_CREATED', true);
          console.log('Manual poll created:', question);
        }
      } catch (error) {
        console.error('Error creating poll:', error);
        window.showAlert('Failed to create poll.', false);
      }
    };

    function renderTrivia(roomId) {
      const triviaContainer = document.getElementById('trivia-container');
      try {
        onValue(ref(db, `chatrooms/${roomId}/trivia`), async (snapshot) => {
          const trivia = snapshot.val() || {};
          console.log('Rendering trivia:', trivia);
          await cacheData('trivia', roomId, trivia);
          triviaContainer.innerHTML = '<button class="btn primary" onclick="window.createTrivia()">Create Trivia</button>';
          if (Object.keys(trivia).length === 0) {
            triviaContainer.innerHTML += '<p>No trivia available.</p>';
            return;
          }
          const roomSnapshot = await get(ref(db, `chatrooms/${roomId}`));
          const room = roomSnapshot.val() || { language: 'en' };
          const usersRef = ref(db, 'users');
          const userSnapshot = await get(usersRef);
          const users = userSnapshot.val() || {};
          Object.entries(trivia).slice(-10).forEach(([triviaId, triviaData]) => {
            const userVote = triviaData.votes[auth.currentUser?.uid];
            const voteCounts = triviaData.options.reduce((acc, opt) => {
              acc[opt[room.language || 'en']] = Object.values(triviaData.votes || {}).filter(v => v === opt[room.language || 'en']).length;
              return acc;
            }, {});
            const triviaHtml = `
              <div class="trivia-item">
                <h3>${triviaData.question[room.language || 'en'] || 'No question'}</h3>
                <div class="trivia-options">
                  ${triviaData.options.map(opt => `
                    <div class="trivia-option ${userVote === opt[room.language || 'en'] ? 'voted' : ''}" onclick="voteTrivia('${roomId}', '${triviaId}', '${opt[room.language || 'en']}', '${triviaData.answer || ''}', ${triviaData.vynixReward}, ${triviaData.streakBonus})">
                      ${opt[room.language || 'en']} (${voteCounts[opt[room.language || 'en']] || 0} votes)
                    </div>
                  `).join('')}
                </div>
                <div class="trivia-results">Total votes: ${Object.keys(triviaData.votes || {}).length}</div>
              </div>
            `;
            triviaContainer.innerHTML += triviaHtml;
          });
        }, async (error) => {
          console.error('Error fetching trivia:', error);
          const cachedTrivia = await getCachedData('trivia', roomId);
          triviaContainer.innerHTML = '<button class="btn primary" onclick="window.createTrivia()">Create Trivia</button>';
          if (Object.keys(cachedTrivia).length === 0) {
            triviaContainer.innerHTML += '<p>No trivia available (offline).</p>';
          } else {
            Object.entries(cachedTrivia).forEach(([triviaId, triviaData]) => {
              const userVote = triviaData.votes[auth.currentUser?.uid];
              const voteCounts = triviaData.options.reduce((acc, opt) => {
                acc[opt.en] = Object.values(triviaData.votes || {}).filter(v => v === opt.en).length;
                return acc;
              }, {});
              const triviaHtml = `
                <div class="trivia-item">
                  <h3>${triviaData.question.en || 'No question'}</h3>
                  <div class="trivia-options">
                    ${triviaData.options.map(opt => `
                      <div class="trivia-option ${userVote === opt.en ? 'voted' : ''}">
                        ${opt.en} (${voteCounts[opt.en] || 0} votes)
                      </div>
                    `).join('')}
                  </div>
                  <div class="trivia-results">Total votes: ${Object.keys(triviaData.votes || {}).length} (cached)</div>
                </div>
              `;
              triviaContainer.innerHTML += triviaHtml;
            });
          }
        });
      } catch (error) {
        console.error('Error rendering trivia:', error);
        triviaContainer.innerHTML = '<p>Error loading trivia.</p>';
      }
    }

    window.voteTrivia = async function(roomId, triviaId, option, answer, vynixReward, streakBonus) {
      try {
        const userId = auth.currentUser.uid;
        const triviaRef = ref(db, `chatrooms/${roomId}/trivia/${triviaId}`);
        const triviaSnapshot = await get(triviaRef);
        const trivia = triviaSnapshot.val();
        const roomSnapshot = await get(ref(db, `chatrooms/${roomId}`));
        const room = roomSnapshot.val() || { language: 'en' };
        if (!trivia) {
          window.showAlert('Trivia not found.', false);
          return;
        }
        if (trivia.votes[userId]) {
          window.showAlert('TRIVIA_ALREADY_VOTED', false);
          return;
        }
        await set(ref(db, `chatrooms/${roomId}/trivia/${triviaId}/votes/${userId}`), option);
        window.showAlert('TRIVIA_VOTED', true);
        if (trivia.creatorId === 'system' && answer && option === answer) {
          const userRef = ref(db, `chatrooms/${roomId}/leaderboards/${userId}`);
          const userSnapshot = await get(userRef);
          const userData = userSnapshot.val() || { streak: 0, points: 0 };
          const newStreak = userData.streak + 1;
          const reward = vynixReward + (newStreak >= 3 ? streakBonus : 0);
          await update(ref(db, `wallets/${userId}`), {
            balance: ((await get(ref(db, `wallets/${userId}`))).val()?.balance || 0) + reward
          });
          await push(ref(db, `wallets/${userId}/transactions`), {
            amount: reward,
            type: 'trivia_reward',
            roomId,
            timestamp: Date.now()
          });
          await push(ref(db, `chatrooms/${roomId}/messages`), {
            content: CryptoJS.AES.encrypt(`Correct answer! You earned ${reward} Vynix Coins${newStreak >= 3 ? ' (streak bonus!)' : ''}.`, ENCRYPTION_KEY).toString(),
            senderId: 'system',
            type: 'text',
            timestamp: Date.now(),
            read: true
          });
          await update(ref(db, `chatrooms/${roomId}/leaderboards/${userId}`), {
            points: userData.points + reward,
            streak: newStreak
          });
          if (newStreak >= 3) {
            await update(ref(db, `chatrooms/${roomId}/leaderboards/${userId}`), {
              badges: { "Trivia Master": true },
              lastBadgeTime: Date.now()
            });
          }
        } else if (trivia.creatorId === 'system' && option !== answer) {
          await update(ref(db, `chatrooms/${roomId}/leaderboards/${userId}`), { streak: 0 });
        }
        console.log('Voted on trivia:', triviaId, option);
      } catch (error) {
        console.error('Error voting on trivia:', error);
        window.showAlert('Failed to vote.', false);
      }
    };

    function renderPolls(roomId) {
      const pollContainer = document.getElementById('poll-container');
      try {
        onValue(ref(db, `chatrooms/${roomId}/polls`), async (snapshot) => {
          const polls = snapshot.val() || {};
          console.log('Rendering polls:', polls);
          await cacheData('polls', roomId, polls);
          pollContainer.innerHTML = '<button class="btn primary" onclick="window.createPoll()">Create Poll</button>';
          if (Object.keys(polls).length === 0) {
            pollContainer.innerHTML += '<p>No polls available.</p>';
            return;
          }
          const roomSnapshot = await get(ref(db, `chatrooms/${roomId}`));
          const room = roomSnapshot.val() || { language: 'en' };
          const usersRef = ref(db, 'users');
          const userSnapshot = await get(usersRef);
          const users = userSnapshot.val() || {};
          Object.entries(polls).slice(-10).forEach(([pollId, poll]) => {
            const userVote = poll.votes[auth.currentUser?.uid];
            const voteCounts = poll.options.reduce((acc, opt) => {
              acc[opt[room.language || 'en']] = Object.values(poll.votes || {}).filter(v => v === opt[room.language || 'en']).length;
              return acc;
            }, {});
            const pollHtml = `
              <div class="poll-item">
                <h3>${poll.question[room.language || 'en'] || 'No question'}</h3>
                <div class="poll-options">
                  ${poll.options.map(opt => `
                    <div class="poll-option ${userVote === opt[room.language || 'en'] ? 'voted' : ''}" onclick="votePoll('${roomId}', '${pollId}', '${opt[room.language || 'en']}', '${poll.answer || ''}')">
                      ${opt[room.language || 'en']} (${voteCounts[opt[room.language || 'en']] || 0} votes)
                    </div>
                  `).join('')}
                </div>
                <div class="poll-results">Total votes: ${Object.keys(poll.votes || {}).length}</div>
              </div>
            `;
            pollContainer.innerHTML += pollHtml;
          });
        }, async (error) => {
          console.error('Error fetching polls:', error);
          const cachedPolls = await getCachedData('polls', roomId);
          pollContainer.innerHTML = '<button class="btn primary" onclick="window.createPoll()">Create Poll</button>';
          if (Object.keys(cachedPolls).length === 0) {
            pollContainer.innerHTML += '<p>No polls available (offline).</p>';
          } else {
            Object.entries(cachedPolls).forEach(([pollId, poll]) => {
              const userVote = poll.votes[auth.currentUser?.uid];
              const voteCounts = poll.options.reduce((acc, opt) => {
                acc[opt.en] = Object.values(poll.votes || {}).filter(v => v === opt.en).length;
                return acc;
              }, {});
              const pollHtml = `
                <div class="poll-item">
                  <h3>${poll.question.en || 'No question'}</h3>
                  <div class="poll-options">
                    ${poll.options.map(opt => `
                      <div class="poll-option ${userVote === opt.en ? 'voted' : ''}">
                        ${opt.en} (${voteCounts[opt.en] || 0} votes)
                      </div>
                    `).join('')}
                  </div>
                  <div class="poll-results">Total votes: ${Object.keys(poll.votes || {}).length} (cached)</div>
                </div>
              `;
              pollContainer.innerHTML += pollHtml;
            });
          }
        });
      } catch (error) {
        console.error('Error rendering polls:', error);
        pollContainer.innerHTML = '<p>Error loading polls.</p>';
      }
    }

    window.votePoll = async function(roomId, pollId, option, answer) {
      try {
        const userId = auth.currentUser.uid;
        const pollRef = ref(db, `chatrooms/${roomId}/polls/${pollId}`);
        const pollSnapshot = await get(pollRef);
        const poll = pollSnapshot.val();
        const roomSnapshot = await get(ref(db, `chatrooms/${roomId}`));
        const room = roomSnapshot.val() || { language: 'en' };
        if (!poll) {
          window.showAlert('Poll not found.', false);
          return;
        }
        if (poll.votes[userId]) {
          window.showAlert('POLL_ALREADY_VOTED', false);
          return;
        }
        await set(ref(db, `chatrooms/${roomId}/polls/${pollId}/votes/${userId}`), option);
        window.showAlert('POLL_VOTED', true);
        if (poll.creatorId === 'system' && answer && option === answer) {
          await update(ref(db, `wallets/${userId}`), {
            balance: ((await get(ref(db, `wallets/${userId}`))).val()?.balance || 0) + 5
          });
          await push(ref(db, `wallets/${userId}/transactions`), {
            amount: 5,
            type: 'poll_reward',
            roomId,
            timestamp: Date.now()
          });
          await push(ref(db, `chatrooms/${roomId}/messages`), {
            content: CryptoJS.AES.encrypt('Correct answer! You earned 5 Vynix Coins.', ENCRYPTION_KEY).toString(),
            senderId: 'system',
            type: 'text',
            timestamp: Date.now(),
            read: true
          });
          const userPoints = (await get(ref(db, `chatrooms/${roomId}/leaderboards/${userId}`))).val()?.points || 0;
          await update(ref(db, `chatrooms/${roomId}/leaderboards/${userId}`), { points: userPoints + 5 });
        }
        console.log('Voted on poll:', pollId, option);
      } catch (error) {
        console.error('Error voting on poll:', error);
        window.showAlert('Failed to vote.', false);
      }
    };

    window.tipUser = async function(receiverId, roomId) {
      try {
        const roomSnapshot = await get(ref(db, `chatrooms/${roomId}`));
        const room = roomSnapshot.val() || { language: 'en' };
        const lang = room.language;
        const amount = await window.showAlert('TIP_PROMPT', false, true);
        if (amount && !isNaN(amount) && parseInt(amount) > 0) {
          const userId = auth.currentUser.uid;
          const senderWallet = (await get(ref(db, `wallets/${userId}`))).val() || { balance: 0 };
          if (senderWallet.balance < parseInt(amount)) {
            window.showAlert('TIP_INSUFFICIENT', false);
            return;
          }
          await update(ref(db, `wallets/${userId}`), { balance: senderWallet.balance - parseInt(amount) });
          await update(ref(db, `wallets/${receiverId}`), {
            balance: ((await get(ref(db, `wallets/${receiverId}`))).val()?.balance || 0) + parseInt(amount)
          });
          await push(ref(db, `wallets/${userId}/transactions`), {
            amount: -parseInt(amount),
            type: 'tip',
            to: receiverId,
            roomId,
            timestamp: Date.now()
          });
          await push(ref(db, `wallets/${receiverId}/transactions`), {
            amount: parseInt(amount),
            type: 'tip',
            from: userId,
            roomId,
            timestamp: Date.now()
          });
          const userPoints = (await get(ref(db, `chatrooms/${roomId}/leaderboards/${receiverId}`))).val()?.points || 0;
          await update(ref(db, `chatrooms/${roomId}/leaderboards/${receiverId}`), { points: userPoints + parseInt(amount) });
          window.showAlert('TIP_SUCCESS'.replace('{amount}', amount), true);
          console.log('Tipped:', amount, 'to', receiverId);
        } else {
          window.showAlert('Invalid tip amount.', false);
        }
      } catch (error) {
        console.error('Error tipping user:', error);
        window.showAlert('Failed to tip.', false);
      }
    };

    const WEEKLY_RESET = 7 * 24 * 60 * 60 * 1000; // 1 week
    async function awardMostActiveBadge(roomId) {
      try {
        const leaderboardRef = ref(db, `chatrooms/${roomId}/leaderboards`);
        const leaderboardSnapshot = await get(leaderboardRef);
        const leaderboard = leaderboardSnapshot.val() || {};
        const topUser = Object.entries(leaderboard)
          .sort((a, b) => b[1].points - a[1].points)[0];
        if (topUser && (!topUser[1].lastBadgeTime || Date.now() - topUser[1].lastBadgeTime > WEEKLY_RESET)) {
          await update(ref(db, `chatrooms/${roomId}/leaderboards/${topUser[0]}`), {
            badges: { "Most Active": true },
            lastBadgeTime: Date.now()
          });
          await push(ref(db, `chatrooms/${roomId}/messages`), {
            content: CryptoJS.AES.encrypt(`${topUser[0]} awarded Most Active badge!`, ENCRYPTION_KEY).toString(),
            senderId: 'system',
            type: 'text',
            timestamp: Date.now(),
            read: true
          });
          console.log('Awarded Most Active badge to:', topUser[0]);
        }
      } catch (error) {
        console.error('Error awarding badge:', error);
      }
    }

    function renderLeaderboard(roomId) {
      const leaderboardContainer = document.getElementById('leaderboard-container');
      try {
        onValue(ref(db, `chatrooms/${roomId}/leaderboards`), async (snapshot) => {
          const roomSnapshot = await get(ref(db, `chatrooms/${roomId}`));
          const room = roomSnapshot.val() || { language: 'en' };
          const lang = room.language;
          document.getElementById('leaderboard-title').textContent = LEADERBOARD_TITLES[lang];
          const leaderboard = snapshot.val() || {};
          console.log('Rendering leaderboard:', leaderboard);
          const usersRef = ref(db, 'users');
          const userSnapshot = await get(usersRef);
          const users = userSnapshot.val() || {};
          const leaderboardHtml = Object.entries(leaderboard)
            .sort((a, b) => b[1].points - a[1].points)
            .map(([userId, data]) => `
              <div class="leaderboard-item">
                <span>${users[userId]?.name || 'Unknown'}: ${data.points} points${data.streak ? ` (Streak: ${data.streak})` : ''}</span>
                ${data.badges ? Object.keys(data.badges).map(b => `<span class="badge">${b}</span>`).join('') : ''}
              </div>
            `).join('');
          leaderboardContainer.innerHTML = `
            <h3>${LEADERBOARD_TITLES[lang]}</h3>
            ${leaderboardHtml || 'No activity yet.'}
          `;
        }, async (error) => {
          console.error('Error fetching leaderboard:', error);
          leaderboardContainer.innerHTML = '<p>Error loading leaderboard.</p>';
        });
      } catch (error) {
        console.error('Error rendering leaderboard:', error);
        leaderboardContainer.innerHTML = '<p>Error loading leaderboard.</p>';
      }
    }

    window.setRoomLanguage = async function() {
      try {
        const roomId = new URLSearchParams(window.location.search).get('roomId');
        const roomSnapshot = await get(ref(db, `chatrooms/${roomId}`));
        const room = roomSnapshot.val();
        if (!room) {
          window.showAlert('ROOM_NOT_FOUND', false);
          return;
        }
        if (room.creatorId !== auth.currentUser.uid) {
          window.showAlert('Only the room creator can set the language.', false);
          return;
        }
        const language = await window.showAlert('Enter language (en, zu, xh, af):', false, true);
        if (['en', 'zu', 'xh', 'af'].includes(language)) {
          await update(ref(db, `chatrooms/${roomId}`), { language });
          window.showAlert('Room language updated!', true);
          console.log('Room language set to:', language);
        } else {
          window.showAlert('Invalid language. Use en, zu, xh, or af.', false);
        }
      } catch (error) {
        console.error('Error setting room language:', error);
        window.showAlert('Failed to set language.', false);
      }
    };

    async function loadRoom(userId, roomId) {
      try {
        showShimmer();
        console.log('Loading room:', roomId, 'for user:', userId);
        const roomRef = ref(db, `chatrooms/${roomId}`);
        const roomSnapshot = await get(roomRef);
        if (!roomSnapshot.exists()) {
          console.error('Room not found:', roomId);
          window.showAlert('ROOM_NOT_FOUND', false);
          messageList.innerHTML = '';
          window.location.href = ROUTES.INDEX;
          return;
        }
        const room = roomSnapshot.val();
        console.log('Room data:', room);

        if (!room.members || !room.members[userId]) {
          if (room.type === 'private') {
            const inviteCode = await window.showAlert('Enter invite code:', false, true);
            if (inviteCode) {
              if (room.inviteCode === inviteCode) {
                try {
                  await update(ref(db, `chatrooms/${roomId}/members`), { [userId]: true });
                  await set(ref(db, `users/${userId}/joinedRooms/${roomId}`), true);
                  window.showAlert('ROOM_JOIN_SUCCESS', true);
                } catch (error) {
                  console.error('Error joining room:', error);
                  window.showAlert('ROOM_JOIN_FAIL', false);
                  window.location.href = ROUTES.INDEX;
                  return;
                }
              } else {
                window.showAlert('INVALID_INVITE_CODE', false);
                window.location.href = ROUTES.INDEX;
                return;
              }
            } else {
              window.location.href = ROUTES.INDEX;
              return;
            }
          } else {
            try {
              await update(ref(db, `chatrooms/${roomId}/members`), { [userId]: true });
              await set(ref(db, `users/${userId}/joinedRooms/${roomId}`), true);
              window.showAlert('ROOM_JOIN_SUCCESS', true);
            } catch (error) {
              console.error('Error joining room:', error);
              window.showAlert('ROOM_JOIN_FAIL', false);
              window.location.href = ROUTES.INDEX;
              return;
            }
          }
        }

        roomAvatar.innerHTML = room.name?.charAt(0) || '?';
        roomName.textContent = room.name || 'Unnamed Room';
        roomMembers.textContent = `${Object.keys(room.members || {}).length} members`;

        const messagesRef = ref(db, `chatrooms/${roomId}/messages`);
        onValue(messagesRef, async (snapshot, { limitToLast: 50 }) => {
          messageList.innerHTML = '';
          if (!snapshot.exists()) {
            messageList.innerHTML = '<p style="text-align: center; padding: 1rem;">No messages yet.</p>';
            console.log('No messages in room:', roomId);
            await cacheData('messages', roomId, {});
            return;
          }
          const messages = snapshot.val();
          console.log('Messages loaded:', messages);
          await cacheData('messages', roomId, messages);
          const usersRef = ref(db, 'users');
          const userSnapshot = await get(usersRef);
          const users = userSnapshot.val() || {};
          let latestTimestamp = 0;
          Object.entries(messages).slice(-50).forEach(([messageId, message]) => {
            if (message.timestamp > lastMessageTimestamp && message.senderId !== userId) {
              if ('vibrate' in navigator) {
                navigator.vibrate(200);
              }
            }
            if (message.timestamp > latestTimestamp) {
              latestTimestamp = message.timestamp;
            }
            const sender = users[message.senderId] || { name: message.senderId.startsWith('system') ? 'System' : 'Unknown' };
            const messageItem = document.createElement('div');
            messageItem.className = `message ${message.senderId === userId ? 'sent' : 'received'} ${message.type !== 'text' ? 'media' : ''}`;
            let content;
            if (message.type === 'text') {
              content = decryptMessage(message.content);
              messageItem.innerHTML = `
                ${message.senderId !== userId ? `<div class="message-sender">${sender.name}</div>` : ''}
                <div>${content}</div>
                <div class="message-time">${formatTimestamp(message.timestamp)}</div>
                ${message.senderId !== userId && !message.senderId.startsWith('system') ? `<button class="tip-btn" onclick="tipUser('${message.senderId}', '${roomId}')">Tip Vynix Coins</button>` : ''}
              `;
            } else if (message.type === 'image') {
              content = decryptMessage(message.content);
              messageItem.innerHTML = `
                ${message.senderId !== userId ? `<div class="message-sender">${sender.name}</div>` : ''}
                <img src="${content}" alt="Shared image" loading="lazy" />
                <div class="message-time">${formatTimestamp(message.timestamp)}</div>
                ${message.senderId !== userId && !message.senderId.startsWith('system') ? `<button class="tip-btn" onclick="tipUser('${message.senderId}', '${roomId}')">Tip Vynix Coins</button>` : ''}
              `;
            } else if (message.type === 'video') {
              content = decryptMessage(message.content);
              messageItem.innerHTML = `
                ${message.senderId !== userId ? `<div class="message-sender">${sender.name}</div>` : ''}
                <video src="${content}" controls></video>
                <div class="message-time">${formatTimestamp(message.timestamp)}</div>
                ${message.senderId !== userId && !message.senderId.startsWith('system') ? `<button class="tip-btn" onclick="tipUser('${
                  ${message.senderId}', '${roomId}')">Tip Vynix Coins</button>` : ''}
              `;
            } else if (message.type === 'voice') {
              content = decryptMessage(message.content);
              messageItem.innerHTML = `
                ${message.senderId !== userId ? `<div class="message-sender">${sender.name}</div>` : ''}
                <audio src="${content}" controls></audio>
                <div class="message-time">${formatTimestamp(message.timestamp)}</div>
                ${message.senderId !== userId && !message.senderId.startsWith('system') ? `<button class="tip-btn" onclick="tipUser('${message.senderId}', '${roomId}')">Tip Vynix Coins</button>` : ''}
              `;
            }
            messageList.appendChild(messageItem);
          });
          lastMessageTimestamp = latestTimestamp;
          messageList.scrollTop = messageList.scrollHeight;
          if (!room.lastTriviaTime || Date.now() - room.lastTriviaTime > TRIVIA_INTERVAL) {
            await createAutoTrivia(roomId);
          }
        }, async (error) => {
          console.error('Error fetching messages:', error);
          const cachedMessages = await getCachedData('messages', roomId);
          messageList.innerHTML = '';
          if (Object.keys(cachedMessages).length === 0) {
            messageList.innerHTML = '<p style="text-align: center; padding: 1rem;">No messages available (offline).</p>';
          } else {
            const usersRef = ref(db, 'users');
            const userSnapshot = await get(usersRef);
            const users = userSnapshot.val() || {};
            Object.entries(cachedMessages).forEach(([messageId, message]) => {
              const sender = users[message.senderId] || { name: message.senderId.startsWith('system') ? 'System' : 'Unknown' };
              const messageItem = document.createElement('div');
              messageItem.className = `message ${message.senderId === userId ? 'sent' : 'received'} ${message.type !== 'text' ? 'media' : ''}`;
              let content;
              if (message.type === 'text') {
                content = decryptMessage(message.content);
                messageItem.innerHTML = `
                  ${message.senderId !== userId ? `<div class="message-sender">${sender.name}</div>` : ''}
                  <div>${content}</div>
                  <div class="message-time">${formatTimestamp(message.timestamp)}</div>
                `;
              } else if (message.type === 'image') {
                content = decryptMessage(message.content);
                messageItem.innerHTML = `
                  ${message.senderId !== userId ? `<div class="message-sender">${sender.name}</div>` : ''}
                  <img src="${content}" alt="Shared image" loading="lazy" />
                  <div class="message-time">${formatTimestamp(message.timestamp)}</div>
                `;
              } else if (message.type === 'video') {
                content = decryptMessage(message.content);
                messageItem.innerHTML = `
                  ${message.senderId !== userId ? `<div class="message-sender">${sender.name}</div>` : ''}
                  <video src="${content}" controls></video>
                  <div class="message-time">${formatTimestamp(message.timestamp)}</div>
                `;
              } else if (message.type === 'voice') {
                content = decryptMessage(message.content);
                messageItem.innerHTML = `
                  ${message.senderId !== userId ? `<div class="message-sender">${sender.name}</div>` : ''}
                  <audio src="${content}" controls></audio>
                  <div class="message-time">${formatTimestamp(message.timestamp)}</div>
                `;
              }
              messageList.appendChild(messageItem);
            });
            messageList.scrollTop = messageList.scrollHeight;
          }
        });

        renderTrivia(roomId);
        renderPolls(roomId);
        renderLeaderboard(roomId);
        awardMostActiveBadge(roomId);
      } catch (error) {
        console.error('Error loading room:', error);
        window.showAlert('LOAD_ERROR', false);
        messageList.innerHTML = '';
        window.location.href = ROUTES.INDEX;
      }
    }

    async function sendMessage(userId, roomId, content, type = 'text') {
      try {
        const encryptedContent = CryptoJS.AES.encrypt(content, ENCRYPTION_KEY).toString();
        const messageData = {
          senderId: userId,
          content: encryptedContent,
          type,
          timestamp: Date.now(),
          read: true
        };
        await push(ref(db, `chatrooms/${roomId}/messages`), messageData);
        const userPoints = (await get(ref(db, `chatrooms/${roomId}/leaderboards/${userId}`))).val()?.points || 0;
        await update(ref(db, `chatrooms/${roomId}/leaderboards/${userId}`), { points: userPoints + 1 });
        messageInput.value = '';
        console.log('Message sent:', content, type);
      } catch (error) {
        console.error('Error sending message:', error);
        window.showAlert('MESSAGE_SEND_FAIL', false);
      }
    }

    function setupEventListeners() {
      messageInput.addEventListener('keypress', async (e) => {
        if (e.key === 'Enter' && messageInput.value.trim()) {
          const userId = auth.currentUser?.uid;
          const roomId = new URLSearchParams(window.location.search).get('roomId');
          if (userId && roomId) {
            await sendMessage(userId, roomId, messageInput.value.trim());
          }
        }
      });

      fab.addEventListener('click', async () => {
        const userId = auth.currentUser?.uid;
        const roomId = new URLSearchParams(window.location.search).get('roomId');
        if (userId && roomId && messageInput.value.trim()) {
          await sendMessage(userId, roomId, messageInput.value.trim());
        }
      });

      document.getElementById('attachment-btn').addEventListener('click', () => {
        document.getElementById('media-upload').click();
      });

      document.getElementById('media-upload').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
          const media = await uploadMedia(file);
          if (media) {
            const userId = auth.currentUser?.uid;
            const roomId = new URLSearchParams(window.location.search).get('roomId');
            if (userId && roomId) {
              await sendMessage(userId, roomId, media.url, media.type);
            }
          }
        }
      });

      document.getElementById('mic-btn').addEventListener('click', () => {
        startRecording();
      });
    }

    onAuthStateChanged(auth, (user) => {
      if (!user) {
        window.showAlert('SIGN_IN_REQUIRED', false);
        window.location.href = ROUTES.INDEX;
        return;
      }
      const roomId = new URLSearchParams(window.location.search).get('roomId');
      if (!roomId) {
        window.showAlert('ROOM_NOT_FOUND', false);
        window.location.href = ROUTES.INDEX;
        return;
      }
      loadRoom(user.uid, roomId);
      setupEventListeners();
    });

    window.addEventListener('offline', () => {
      window.showAlert('You are offline. Some features may be limited.', false);
    });

    window.addEventListener('online', async () => {
      const userId = auth.currentUser?.uid;
      const roomId = new URLSearchParams(window.location.search).get('roomId');
      if (userId && roomId) {
        await loadRoom(userId, roomId);
      }
      window.showAlert('You are back online!', true);
    });
  </script>
</body>
</html>
