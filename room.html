<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <meta name="theme-color" content="#ff2a6d">
  <title>Room • Vynix</title>

  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    :root{--accent:#ff2a6d;--bg:#ffffff;--text:#0f1419;--text2:#536471;--border:#eff3f4}
    [data-theme="dark"]{--bg:#000000;--text:#e7e9ea;--text2:#71767b;--border:#2f3336}
    body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;background:var(--bg);color:var(--text);-webkit-user-select:none;user-select:none;padding-bottom:80px;overflow:hidden}
    #messages{height:calc(100vh - 140px);overflow-y:auto;padding:12px 0}
    .msg{display:flex;margin:6px 12px;opacity:0;transform:translateY(10px);animation:msgIn .35s forwards}
    @keyframes msgIn{to{opacity:1;transform:none}}
    .mine{justify-content:flex-end}
    .mine .bubble{background:var(--accent);color:#fff}
    .bubble{max-width:72%;padding:11px 15px;border-radius:18px;font-size:15px;background:var(--border);color:var(--text);word-break:break-word;position:relative}
    .bubble::after{content:'';position:absolute;bottom:4px;right:8px;width:20px;height:12px;background:inherit;clip-path:polygon(0 0,100% 0,100% 100%);}
    .mine .bubble::after{left:8px;right:auto;transform:scaleX(-1)}
    .msgMeta{font-size:11px;color:var(--text2);margin-top:4px;display:flex;align-items:center;gap:6px;padding-left:12px;padding-right:12px}
    .mine .msgMeta{justify-content:flex-end}
    .read{color:#10B981 !important;font-weight:600}
    .composer{position:fixed;bottom:0;left:0;right:0;height:60px;border-top:1px solid var(--border);background:var(--bg);display:flex;align-items:center;padding:0 12px;gap:8px}
    .composer input{flex:1;background:var(--border);border:none;border-radius:9999px;padding:11px 16px;font-size:16px;outline:none;color:var(--text)}
    .composer button{background:var(--accent);color:#fff;border:none;border-radius:50%;width:44px;height:44px;display:grid;place-items:center;cursor:pointer;transition:transform .15s}
    .composer button:active{transform:scale(0.92)}

    /* Custom Alert */
    #alertOverlay{position:fixed;inset:0;background:rgba(0,0,0,0.7);backdrop-filter:blur(10px);z-index:50;display:none;align-items:center;justify-content:center}
    .alertBox{background:var(--bg);border:1px solid var(--border);border-radius:20px;padding:28px;max-width:90%;text-align:center;box-shadow:0 25px 50px rgba(0,0,0,0.3)}
    .alertTitle{font-weight:700;font-size:19px;margin-bottom:12px}
    .verifyCode{font-family:monospace;font-size:24px;letter-spacing:5px;margin:20px 0;padding:14px;background:#0001;border-radius:10px}
    .alertBtn{background:var(--accent);color:white;padding:14px 32px;border-radius:999px;margin-top:16px;font-weight:600;font-size:15px}

    /* Shimmer */
    .shimmer{background:#f6f7f8;background:linear-gradient(90deg,#f0f0f0 25%,#f8f8f8 50%,#f0f0f0 75%);background-size:200% 100%;animation:shimmer 1.5s infinite}
    @keyframes shimmer{0%{background-position:200% 0}100%{background-position:-200% 0}}
    [data-theme="dark"] .shimmer{background:linear-gradient(90deg,#1a1a1a 25%,#222 50%,#1a1a1a 75%)}
    .empty{text-align:center;padding:60px 20px;color:var(--text2)}
  </style>
</head>
<body>

<header class="sticky top-0 bg-[var(--bg)] px-4 py-3 border-b border-[var(--border)] flex items-center gap-3 z-10">
  <span id="back" class="material-icons cursor-pointer">arrow_back</span>
  <img id="hdrAva" class="w-10 h-10 rounded-full object-cover shimmer" src="">
  <div class="flex-1">
    <div id="hdrName" class="font-bold shimmer">Loading…</div>
    <div id="connStatus" class="text-xs text-orange-500">Establishing secure connection…</div>
  </div>
</header>

<div id="messages">
  <div class="empty">Send a message — it's end-to-end encrypted!</div>
</div>

<div class="composer">
  <input id="input" type="text" placeholder="Message…" autocomplete="off">
  <button id="send"><span class="material-icons">send</span></button>
</div>

<!-- Verification Alert -->
<div id="alertOverlay">
  <div class="alertBox">
    <div class="alertTitle">Verify Encryption</div>
    <div>Compare this code with your friend to confirm you're really talking to each other.</div>
    <div id="verifyCodeDisplay" class="verifyCode">•••• •••• •••• •••• •••• ••••</div>
    <button class="alertBtn" onclick="document.getElementById('alertOverlay').style.display='none'">Got it</button>
  </div>
</div>

<script type="module">
import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js';
import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js';
import { getDatabase, ref, onChildAdded, push, set, serverTimestamp, get, onValue, remove } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js';

const firebaseConfig = {
  apiKey: "AIzaSyBOyZ3As4GTuNvjemvPF_SpsC6m6vqtNhc",
  authDomain: "fire-b-a8878.firebaseapp.com",
  databaseURL: "https://fire-b-a8878.firebaseio.com",
  projectId: "fire-b-a8878",
  storageBucket: "fire-b-a8878.firebasestorage.app",
  messagingSenderId: "658673187627",
  appId: "1:658673187627:web:6e4c29af661785f0afa36e"
};

const app  = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db   = getDatabase(app);

let myUid, roomId, otherUid, sharedSecret = null, verificationCode = null;
const messageQueue = [];

/* UI */
const listEl = document.getElementById('messages');
const input  = document.getElementById('input');
const sendBtn= document.getElementById('send');
const connStatusEl = document.getElementById('connStatus');
const verifyDisplay = document.getElementById('verifyCodeDisplay');

/* Init */
onAuthStateChanged(auth, user => {
  if (!user) { location.href = 'login.html'; return; }
  myUid = user.uid;
  parseHash();
  loadHeader();
  startKeyExchange();
  loadMessages();
});

document.getElementById('back').onclick = () => history.back();

function parseHash() {
  const [r, o] = location.hash.slice(1).split('|');
  roomId = r; otherUid = o;
  if (!roomId || !otherUid) { alert('Invalid link'); history.back(); }
}

async function loadHeader() {
  const snap = await get(ref(db, `users/${otherUid}`));
  const u = snap.val() || {};
  const name = u.displayName || 'User';
  const avatar = u.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&background=ff2a6d&color=fff`;

  // Fixed typo here: HdrName → hdrName
  document.getElementById('hdrName').textContent = name;
  document.getElementById('hdrName').classList.remove('shimmer');
  document.getElementById('hdrAva').src = avatar;
  document.getElementById('hdrAva').classList.remove('shimmer');
}

/* Key Exchange + Verification */
async function startKeyExchange() {
  const myKeyPair = await crypto.subtle.generateKey({ name: 'ECDH', namedCurve: 'P-256' }, false, ['deriveKey']);
  const myPubRaw = await crypto.subtle.exportKey('raw', myKeyPair.publicKey);

  await set(ref(db, `roomKeys/\( {roomId}/public/ \){myUid}`), {
    raw: Array.from(new Uint8Array(myPubRaw)),
    ts: serverTimestamp()
  });

  const pubRef = ref(db, `roomKeys/${roomId}/public`);
  onValue(pubRef, async (snap) => {
    const keys = snap.val() || {};
    const myKey = keys[myUid]?.raw;
    const otherKey = keys[otherUid]?.raw;
    if (!myKey || !otherKey || sharedSecret) return;

    const otherPub = await crypto.subtle.importKey('raw', new Uint8Array(otherKey), { name: 'ECDH', namedCurve: 'P-256' }, false, []);
    sharedSecret = await crypto.subtle.deriveKey(
      { name: 'ECDH', public: otherPub },
      myKeyPair.privateKey,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt', 'decrypt']
    );

    const pubA = myUid < otherUid ? new Uint8Array(myKey) : new Uint8Array(otherKey);
    const pubB = myUid < otherUid ? new Uint8Array(otherKey) : new Uint8Array(myKey);
    const concat = new Uint8Array(pubA.length + pubB.length);
    concat.set(pubA, 0); concat.set(pubB, pubA.length);
    const hash = await crypto.subtle.digest('SHA-256', concat);
    const hex = Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2,'0')).join('').toUpperCase();
    verificationCode = hex.match(/.{4}/g).join(' ');

    connStatusEl.textContent = 'End-to-end encrypted';
    connStatusEl.style.color = '#10B981';
    document.querySelector('.empty')?.remove();
    processMessageQueue();

    if (!localStorage.getItem(`verified_${roomId}`)) {
      verifyDisplay.textContent = verificationCode;
      document.getElementById('alertOverlay').style.display = 'flex';
      localStorage.setItem(`verified_${roomId}`, 'true');
    }

    setTimeout(() => remove(ref(db, `roomKeys/${roomId}/public`)), 5*60*1000);
  });
}

/* Encrypt / Decrypt */
async function encrypt(text) {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const data = new TextEncoder().encode(text);
  const ct = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, sharedSecret, data);
  return { iv: Array.from(iv), ct: Array.from(new Uint8Array(ct)) };
}

async function decrypt(ivArr, ctArr) {
  try {
    const iv = new Uint8Array(ivArr);
    const ct = new Uint8Array(ctArr);
    const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, sharedSecret, ct);
    return new TextDecoder().decode(pt);
  } catch { return '[Undecryptable]'; }
}

/* Time formatting */
function formatTime(ts) {
  if (!ts) return '';
  const d = ts.toDate ? ts.toDate() : new Date(ts);
  const now = new Date();
  const isToday = d.toDateString() === now.toDateString();
  if (isToday) {
    return d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
  }
  return d.toLocaleDateString([], {month:'short', day:'numeric'});
}

/* Send Message */
sendBtn.onclick = async () => {
  const text = input.value.trim();
  if (!text || !sharedSecret) return;
  input.value = '';

  const payload = await encrypt(text);
  const msgRef = push(ref(db, `messages/${roomId}`));
  const msgKey = msgRef.key;

  await set(msgRef, {
    from: myUid,
    iv: payload.iv,
    ct: payload.ct,
    ts: serverTimestamp(),
    read: false
  });

  await set(ref(db, `lastMessage/${roomId}`), {
    text, time: Date.now(), unread: otherUid
  });

  appendBubble(text, true, 'Sending…', msgKey);
};

/* Receive & Display Messages */
function loadMessages() {
  onChildAdded(ref(db, `messages/${roomId}`), async (snap) => {
    const m = snap.val();
    const key = snap.key;
    if (m.from === myUid) {
      const time = m.ts ? formatTime(m.ts) : 'Pending';
      const status = m.read ? 'read' : 'sent';
      updateMessageStatus(key, time, status);
      return;
    }

    if (!sharedSecret) { messageQueue.push({key, data: m}); return; }

    const text = await decrypt(m.iv, m.ct);
    const time = m.ts ? formatTime(m.ts) : '';
    appendBubble(text, false, time, key);

    if (!m.read) {
      await set(ref(db, `messages/\( {roomId}/ \){key}/read`), true);
      await set(ref(db, `lastMessage/${roomId}/unread`), false);
    }
  });
}

function processMessageQueue() {
  messageQueue.forEach(async ({key, data}) => {
    const text = await decrypt(data.iv, data.ct);
    const time = data.ts ? formatTime(data.ts) : '';
    appendBubble(text, false, time, key);
    if (!data.read) {
      set(ref(db, `messages/\( {roomId}/ \){key}/read`), true);
      set(ref(db, `lastMessage/${roomId}/unread`), false);
    }
  });
  messageQueue.length = 0;
}

function appendBubble(text, mine, timeText, msgKey) {
  const div = document.createElement('div');
  div.className = `msg ${mine ? 'mine' : ''}`;
  div.dataset.key = msgKey || '';
  div.innerHTML = `
    <div class="bubble">${esc(text)}</div>
    <div class="msgMeta">
      <span class="time">${timeText}</span>
      ${mine ? '<span class="status">sent</span>' : ''}
    </div>
  `;
  listEl.appendChild(div);
  listEl.scrollTop = listEl.scrollHeight;
}

function updateMessageStatus(key, time, status) {
  const msgEl = listEl.querySelector(`[data-key="${key}"]`);
  if (!msgEl) return;
  const timeEl = msgEl.querySelector('.time');
  const statusEl = msgEl.querySelector('.status');
  if (timeEl) timeEl.textContent = time;
  if (statusEl) {
    statusEl.textContent = status;
    if (status === 'read') statusEl.classList.add('read');
  }
}

function esc(str) {
  const el = document.createElement('div');
  el.textContent = str;
  return el.innerHTML;
}

/* Dark Mode */
if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
  document.documentElement.setAttribute('data-theme', 'dark');
}
</script>
</body>
</html>
