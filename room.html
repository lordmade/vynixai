<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <meta name="theme-color" content="#ff2a6d">
  <title>Room • Vynix</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root{--accent:#ff2a6d;--bg:#ffffff;--text:#0f1419;--text2:#536471;--border:#eff3f4}
    [data-theme="dark"]{--bg:#000000;--text:#e7e9ea;--text2:#71767b;--border:#2f3336}
    body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;background:var(--bg);color:var(--text);-webkit-user-select:none;user-select:none;padding-bottom:80px}
    #messages{height:calc(100vh - 140px);overflow-y:auto;padding:12px}
    .msg{display:flex;margin:4px 0}
    .mine{justify-content:flex-end}
    .mine .bubble{background:var(--accent);color:#fff}
    .bubble{max-width:70%;padding:10px 14px;border-radius:18px;font-size:15px;background:var(--border);color:var(--text)}
    .composer{position:fixed;bottom:0;left:0;right:0;height:60px;border-top:1px solid var(--border);background:var(--bg);display:flex;align-items:center;padding:0 12px;gap:8px}
    .composer input{flex:1;background:var(--border);border:none;border-radius:999px;padding:10px 16px;font-size:16px;outline:none;color:var(--text)}
    .composer button{background:var(--accent);color:#fff;border:none;border-radius:50%;width:44px;height:44px;display:grid;place-items:center}
    .empty{text-align:center;padding:60px 20px;color:var(--text2)}
  </style>
</head>
<body>

<header class="sticky top-0 bg-[var(--bg)] px-4 py-3 border-b border-[var(--border)] flex items-center gap-3 z-10">
  <span id="back" class="material-icons cursor-pointer">arrow_back</span>
  <img id="hdrAva" class="w-10 h-10 rounded-full object-cover">
  <div class="flex-1">
    <div id="hdrName" class="font-bold"></div>
    <div class="text-xs text-gray-500">Encrypted</div>
  </div>
</header>

<div id="messages">
  <div class="empty">Send the first encrypted message!</div>
</div>

<div class="composer">
  <input id="input" type="text" placeholder="Encrypted message…" autocomplete="off">
  <button id="send"><span class="material-icons">send</span></button>
</div>

<script type="module">
import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js';
import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js';
import { getDatabase, ref, onChildAdded, push, set, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js';

const firebaseConfig = {
  apiKey: "AIzaSyBOyZ3As4GTuNvjemvPF_SpsC6m6vqtNhc",
  authDomain: "fire-b-a8878.firebaseapp.com",
  databaseURL: "https://fire-b-a8878.firebaseio.com",
  projectId: "fire-b-a8878",
  storageBucket: "fire-b-a8878.firebasestorage.app",
  messagingSenderId: "658673187627",
  appId: "1:658673187627:web:6e4c29af661785f0afa36e"
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getDatabase(app);

let myUid, myName, myAvatar, roomId, otherUid, otherName, otherAvatar;
let ecdhKeys, sharedSecret; // for E2E

/* ---------- init ---------- */
onAuthStateChanged(auth, user => {
  if (!user) return;
  myUid = user.uid;
  myName = user.displayName || 'User';
  myAvatar = user.photoURL || `https://ui-avatars.com/api/?name=${myName}&background=ff2a6d&color=fff`;
  parseHash();
  initCrypto();
  loadMessages();
});

function parseHash() {
  const [r, o] = location.hash.slice(1).split('|');
  roomId = r; otherUid = o;
  if (!roomId || !otherUid) { alert('Missing room'); history.back(); }
  // header
  get(ref(db, `users/${otherUid}`)).then(s => {
    const u = s.val() || {};
    otherName = u.displayName || 'User';
    otherAvatar = u.photoURL || `https://ui-avatars.com/api/?name=${otherName}&background=ff2a6d&color=fff`;
    document.getElementById('hdrName').textContent = otherName;
    document.getElementById('hdrAva').src = otherAvatar;
  });
}

document.getElementById('back').onclick = () => history.back();

/* ---------- WebCrypto ECDH ---------- */
async function initCrypto() {
  // generate ECDH keypair
  const myKeyPair = await crypto.subtle.generateKey({ name: 'ECDH', namedCurve: 'P-256' }, false, ['deriveKey']);
  const myPublicJwk = await crypto.subtle.exportKey('jwk', myKeyPair.publicKey);
  const myPublicRaw = await crypto.subtle.exportKey('raw', myKeyPair.publicKey);

  // share / fetch other public key
  const pubRef = ref(db, `roomKeys/${roomId}/public`);
  onValue(pubRef, async snap => {
    const map = snap.val() || {};
    if (!map[myUid]) {
      // publish our public key
      await set(ref(db, `roomKeys/${roomId}/public/${myUid}`), { jwk: myPublicJwk, ts: serverTimestamp() });
    }
    const other = map[otherUid];
    if (!other) return; // wait for other
    const otherPub = await crypto.subtle.importKey('jwk', other.jwk, { name: 'ECDH', namedCurve: 'P-256' }, false, []);
    // derive shared AES key
    sharedSecret = await crypto.subtle.deriveKey(
      { name: 'ECDH', public: otherPub },
      myKeyPair.privateKey,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt', 'decrypt']
    );
    listEl.innerHTML = ''; // ready
  });
}

/* ---------- encrypt / decrypt ---------- */
const ivLen = 12;
async function encrypt(text) {
  const enc = new TextEncoder();
  const iv = crypto.getRandomValues(new Uint8Array(ivLen));
  const ct = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, sharedSecret, enc.encode(text));
  return { iv: Array.from(iv), ct: Array.from(new Uint8Array(ct)) };
}
async function decrypt(ivArr, ctArr) {
  const iv = new Uint8Array(ivArr);
  const ct = new Uint8Array(ctArr);
  const dec = new TextDecoder();
  const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, sharedSecret, ct);
  return dec.decode(pt);
}

/* ---------- send ---------- */
send.onclick = async () => {
  const plain = input.value.trim();
  if (!plain || !sharedSecret) return;
  input.value = '';
  const { iv, ct } = await encrypt(plain);
  await push(ref(db, `messages/${roomId}`), {
    from: myUid,
    iv, ct,
    ts: serverTimestamp()
  });
  // update last message for list
  await set(ref(db, `lastMessage/${roomId}`), { text: plain, time: Date.now(), unread: true });
};

/* ---------- load & decrypt ---------- */
function loadMessages() {
  onChildAdded(ref(db, `messages/${roomId}`), async ss => {
    const m = ss.val();
    if (m.from === myUid) {
      appendBubble(m, true);
    } else {
      appendBubble(m, false);
      // mark room read
      await set(ref(db, `lastMessage/${roomId}/unread`), false);
    }
  });
}

async function appendBubble(m, mine) {
  const plain = await decrypt(m.iv, m.ct);
  const side = mine ? 'mine' : 'other';
  const html = `<div class="msg ${side}"><div class="bubble">${esc(plain)}</div></div>`;
  listEl.insertAdjacentHTML('beforeend', html);
  listEl.scrollTop = listEl.scrollHeight;
}

/* ---------- utils ---------- */
function esc(str) {
  return str.replace(/[&<>"']/g, m => ({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));
}

/* theme */
if (matchMedia('(prefers-color-scheme: dark)').matches) document.documentElement.setAttribute('data-theme', 'dark');
</script>

</body>
</html>
