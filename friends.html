<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-touch-fullscreen" content="yes">
  <title>Chat - GrokChat</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js"></script>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Chirp:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #000000;
      --card-bg: #16181c;
      --text-primary: #ffffff;
      --text-secondary: #71767b;
      --border: #2f3336;
      --accent: #1d9bf0;
      --x-blue: #1d9bf0;
      --header-bg: #000000;
      --chat-bubble-sent: #1d9bf0;
      --chat-bubble-received: #16181c;
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.4);
      --glow: 0 0 10px rgba(29, 155, 240, 0.5);
    }
    body.light {
      --bg: #ffffff;
      --card-bg: #f7f9fa;
      --text-primary: #0f1419;
      --text-secondary: #536471;
      --border: #e1e8ed;
      --header-bg: #ffffff;
      --chat-bubble-sent: #1d9bf0;
      --chat-bubble-received: #f7f9fa;
    }
    body {
      font-family: 'Chirp', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      background: var(--bg);
      color: var(--text-primary);
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      line-height: 1.4;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    * {
      -webkit-touch-callout: none !important;
    }
    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: var(--header-bg);
      z-index: 100;
      padding: 12px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 64px;
      box-shadow: var(--shadow-sm);
      transition: background-color 0.3s ease;
    }
    body.light .header {
      background: var(--header-bg);
    }
    .header-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .back-btn {
      background: none;
      border: none;
      color: var(--text-primary);
      font-size: 24px;
      cursor: pointer;
      padding: 8px;
      border-radius: 50%;
      transition: background 0.2s ease;
    }
    .back-btn:hover {
      background: rgba(29, 155, 240, 0.1);
    }
    .header-center {
      flex: 1;
      text-align: center;
      font-weight: 800;
      font-size: 20px;
    }
    .main-content {
      padding: 84px 20px 140px;
      min-height: calc(100vh - 160px);
      display: flex;
      flex-direction: column;
      transition: padding 0.3s ease;
    }
    .messages-container {
      flex: 1;
      overflow-y: auto;
      padding-bottom: 20px;
    }
    .message {
      display: flex;
      margin-bottom: 16px;
      max-width: 100%;
    }
    .message.sent {
      justify-content: flex-end;
    }
    .message.received {
      justify-content: flex-start;
    }
    .bubble {
      max-width: 70%;
      padding: 12px 16px;
      border-radius: 18px;
      word-wrap: break-word;
    }
    .message.sent .bubble {
      background: var(--chat-bubble-sent);
      color: #000000;
    }
    .message.received .bubble {
      background: var(--chat-bubble-received);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }
    .input-container {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 20px;
      background: var(--header-bg);
      border-top: 1px solid var(--border);
      display: flex;
      gap: 12px;
      align-items: flex-end;
      z-index: 50;
    }
    .message-input {
      flex: 1;
      padding: 12px 16px;
      border: 1px solid var(--border);
      border-radius: 20px;
      background: var(--card-bg);
      color: var(--text-primary);
      font-size: 16px;
      resize: none;
      min-height: 48px;
      max-height: 120px;
      outline: none;
      transition: border-color 0.2s ease;
    }
    .message-input:focus {
      border-color: var(--x-blue);
    }
    .send-btn {
      background: var(--x-blue);
      color: #000000;
      border: none;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .send-btn:hover {
      box-shadow: var(--glow);
      transform: scale(1.05);
    }
    .typing-indicator {
      display: none;
      padding: 12px 0;
      color: var(--text-secondary);
      font-size: 15px;
      align-items: center;
      gap: 8px;
    }
    .typing-indicator.active {
      display: flex;
    }
    .dots {
      display: flex;
      gap: 4px;
    }
    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-secondary);
      animation: bounce 1.4s ease-in-out infinite both;
    }
    .dot:nth-child(2) {
      animation-delay: 0.2s;
    }
    .dot:nth-child(3) {
      animation-delay: 0.4s;
    }
    @keyframes bounce {
      0%, 80%, 100% { transform: scale(0); }
      40% { transform: scale(1); }
    }
    .spinner-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
      transition: opacity 0.3s ease;
    }
    .spinner-overlay.active {
      display: flex;
    }
    .spinner {
      display: flex;
      gap: 12px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .dot-spinner {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--x-blue);
      animation: bounce 1.4s ease-in-out infinite both;
    }
    .dot-spinner:nth-child(1) { animation-delay: -0.32s; }
    .dot-spinner:nth-child(2) { animation-delay: -0.16s; }
    .alert {
      position: fixed;
      top: 84px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--x-blue);
      color: #000000;
      padding: 16px 28px;
      border-radius: 20px;
      display: none;
      z-index: 1000;
      box-shadow: var(--shadow-md), var(--glow);
      font-weight: 700;
      font-size: 15px;
      animation: slideDown 0.3s ease;
    }
    @keyframes slideDown {
      from { transform: translateX(-50%) translateY(-100%); opacity: 0; }
      to { transform: translateX(-50%) translateY(0); opacity: 1; }
    }
    .alert.active {
      display: block;
    }
    @media (min-width: 768px) {
      .main-content {
        padding: 84px 60px 140px;
      }
      .input-container {
        padding: 20px 60px;
      }
    }
    @media (prefers-color-scheme: light) {
      :root {
        --bg: #ffffff;
        --card-bg: #f7f9fa;
        --text-primary: #0f1419;
        --text-secondary: #536471;
        --border: #e1e8ed;
        --header-bg: #ffffff;
      }
      body {
        background: var(--bg);
      }
      .header {
        background: var(--header-bg);
      }
    }
  </style>
</head>
<body class="dark">
  <div class="spinner-overlay" id="spinner-overlay">
    <div class="spinner">
      <div class="dot-spinner"></div>
      <div class="dot-spinner"></div>
      <div class="dot-spinner"></div>
    </div>
  </div>
  <header class="header">
    <div class="header-left">
      <button class="back-btn material-icons" onclick="window.location.href='friends.html'" aria-label="Back">arrow_back</button>
      <div class="header-center">
        <h1 id="chat-title">Chat</h1>
      </div>
    </div>
  </header>
  <main class="main-content">
    <div class="messages-container" id="messages"></div>
    <div id="typing-indicator" class="typing-indicator">
      <span id="typing-user-name">User</span> is typing
      <div class="dots">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
    </div>
  </main>
  <div class="input-container">
    <textarea id="message-input" class="message-input" placeholder="Type a message..." rows="1"></textarea>
    <button id="send-btn" class="send-btn material-icons" disabled>send</button>
  </div>
  <div id="alert-message" class="alert" role="alert" aria-live="polite"></div>
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js';
    import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js';
    import { getDatabase, ref, get, onValue, set, push, update } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js';

    const firebaseConfig = {
      apiKey: "AIzaSyBOyZ3As4GTuNvjemvPF_SpsC6m6vqtNhc",
      authDomain: "fire-b-a8878.firebaseapp.com",
      databaseURL: "https://fire-b-a8878.firebaseio.com",
      projectId: "fire-b-a8878",
      storageBucket: "fire-b-a8878.firebasestorage.app",
      messagingSenderId: "658673187627",
      appId: "1:658673187627:web:6e4c29af661785f0afa36e",
      measurementId: "G-V4W97VMSKL"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getDatabase(app);

    let currentUser;
    const urlParams = new URLSearchParams(window.location.search);
    const chatId = urlParams.get('chatId');
    const otherUserId = urlParams.get('userId');

    if (!chatId || !otherUserId) {
      window.location.href = 'friends.html';
    }

    const verifiedIcon = `<span class="material-icons verified-icon">verified</span>`;

    const showSpinner = () => {
      document.getElementById('spinner-overlay').classList.add('active');
    };

    const hideSpinner = () => {
      document.getElementById('spinner-overlay').classList.remove('active');
    };

    const showAlert = (message) => {
      const alert = document.getElementById('alert-message');
      if (alert) {
        alert.textContent = message;
        alert.classList.add('active');
        setTimeout(() => alert.classList.remove('active'), 4000);
      }
    };

    async function decryptMessage(encryptedStr, chatId) {
      try {
        const { iv, ciphertext } = JSON.parse(encryptedStr);
        const ivBytes = Uint8Array.from(atob(iv), c => c.charCodeAt(0));
        const ciphertextBytes = Uint8Array.from(atob(ciphertext), c => c.charCodeAt(0));
        const encoder = new TextEncoder();
        const keyMaterial = await crypto.subtle.importKey(
          "raw",
          encoder.encode("grochat-secret-key-2025"),
          { name: "PBKDF2" },
          false,
          ["deriveBits", "deriveKey"]
        );
        const salt = encoder.encode(chatId);
        const key = await crypto.subtle.deriveKey(
          {
            name: "PBKDF2",
            salt: salt,
            iterations: 100000,
            hash: "SHA-256"
          },
          keyMaterial,
          { name: "AES-GCM", length: 256 },
          true,
          ["decrypt"]
        );
        const decrypted = await crypto.subtle.decrypt(
          { name: "AES-GCM", iv: ivBytes },
          key,
          ciphertextBytes
        );
        const decoder = new TextDecoder();
        return decoder.decode(decrypted);
      } catch (error) {
        console.error('Decryption failed:', error);
        return '[Unable to display]';
      }
    }

    async function encryptMessage(message, chatId) {
      try {
        const encoder = new TextEncoder();
        const keyMaterial = await crypto.subtle.importKey(
          "raw",
          encoder.encode("grochat-secret-key-2025"),
          { name: "PBKDF2" },
          false,
          ["deriveBits", "deriveKey"]
        );
        const salt = encoder.encode(chatId);
        const key = await crypto.subtle.deriveKey(
          {
            name: "PBKDF2",
            salt: salt,
            iterations: 100000,
            hash: "SHA-256"
          },
          keyMaterial,
          { name: "AES-GCM", length: 256 },
          true,
          ["encrypt"]
        );
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const data = encoder.encode(message);
        const encrypted = await crypto.subtle.encrypt(
          { name: "AES-GCM", iv: iv },
          key,
          data
        );
        const ivB64 = btoa(String.fromCharCode(...iv));
        const ciphertextB64 = btoa(String.fromCharCode(...new Uint8Array(encrypted)));
        return JSON.stringify({ iv: ivB64, ciphertext: ciphertextB64 });
      } catch (error) {
        console.error('Encryption failed:', error);
        throw error;
      }
    }

    function createMessageElement(msg, decryptedText, isSent) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;
      messageDiv.innerHTML = `
        <div class="bubble">${decryptedText}</div>
      `;
      return messageDiv;
    }

    async function loadChat() {
      showSpinner();
      const messagesContainer = document.getElementById('messages');
      const messagesRef = ref(db, `chats/${chatId}/messages`);
      onValue(messagesRef, async (snap) => {
        messagesContainer.innerHTML = '';
        const data = snap.val();
        if (data) {
          const messagesArray = Object.values(data).sort((a, b) => a.timestamp - b.timestamp);
          for (const msg of messagesArray) {
            const decrypted = await decryptMessage(msg.message, chatId);
            const isSent = msg.senderId === currentUser.uid;
            const messageEl = createMessageElement(msg, decrypted, isSent);
            messagesContainer.appendChild(messageEl);
          }
        }
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      });

      // Reset unread count
      const currentChatRef = ref(db, `users/${currentUser.uid}/chats/${otherUserId}`);
      update(currentChatRef, { unreadCount: 0 });

      // Load other user info
      const otherUserRef = ref(db, `users/${otherUserId}`);
      onValue(otherUserRef, (snap) => {
        const user = snap.val();
        if (user) {
          document.getElementById('chat-title').textContent = user.displayName || user.email || 'User';
          document.getElementById('typing-user-name').textContent = user.displayName || user.email || 'User';
        }
      });

      // Typing listener for other user
      const otherTypingRef = ref(db, `chats/${chatId}/typing/${otherUserId}`);
      onValue(otherTypingRef, (snap) => {
        const typingEl = document.getElementById('typing-indicator');
        typingEl.classList.toggle('active', snap.val() === true);
      });

      hideSpinner();
    }

    let typingTimeout;
    function handleTyping(isTyping) {
      const typingRef = ref(db, `chats/${chatId}/typing/${currentUser.uid}`);
      set(typingRef, isTyping);
      if (isTyping) {
        clearTimeout(typingTimeout);
        typingTimeout = setTimeout(() => handleTyping(false), 2000);
      }
    }

    onAuthStateChanged(auth, async (user) => {
      currentUser = user;
      if (user) {
        // Set online status if needed
        const userStatusRef = ref(db, `users/${user.uid}/online`);
        set(userStatusRef, true);

        await loadChat();

        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');

        messageInput.addEventListener('input', () => {
          const text = messageInput.value.trim();
          sendBtn.disabled = !text;
          if (text) {
            handleTyping(true);
          } else {
            handleTyping(false);
          }
        });

        sendBtn.addEventListener('click', async () => {
          const text = messageInput.value.trim();
          if (text) {
            const encrypted = await encryptMessage(text, chatId);
            const messagesRef = ref(db, `chats/${chatId}/messages`);
            const newMsgRef = push(messagesRef);
            await set(newMsgRef, {
              senderId: currentUser.uid,
              message: encrypted,
              type: 'text',
              timestamp: Date.now()
            });

            // Update last message for current user
            const currentChatRef = ref(db, `users/${currentUser.uid}/chats/${otherUserId}`);
            const currentChatSnap = await get(currentChatRef);
            const currentChatData = currentChatSnap.val() || {};
            await set(currentChatRef, {
              ...currentChatData,
              chatId,
              otherUserId,
              lastMessage: encrypted,
              lastMessageType: 'text',
              lastMessageTime: Date.now(),
              unreadCount: 0
            });

            // Update last message for other user (increment unread if online or something, but for now set)
            const otherChatRef = ref(db, `users/${otherUserId}/chats/${currentUser.uid}`);
            const otherChatSnap = await get(otherChatRef);
            const otherChatData = otherChatSnap.val() || {};
            const newUnread = (otherChatData.unreadCount || 0) + 1;
            await set(otherChatRef, {
              ...otherChatData,
              chatId,
              otherUserId: currentUser.uid,
              lastMessage: encrypted,
              lastMessageType: 'text',
              lastMessageTime: Date.now(),
              unreadCount: newUnread
            });

            messageInput.value = '';
            sendBtn.disabled = true;
            handleTyping(false);
          }
        });

        messageInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendBtn.click();
          }
        });
      } else {
        window.location.href = 'login.html';
      }
    });
  </script>
</body>
</html>
