<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-touch-fullscreen" content="yes">
  <title>Friends - Vynix Chats</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js"></script>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Chirp:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #000000;
      --card-bg: #16181c;
      --text-primary: #ffffff;
      --text-secondary: #71767b;
      --border: #2f3336;
      --accent: #1d9bf0;
      --x-blue: #1d9bf0;
      --header-bg: #000000;
      --chat-bubble-sent: #1d9bf0;
      --chat-bubble-received: #16181c;
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.4);
      --glow: 0 0 10px rgba(29, 155, 240, 0.5);
    }
    body.light {
      --bg: #ffffff;
      --card-bg: #f7f9fa;
      --text-primary: #0f1419;
      --text-secondary: #536471;
      --border: #e1e8ed;
      --header-bg: #ffffff;
      --chat-bubble-sent: #1d9bf0;
      --chat-bubble-received: #f7f9fa;
    }
    body {
      font-family: 'Chirp', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      background: var(--bg);
      color: var(--text-primary);
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      line-height: 1.4;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    * {
      -webkit-touch-callout: none !important;
    }
    #app-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 84px;
      background: var(--header-bg);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      z-index: 10;
      transition: transform 0.3s ease;
      transform: translateY(0);
      border-bottom: 1px solid var(--border);
    }
    #app-header.hidden {
      transform: translateY(-100%);
    }
    #app-header h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 900;
      color: var(--x-blue);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
      letter-spacing: -0.5px;
    }
    .sub-tabs {
      position: fixed;
      top: 84px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      gap: 8px;
      padding: 12px 20px;
      background: var(--header-bg);
      border-bottom: 1px solid var(--border);
      z-index: 9;
    }
    .tab-btn {
      display: flex;
      align-items: center;
      flex: none;
      padding: 12px 24px;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      font-weight: 600;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s ease;
      border-radius: 9999px;
      white-space: nowrap;
    }
    .tab-btn .material-icons {
      font-size: 16px;
      line-height: 1;
      vertical-align: -2px;
      margin-right: 8px;
    }
    .tab-btn.active {
      background: var(--x-blue);
      color: white;
      border-color: var(--x-blue);
    }
    .main-content {
      padding: 164px 20px 100px;
      min-height: calc(100vh - 160px);
      transition: padding 0.3s ease;
    }
    .tab-section {
      opacity: 0;
      transition: opacity 0.3s ease;
      display: none;
    }
    .tab-section.active {
      display: block;
      opacity: 1;
    }
    .search-container {
      margin-bottom: 20px;
    }
    .filter-container {
      margin-bottom: 20px;
    }
    .search-input {
      width: 100%;
      padding: 12px 16px;
      border: 1px solid var(--border);
      border-radius: 20px;
      background: var(--card-bg);
      color: var(--text-primary);
      font-size: 16px;
      box-sizing: border-box;
      transition: border-color 0.2s ease;
    }
    .search-input:focus {
      outline: none;
      border-color: var(--x-blue);
    }
    .category-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 12px;
      margin-bottom: 20px;
    }
    .category-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 12px 8px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      color: var(--text-secondary);
      font-size: 12px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 600;
    }
    .category-btn .material-icons {
      font-size: 24px;
      margin-bottom: 4px;
    }
    .category-btn.active {
      background: var(--x-blue);
      color: white;
      border-color: var(--x-blue);
    }
    .category-filter {
      display: flex;
      overflow-x: auto;
      gap: 8px;
      padding: 8px 0;
      margin-bottom: 20px;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    .category-filter::-webkit-scrollbar {
      display: none;
    }
    .filter-btn {
      display: flex;
      align-items: center;
      padding: 8px 16px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 20px;
      color: var(--text-secondary);
      font-size: 14px;
      white-space: nowrap;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .filter-btn .material-icons {
      font-size: 18px;
      margin-right: 6px;
    }
    .filter-btn.active {
      background: var(--x-blue);
      color: white;
      border-color: var(--x-blue);
    }
    .user-card, .channel-card {
      display: flex;
      align-items: flex-start;
      gap: 20px;
      padding: 20px;
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 20px;
      cursor: pointer;
      margin-bottom: 16px;
      box-shadow: var(--shadow-sm);
      transition: all 0.3s ease;
    }
    .user-card:hover, .channel-card:hover {
      border-color: var(--x-blue);
      box-shadow: var(--glow);
      transform: translateY(-1px);
    }
    .avatar-wrapper {
      position: relative;
      flex-shrink: 0;
    }
    .user-avatar, .channel-avatar {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      object-fit: cover;
      background: var(--x-blue);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #000000;
      font-weight: bold;
      box-shadow: var(--shadow-sm);
      cursor: pointer;
    }
    .channel-avatar {
      object-fit: cover;
    }
    .channel-avatar[src] {
      display: block;
    }
    .header-profile-pic {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--x-blue);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #000000;
      font-weight: bold;
      font-size: 18px;
      cursor: pointer;
      box-shadow: var(--shadow-sm);
      transition: box-shadow 0.2s ease;
    }
    .header-profile-pic:hover {
      box-shadow: var(--glow);
    }
    .header-profile-pic img {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      object-fit: cover;
    }
    .online-indicator {
      position: absolute;
      bottom: 2px;
      right: 2px;
      width: 12px;
      height: 12px;
      background: #4ade80;
      border-radius: 50%;
      border: 2px solid var(--bg);
      display: none;
    }
    body.light .online-indicator {
      border-color: #ffffff;
    }
    .user-info, .channel-info {
      flex: 1;
      min-width: 0;
    }
    .user-name, .channel-name {
      font-weight: 800;
      font-size: 17px;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      margin-bottom: 4px;
      flex-wrap: wrap;
    }
    .category-badge {
      display: flex;
      align-items: center;
      background: #6b7280;
      color: white;
      padding: 4px 8px;
      border-radius: 10px;
      font-size: 12px;
      font-weight: 600;
      margin-left: 8px;
      white-space: nowrap;
    }
    .category-badge .material-icons {
      font-size: 14px;
      margin-right: 4px;
    }
    .channel-desc {
      color: var(--text-secondary);
      font-size: 14px;
      margin-bottom: 4px;
    }
    .channel-meta {
      display: flex;
      gap: 8px;
      align-items: center;
      color: var(--text-secondary);
      font-size: 12px;
      margin-bottom: 4px;
    }
    .last-preview {
      color: var(--text-secondary);
      font-size: 15px;
      margin-top: 4px;
      max-width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .last-time {
      color: var(--text-secondary);
      font-size: 12px;
      opacity: 0.7;
      margin-top: 2px;
    }
    .verified-icon {
      font-size: 20px;
      color: #1d9bf0;
      margin-left: 4px;
    }
    .unread-badge {
      background: #f91880;
      color: white;
      border-radius: 12px;
      padding: 2px 6px;
      font-size: 12px;
      font-weight: bold;
      min-width: 18px;
      text-align: center;
      margin-left: 8px;
    }
    .follow-btn {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 14px;
      margin-left: auto;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }
    .follow-btn.following {
      background: var(--x-blue);
      border-color: var(--x-blue);
      color: white;
    }
    .follow-btn:hover {
      background: rgba(29, 155, 240, 0.1);
    }
    .follow-btn.following:hover {
      background: #0c7bb8;
    }
    .context-btn {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 20px;
      cursor: pointer;
      padding: 0 10px;
      margin-left: auto;
      display: flex;
      align-items: flex-start;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    .user-card:hover .context-btn, .channel-card:hover .context-btn {
      opacity: 1;
    }
    .fab {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 56px;
      height: 56px;
      background: var(--x-blue);
      border: none;
      border-radius: 50%;
      color: white;
      font-size: 24px;
      cursor: pointer;
      box-shadow: var(--shadow-md);
      z-index: 20;
      transition: display 0.3s ease;
    }
    .fab:hover {
      box-shadow: var(--glow);
    }
    .bottom-sheet {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 0;
      background: var(--card-bg);
      border-top-left-radius: 20px;
      border-top-right-radius: 20px;
      overflow: hidden;
      transition: height 0.3s ease;
      z-index: 100;
      display: none;
    }
    .bottom-sheet.active {
      display: block;
      height: 80vh;
    }
    .bottom-sheet-header {
      padding: 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .bottom-sheet-title {
      font-size: 18px;
      font-weight: 700;
      color: var(--text-primary);
      margin: 0;
    }
    .bottom-sheet-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 24px;
      cursor: pointer;
    }
    .bottom-sheet-content {
      padding: 20px;
      overflow-y: auto;
      height: calc(80vh - 80px);
    }
    .input-group {
      margin-bottom: 20px;
    }
    .input-group label {
      display: block;
      margin-bottom: 8px;
      color: var(--text-secondary);
      font-size: 14px;
    }
    .input-group input {
      width: 100%;
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--bg);
      color: var(--text-primary);
      font-size: 16px;
      box-sizing: border-box;
    }
    .input-group input[type="file"] {
      padding: 8px;
    }
    .btn {
      width: 100%;
      padding: 12px;
      background: var(--x-blue);
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      margin-bottom: 10px;
      transition: background 0.2s ease;
    }
    .btn:hover {
      background: #0c7bb8;
    }
    .btn:disabled {
      background: var(--text-secondary);
      cursor: not-allowed;
    }
    .btn-secondary {
      background: var(--bg);
      color: var(--text-primary);
      border: 1px solid var(--border);
      width: auto;
      padding: 6px 12px;
      margin-left: auto;
    }
    .spinner-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 64px;
      background: var(--header-bg);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
      border-bottom: 1px solid var(--border);
      transition: opacity 0.3s ease;
    }
    .spinner-overlay.active {
      display: flex;
    }
    .spinner {
      display: flex;
      gap: 12px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .dot {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--x-blue);
      animation: bounce 1.4s ease-in-out infinite both;
    }
    .dot:nth-child(1) { animation-delay: -0.32s; }
    .dot:nth-child(2) { animation-delay: -0.16s; }
    @keyframes bounce {
      0%, 80%, 100% { transform: scale(0); }
      40% { transform: scale(1); }
    }
    .alert {
      position: fixed;
      top: 84px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--x-blue);
      color: #000000;
      padding: 16px 28px;
      border-radius: 20px;
      display: none;
      z-index: 1000;
      box-shadow: var(--shadow-md), var(--glow);
      font-weight: 700;
      font-size: 15px;
      animation: slideDown 0.3s ease;
    }
    @keyframes slideDown {
      from { transform: translateX(-50%) translateY(-100%); opacity: 0; }
      to { transform: translateX(-50%) translateY(0); opacity: 1; }
    }
    .alert.active {
      display: block;
    }
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.3s ease;
    }
    .modal.active {
      display: flex;
    }
    .modal-content {
      position: relative;
      background: var(--card-bg);
      border-radius: 20px;
      padding: 40px 20px 20px;
      text-align: center;
      max-width: 300px;
      width: 90%;
      border: 1px solid var(--border);
    }
    .context-option {
      padding: 16px;
      cursor: pointer;
      border-bottom: 1px solid var(--border);
      font-size: 16px;
      color: var(--text-primary);
      transition: background-color 0.2s;
      text-align: left;
    }
    .context-option:hover {
      background: rgba(29, 155, 240, 0.1);
    }
    .context-option:last-child {
      border-bottom: none;
    }
    .profile-img {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      object-fit: cover;
      margin: 0 auto 16px;
      display: block;
      box-shadow: var(--shadow-md);
    }
    .profile-avatar {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: var(--x-blue);
      color: #000000;
      font-size: 48px;
      font-weight: bold;
      display: none;
      align-items: center;
      justify-content: center;
      margin: 0 auto 16px;
      box-shadow: var(--shadow-md);
    }
    .profile-name {
      font-size: 20px;
      font-weight: 800;
      color: var(--text-primary);
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }
    .close-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      font-size: 24px;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background-color 0.2s ease;
    }
    .close-btn:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    @media (min-width: 768px) {
      .main-content {
        padding: 164px 60px 0;
      }
    }
    @media (prefers-color-scheme: light) {
      :root {
        --bg: #ffffff;
        --card-bg: #f7f9fa;
        --text-primary: #0f1419;
        --text-secondary: #536471;
        --border: #e1e8ed;
        --header-bg: #ffffff;
      }
      body {
        background: var(--bg);
      }
      #app-header h1 {
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      }
    }
  </style>
</head>
<body class="dark">
  <div class="spinner-overlay" id="spinner-overlay">
    <div class="spinner">
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
    </div>
  </div>
  <header id="app-header">
    <h1>Vynix Chats</h1>
    <div id="user-profile-pic" class="header-profile-pic"></div>
  </header>
  <div class="sub-tabs">
    <button class="tab-btn active" data-tab="chats"><span class="material-icons">chat</span>Chats</button>
    <button class="tab-btn" data-tab="channels"><span class="material-icons">dynamic_feed</span>Channels</button>
  </div>
  <main class="main-content">
    <div id="chats-section" class="tab-section active">
      <div class="search-container">
        <input type="text" id="search-input" placeholder="Search friends..." class="search-input">
      </div>
      <div id="users-list">
        <!-- Users loaded here -->
      </div>
    </div>
    <div id="channels-section" class="tab-section">
      <div class="search-container">
        <input type="text" id="channel-search-input" placeholder="Search channels..." class="search-input">
      </div>
      <div class="filter-container">
        <div class="category-filter" id="category-filter">
          <button class="filter-btn active" data-category="">
            <span class="material-icons">all_inclusive</span>All
          </button>
          <button class="filter-btn" data-category="general">
            <span class="material-icons">public</span>General
          </button>
          <button class="filter-btn" data-category="tech">
            <span class="material-icons">developer_mode</span>Tech
          </button>
          <button class="filter-btn" data-category="sports">
            <span class="material-icons">sports_soccer</span>Sports
          </button>
          <button class="filter-btn" data-category="music">
            <span class="material-icons">music_note</span>Music
          </button>
          <button class="filter-btn" data-category="news">
            <span class="material-icons">article</span>News
          </button>
        </div>
      </div>
      <div id="channels-list">
        <!-- Channels loaded here -->
      </div>
    </div>
  </main>
  <button id="create-channel-fab" class="fab">+</button>
  <!-- Bottom Sheets -->
  <div id="create-channel-sheet" class="bottom-sheet" onclick="handleBottomSheetClick(event)">
    <div class="bottom-sheet-header">
      <h3 class="bottom-sheet-title">Create Channel</h3>
      <button class="bottom-sheet-close" onclick="closeBottomSheet(event)">&times;</button>
    </div>
    <div class="bottom-sheet-content">
      <div class="input-group">
        <label for="channel-pic">Profile Image (optional)</label>
        <input id="channel-pic" type="file" accept="image/*">
        <div id="channel-pic-progress" class="hidden" style="width: 100%; height: 8px; background: var(--border); border-radius: 4px; overflow: hidden; margin: 16px 0;">
          <div id="channel-pic-progress-bar" style="height: 100%; background: var(--x-blue); width: 0%; transition: width 0.3s ease;"></div>
        </div>
      </div>
      <div class="input-group">
        <label for="channel-name">Channel Name</label>
        <input id="channel-name" type="text" placeholder="Enter channel name">
      </div>
      <div class="input-group">
        <label for="channel-desc">Description</label>
        <input id="channel-desc" type="text" placeholder="Enter brief description (optional)">
      </div>
      <div class="input-group">
        <label>Category</label>
        <div class="category-grid" id="channel-category-grid">
          <button class="category-btn active" data-category="general">
            <span class="material-icons">public</span>
            General
          </button>
          <button class="category-btn" data-category="tech">
            <span class="material-icons">developer_mode</span>
            Tech
          </button>
          <button class="category-btn" data-category="sports">
            <span class="material-icons">sports_soccer</span>
            Sports
          </button>
          <button class="category-btn" data-category="music">
            <span class="material-icons">music_note</span>
            Music
          </button>
          <button class="category-btn" data-category="news">
            <span class="material-icons">article</span>
            News
          </button>
        </div>
      </div>
      <button id="create-channel-btn" class="btn" onclick="createChannel(event)">Create Channel</button>
    </div>
  </div>
  <div id="profile-modal" class="modal">
    <div class="modal-content">
      <button class="close-btn" onclick="closeModal()">&times;</button>
      <img id="modal-profile-img" class="profile-img" alt="Profile" style="display: none;">
      <div id="modal-profile-avatar" class="profile-avatar"></div>
      <div id="modal-username" class="profile-name"></div>
    </div>
  </div>
  <div id="context-menu" class="modal">
    <div class="modal-content" style="max-width: 280px; padding: 20px; text-align: left;">
      <div class="context-option" data-action="delete">Delete Friend's Chats</div>
      <div class="context-option" data-action="block">Block Friend</div>
      <div class="context-option" data-action="pin">Pin to Top</div>
    </div>
  </div>
  <div id="channel-context-menu" class="modal">
    <div class="modal-content" style="max-width: 280px; padding: 20px; text-align: left;">
      <div class="context-option channel-context-option" data-action="pin">Pin Chat</div>
    </div>
  </div>
  <div id="alert-message" class="alert" role="alert" aria-live="polite"></div>
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js';
    import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js';
    import { getDatabase, ref, get, onValue, set, push, update, remove, onDisconnect, query, orderByChild, equalTo } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js';

    const firebaseConfig = {
      apiKey: "AIzaSyBOyZ3As4GTuNvjemvPF_SpsC6m6vqtNhc",
      authDomain: "fire-b-a8878.firebaseapp.com",
      databaseURL: "https://fire-b-a8878.firebaseio.com",
      projectId: "fire-b-a8878",
      storageBucket: "fire-b-a8878.firebasestorage.app",
      messagingSenderId: "658673187627",
      appId: "1:658673187627:web:6e4c29af661785f0afa36e",
      measurementId: "G-V4W97VMSKL"
    };

    const cloudinaryConfig = {
      cloudName: 'dqkujefxj',
      uploadPreset: 'banter_box'
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getDatabase(app);

    let currentUser;
    let currentUserFollows = {};
    let currentUserBlocked = {};
    let outsideClickHandler;

    const verifiedIcon = `<span class="material-icons verified-icon">verified</span>`;

    const showSpinner = () => {
      document.getElementById('spinner-overlay').classList.add('active');
    };

    const hideSpinner = () => {
      document.getElementById('spinner-overlay').classList.remove('active');
    };

    const showAlert = (message) => {
      const alert = document.getElementById('alert-message');
      if (alert) {
        alert.textContent = message;
        alert.classList.add('active');
        setTimeout(() => alert.classList.remove('active'), 4000);
      }
    };

    let currentUid;
    let currentChannelId;

    function handleBottomSheetClick(event) {
      if (event.target.classList.contains('bottom-sheet')) {
        closeBottomSheet();
      }
    }

    function closeBottomSheet(event) {
      if (event) event.stopPropagation();
      document.querySelectorAll('.bottom-sheet').forEach(sheet => sheet.classList.remove('active'));
      if (outsideClickHandler) {
        document.removeEventListener('click', outsideClickHandler, true);
        outsideClickHandler = null;
      }
    }

    function showBottomSheet(sheetId) {
      closeBottomSheet();
      setTimeout(() => {
        const sheet = document.getElementById(sheetId);
        sheet.classList.add('active');
        outsideClickHandler = (event) => {
          if (!event.target.closest('.bottom-sheet.active')) {
            closeBottomSheet();
          }
        };
        document.addEventListener('click', outsideClickHandler, true);
      }, 10);
    }

    function hideContextMenu() {
      document.getElementById('context-menu').classList.remove('active');
      document.getElementById('channel-context-menu').classList.remove('active');
    }

    function showContextMenu(uid) {
      currentUid = uid;
      document.getElementById('context-menu').classList.add('active');
    }

    async function showChannelContextMenu(channelId, channel) {
      currentChannelId = channelId;
      const pinnedRef = ref(db, `users/${currentUser.uid}/pinnedChannels/${channelId}`);
      const pinnedSnap = await get(pinnedRef);
      const pinOption = document.querySelector('#channel-context-menu .context-option[data-action="pin"]');
      if (pinnedSnap.exists()) {
        pinOption.textContent = 'Unpin Chat';
        pinOption.dataset.action = 'unpin';
      } else {
        pinOption.textContent = 'Pin Chat';
        pinOption.dataset.action = 'pin';
      }
      document.getElementById('channel-context-menu').classList.add('active');
    }

    function formatTime(timestamp) {
      const now = Date.now();
      const diff = now - timestamp;
      if (diff < 60000) return 'Just now';
      if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
      if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
      return new Date(timestamp).toLocaleDateString();
    }

    async function decryptMessage(encryptedStr, chatId) {
      try {
        const { iv, ciphertext } = JSON.parse(encryptedStr);
        const ivBytes = Uint8Array.from(atob(iv), c => c.charCodeAt(0));
        const ciphertextBytes = Uint8Array.from(atob(ciphertext), c => c.charCodeAt(0));
        const encoder = new TextEncoder();
        const keyMaterial = await crypto.subtle.importKey(
          "raw",
          encoder.encode("grochat-secret-key-2025"),
          { name: "PBKDF2" },
          false,
          ["deriveBits", "deriveKey"]
        );
        const salt = encoder.encode(chatId);
        const key = await crypto.subtle.deriveKey(
          {
            name: "PBKDF2",
            salt: salt,
            iterations: 100000,
            hash: "SHA-256"
          },
          keyMaterial,
          { name: "AES-GCM", length: 256 },
          true,
          ["decrypt"]
        );
        const decrypted = await crypto.subtle.decrypt(
          { name: "AES-GCM", iv: ivBytes },
          key,
          ciphertextBytes
        );
        const decoder = new TextDecoder();
        return decoder.decode(decrypted);
      } catch (error) {
        console.error('Decryption failed:', error);
        return '[Unable to display]';
      }
    }

    async function loadFollows() {
      if (!currentUser) return;
      const followsRef = ref(db, `users/${currentUser.uid}/following`);
      const snap = await get(followsRef);
      currentUserFollows = snap.val() || {};
    }

    async function loadBlocked() {
      if (!currentUser) return;
      const blockedRef = ref(db, `users/${currentUser.uid}/blocked`);
      const snap = await get(blockedRef);
      currentUserBlocked = snap.val() || {};
    }

    function openModal(user) {
      const modal = document.getElementById('profile-modal');
      const imgEl = document.getElementById('modal-profile-img');
      const avatarEl = document.getElementById('modal-profile-avatar');
      const nameEl = document.getElementById('modal-username');

      const displayName = user?.displayName || user?.email || 'User';
      const initial = displayName[0].toUpperCase();

      nameEl.innerHTML = displayName;
      if (user?.verified) {
        nameEl.innerHTML += verifiedIcon;
      }

      if (user?.photoURL) {
        imgEl.src = user.photoURL;
        imgEl.style.display = 'block';
        avatarEl.style.display = 'none';
      } else {
        avatarEl.textContent = initial;
        avatarEl.style.display = 'flex';
        imgEl.style.display = 'none';
      }

      modal.classList.add('active');
      modal.onclick = (e) => {
        if (e.target === modal) {
          closeModal();
        }
      };
    }

    function closeModal() {
      const modal = document.getElementById('profile-modal');
      modal.classList.remove('active');
    }

    async function deleteChats(uid) {
      try {
        await remove(ref(db, `users/${currentUser.uid}/chats/${uid}`));
        showAlert("Friend's chats deleted.");
        await loadAllUsers();
      } catch (error) {
        console.error('Error deleting chats:', error);
        showAlert('Failed to delete chats.');
      }
    }

    async function blockFriend(uid) {
      try {
        await set(ref(db, `users/${currentUser.uid}/blocked/${uid}`), true);
        await remove(ref(db, `users/${currentUser.uid}/following/${uid}`));
        showAlert('Friend blocked.');
        await loadAllUsers();
      } catch (error) {
        console.error('Error blocking friend:', error);
        showAlert('Failed to block friend.');
      }
    }

    async function pinFriend(uid) {
      try {
        const chatRef = ref(db, `users/${currentUser.uid}/chats/${uid}`);
        const snap = await get(chatRef);
        let chatData = snap.val() || {
          chatId: [currentUser.uid, uid].sort().join('_'),
          otherUserId: uid,
          lastMessageTime: 0,
          unreadCount: 0
        };
        chatData.pinned = Date.now();
        await set(chatRef, chatData);
        showAlert('Friend pinned to top.');
        await loadAllUsers();
      } catch (error) {
        console.error('Error pinning friend:', error);
        showAlert('Failed to pin friend.');
      }
    }

    async function loadAllUsers() {
      showSpinner();
      const usersList = document.getElementById('users-list');
      usersList.innerHTML = '';
      if (currentUser) {
        let followedUsers = [];
        if (Object.keys(currentUserFollows || {}).length > 0) {
          const followedUids = Object.keys(currentUserFollows).filter(uid => !currentUserBlocked[uid]);
          const userPromises = followedUids.map(uid => get(ref(db, `users/${uid}`)).then(snap => ({ uid, user: snap.val() })));
          const userResults = await Promise.allSettled(userPromises);
          followedUsers = userResults.filter(r => r.status === 'fulfilled').map(r => r.value);
        }
        if (followedUsers.length === 0) {
          usersList.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 60px; font-size: 17px;">No friends yet. Follow some to message!</p>';
        } else {
          const chatPromises = followedUsers.map(async ({ uid, user }) => {
            const chatRef = ref(db, `users/${currentUser.uid}/chats/${uid}`);
            const chatSnap = await get(chatRef);
            const chat = chatSnap.val() || {};
            let lastMsg = user.bio || 'Start a chat';
            let lastTime = 0;
            let sortTime = 0;
            const tempChatId = [currentUser.uid, uid].sort().join('_');
            if (chat.lastMessage) {
              lastMsg = await decryptMessage(chat.lastMessage, chat.chatId || tempChatId);
              lastTime = chat.lastMessageTime || 0;
            }
            if (chat.pinned) {
              sortTime = chat.pinned;
            } else {
              sortTime = lastTime;
            }
            return { uid, user, lastMsg, lastTime, sortTime };
          });
          let enrichedUsers = await Promise.all(chatPromises);
          enrichedUsers.sort((a, b) => b.sortTime - a.sortTime);
          for (const { user, uid, lastMsg, lastTime } of enrichedUsers) {
            const initial = user?.displayName ? user.displayName[0].toUpperCase() : 'U';
            let avatarHtml;
            if (user?.photoURL) {
              avatarHtml = `<img src="${user.photoURL}" alt="${user?.displayName || 'User'} avatar" class="user-avatar" loading="lazy">`;
            } else {
              avatarHtml = `<div class="user-avatar" style="background: var(--x-blue); color: #000000; font-size: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold;">${initial}</div>`;
            }
            let nameHtml = user?.displayName || user?.email || 'User';
            if (user?.verified) {
              nameHtml += verifiedIcon;
            }
            const avatarWrapper = `
              <div class="avatar-wrapper">
                ${avatarHtml}
                <div class="online-indicator" id="status-${uid}"></div>
              </div>
            `;
            const userCard = document.createElement('div');
            userCard.className = 'user-card';
            userCard.onclick = () => startChat(uid, user);
            userCard.innerHTML = `
              ${avatarWrapper}
              <div class="user-info">
                <div class="user-name">${nameHtml} <span class="unread-badge" id="unread-${uid}" style="display:none;"></span></div>
                <div class="last-preview" id="preview-${uid}">${lastMsg}</div>
                ${lastTime ? `<div class="last-time" id="time-${uid}">${formatTime(lastTime)}</div>` : ''}
              </div>
              <button class="context-btn" data-uid="${uid}">⋮</button>
            `;
            usersList.appendChild(userCard);

            const contextBtn = userCard.querySelector('.context-btn');
            contextBtn.onclick = (e) => {
              e.stopPropagation();
              showContextMenu(uid);
            };

            const avatar = userCard.querySelector('.user-avatar');
            avatar.onclick = (e) => {
              e.stopPropagation();
              openModal(user);
            };

            // Online status listener
            const statusRef = ref(db, `userStatuses/${uid}`);
            onValue(statusRef, (snap) => {
              const indicator = document.getElementById(`status-${uid}`);
              if (indicator) {
                indicator.style.display = snap.val() === true ? 'block' : 'none';
              }
            });

            const chatRef = ref(db, `users/${currentUser.uid}/chats/${uid}`);
            onValue(chatRef, async (snap) => {
              if (snap.exists()) {
                const chat = snap.val();
                const previewEl = document.getElementById(`preview-${uid}`);
                const timeEl = document.getElementById(`time-${uid}`);
                if (previewEl) {
                  previewEl.textContent = await decryptMessage(chat.lastMessage, chat.chatId);
                }
                if (timeEl) {
                  timeEl.textContent = formatTime(chat.lastMessageTime);
                } else if (chat.lastMessageTime) {
                  const newTimeEl = document.createElement('div');
                  newTimeEl.className = 'last-time';
                  newTimeEl.id = `time-${uid}`;
                  newTimeEl.textContent = formatTime(chat.lastMessageTime);
                  previewEl.parentNode.appendChild(newTimeEl);
                }
              }
            });

            const unreadRef = ref(db, `users/${currentUser.uid}/chats/${uid}/unreadCount`);
            onValue(unreadRef, (snap) => {
              const count = snap.val() || 0;
              const el = document.getElementById(`unread-${uid}`);
              if (el) {
                if (count > 0) {
                  el.textContent = count > 99 ? '99+' : count;
                  el.style.display = 'inline';
                } else {
                  el.style.display = 'none';
                }
              }
            });
          }
        }
      }
      hideSpinner();
    }

    let allChannelsData = [];

    async function loadChannels() {
      showSpinner();
      const channelsList = document.getElementById('channels-list');
      channelsList.innerHTML = '';
      try {
        if (currentUser) {
          const channelsRef = ref(db, 'channels');
          const snap = await get(channelsRef);
          const allChannels = snap.val() || {};
          if (Object.keys(allChannels).length === 0) {
            channelsList.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 60px; font-size: 17px;">No channels yet. Create one!</p>';
          } else {
            const channelPromises = Object.entries(allChannels).map(async ([channelId, channel]) => {
              const pinnedRef = ref(db, `users/${currentUser.uid}/pinnedChannels/${channelId}`);
              const pinnedSnap = await get(pinnedRef);
              let sortTime = channel.lastMessageTime || channel.createdAt || 0;
              if (pinnedSnap.exists()) {
                sortTime = pinnedSnap.val();
              }
              let lastMsg = channel.description || 'Welcome to the channel';
              let lastTime = channel.lastMessageTime || 0;
              if (channel.lastMessage) {
                lastMsg = await decryptMessage(channel.lastMessage, channelId);
              }
              return { channelId, channel, lastMsg, lastTime, sortTime };
            });
            allChannelsData = (await Promise.all(channelPromises)).filter(c => c);
            allChannelsData.sort((a, b) => b.sortTime - a.sortTime);
            renderChannels(allChannelsData);
          }
        }
      } catch (error) {
        console.error('Error loading channels:', error);
        channelsList.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 60px; font-size: 17px;">Error loading channels. Please try again.</p>';
      } finally {
        hideSpinner();
      }
    }

    function getCategoryIcon(category) {
      const icons = {
        general: 'public',
        tech: 'developer_mode',
        sports: 'sports_soccer',
        music: 'music_note',
        news: 'article'
      };
      return icons[category] || 'category';
    }

    function renderChannels(channelsToRender) {
      const channelsList = document.getElementById('channels-list');
      channelsList.innerHTML = '';
      for (const { channel, channelId, lastMsg, lastTime } of channelsToRender) {
        const initial = channel.name ? channel.name[0].toUpperCase() : 'C';
        let avatarHtml;
        const picUrl = channel.profilePic;
        if (picUrl) {
          avatarHtml = `<img src="${picUrl}" alt="${channel.name}" class="channel-avatar" style="display: block;" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" loading="lazy"><div class="channel-avatar" style="display: none; background: var(--x-blue); color: #000000; font-size: 24px; font-weight: bold;">${initial}</div>`;
        } else {
          avatarHtml = `<div class="channel-avatar" style="background: var(--x-blue); color: #000000; font-size: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold;">${initial}</div>`;
        }
        const nameHtml = channel.name || 'Channel';
        const followerCount = channel.followerCount || 0;
        const desc = channel.description || '';
        const category = channel.category || '';
        let categoryHtml = '';
        if (category) {
          const icon = getCategoryIcon(category);
          categoryHtml = `<span class="category-badge"><span class="material-icons">${icon}</span>${category.charAt(0).toUpperCase() + category.slice(1)}</span>`;
        }
        const channelCard = document.createElement('div');
        channelCard.className = 'channel-card';
        channelCard.onclick = () => startChannelChat(channelId, channel);
        channelCard.innerHTML = `
          <div class="avatar-wrapper">
            ${avatarHtml}
          </div>
          <div class="channel-info">
            <div class="channel-name">
              ${nameHtml}
              ${categoryHtml}
              <button class="follow-btn" id="follow-${channelId}" data-channelid="${channelId}">Follow</button>
            </div>
            <div class="channel-desc" id="desc-${channelId}">${desc}</div>
            <div class="channel-meta">
              <span class="follower-count" id="followers-${channelId}">${followerCount} followers</span>
              ${lastTime ? `<span class="last-time" id="channel-time-${channelId}">${formatTime(lastTime)}</span>` : ''}
            </div>
            <div class="last-preview" id="channel-preview-${channelId}">${lastMsg}</div>
          </div>
          <button class="context-btn" data-channelid="${channelId}">⋮</button>
        `;
        channelsList.appendChild(channelCard);

        const followBtn = channelCard.querySelector('.follow-btn');
        followBtn.onclick = async (e) => {
          e.stopPropagation();
          const isFollowing = followBtn.classList.contains('following');
          const countRef = ref(db, `channels/${channelId}/followerCount`);
          const currentCountSnap = await get(countRef);
          let newCount = (currentCountSnap.val() || 0);
          if (isFollowing) {
            await remove(ref(db, `users/${currentUser.uid}/followedChannels/${channelId}`));
            newCount = Math.max(0, newCount - 1);
          } else {
            await set(ref(db, `users/${currentUser.uid}/followedChannels/${channelId}`), true);
            newCount += 1;
          }
          await set(countRef, newCount);
        };

        const contextBtn = channelCard.querySelector('.context-btn');
        contextBtn.onclick = async (e) => {
          e.stopPropagation();
          await showChannelContextMenu(channelId, channel);
        };

        // Follow status listener
        const followedRef = ref(db, `users/${currentUser.uid}/followedChannels/${channelId}`);
        onValue(followedRef, (snap) => {
          if (followBtn) {
            if (snap.exists()) {
              followBtn.textContent = 'Following';
              followBtn.classList.add('following');
            } else {
              followBtn.textContent = 'Follow';
              followBtn.classList.remove('following');
            }
          }
        });

        const channelRef = ref(db, `channels/${channelId}`);
        onValue(channelRef, async (snap) => {
          try {
            if (snap.exists()) {
              const ch = snap.val();
              const previewEl = document.getElementById(`channel-preview-${channelId}`);
              const timeEl = document.getElementById(`channel-time-${channelId}`);
              const descEl = document.getElementById(`desc-${channelId}`);
              const followersEl = document.getElementById(`followers-${channelId}`);
              if (previewEl) {
                previewEl.textContent = ch.lastMessage ? await decryptMessage(ch.lastMessage, channelId) : (ch.description || 'Welcome');
              }
              if (timeEl && ch.lastMessageTime) {
                timeEl.textContent = formatTime(ch.lastMessageTime);
              }
              if (descEl) {
                descEl.textContent = ch.description || '';
              }
              if (followersEl) {
                followersEl.textContent = `${ch.followerCount || 0} followers`;
              }
            }
          } catch (error) {
            console.error('Error updating channel preview:', error);
          }
        });
      }
    }

    function setupChannelSearch() {
      const searchInput = document.getElementById('channel-search-input');
      searchInput.addEventListener('input', (e) => {
        const term = e.target.value.toLowerCase();
        const selectedCategory = document.querySelector('#category-filter .filter-btn.active').dataset.category;
        filterChannels(term, selectedCategory);
      });
    }

    function setupCategoryFilter() {
      const filterBtns = document.querySelectorAll('#category-filter .filter-btn');
      filterBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          filterBtns.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          const selectedCategory = btn.dataset.category;
          const searchTerm = document.getElementById('channel-search-input').value.toLowerCase();
          filterChannels(searchTerm, selectedCategory);
        });
      });
    }

    function setupCreateCategory() {
      const categoryBtns = document.querySelectorAll('#channel-category-grid .category-btn');
      categoryBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          categoryBtns.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
        });
      });
    }

    function filterChannels(searchTerm, selectedCategory) {
      const filtered = allChannelsData.filter(({ channel }) => {
        const matchesSearch = !searchTerm || channel.name.toLowerCase().includes(searchTerm) || channel.description.toLowerCase().includes(searchTerm);
        const matchesCategory = !selectedCategory || channel.category === selectedCategory;
        return matchesSearch && matchesCategory;
      });
      renderChannels(filtered);
    }

    function setupSearch() {
      const searchInput = document.getElementById('search-input');
      searchInput.addEventListener('input', (e) => {
        const term = e.target.value.toLowerCase();
        document.querySelectorAll('#chats-section .user-card').forEach(card => {
          const name = card.querySelector('.user-name').textContent.toLowerCase().replace(verifiedIcon.toLowerCase(), '');
          card.style.display = name.includes(term) ? '' : 'none';
        });
      });
    }

    async function startChat(targetUid, user) {
      try {
        const chatId = [currentUser.uid, targetUid].sort().join('_');
        const currentChatsRef = ref(db, `users/${currentUser.uid}/chats/${targetUid}`);
        const targetChatsRef = ref(db, `users/${targetUid}/chats/${currentUser.uid}`);
        const currentSnapshot = await get(currentChatsRef);
        if (!currentSnapshot.exists()) {
          const initialMessage = 'Say hi to start chatting!';
          const encrypted = await encryptMessage(initialMessage, chatId);
          await set(currentChatsRef, {
            chatId,
            otherUserId: targetUid,
            lastMessage: encrypted,
            lastMessageType: 'text',
            lastMessageTime: Date.now(),
            unreadCount: 0
          });
          await set(targetChatsRef, {
            chatId,
            otherUserId: currentUser.uid,
            lastMessage: encrypted,
            lastMessageType: 'text',
            lastMessageTime: Date.now(),
            unreadCount: 0
          });
          const messagesRef = ref(db, `chats/${chatId}/messages`);
          const newMessageRef = push(messagesRef);
          await set(newMessageRef, {
            senderId: currentUser.uid,
            message: encrypted,
            type: 'text',
            timestamp: Date.now()
          });
        }
        const params = new URLSearchParams({
          chatId,
          userId: targetUid,
          username: user?.displayName || '',
          avatar: user?.photoURL || '',
          verified: !!user?.verified,
          isGroup: false
        });
        window.location.href = `chat.html?${params.toString()}`;
        showAlert('Chat started!');
      } catch (error) {
        console.error('Error starting chat:', error);
        showAlert('Failed to start chat.');
      }
    }

    async function startChannelChat(channelId, channel) {
      try {
        const params = new URLSearchParams({
          chatId: channelId,
          groupName: channel.name || '',
          isGroup: true
        });
        window.location.href = `chat.html?${params.toString()}`;
      } catch (error) {
        console.error('Error starting channel chat:', error);
        showAlert('Failed to start channel chat.');
      }
    }

    async function createChannel(event) {
      if (event) event.stopPropagation();
      const name = document.getElementById('channel-name').value.trim();
      if (!name) return showAlert('Channel name required');
      const desc = document.getElementById('channel-desc').value.trim();
      const fileInput = document.getElementById('channel-pic');
      const file = fileInput.files[0];
      const selectedCategoryBtn = document.querySelector('#channel-category-grid .category-btn.active');
      const category = selectedCategoryBtn ? selectedCategoryBtn.dataset.category : '';
      if (!category) return showAlert('Category required');

      const createBtn = document.getElementById('create-channel-btn');
      createBtn.disabled = true;
      createBtn.textContent = 'Creating...';

      let picUrl = null;
      if (file) {
        const progressDiv = document.getElementById('channel-pic-progress');
        const progressBar = document.getElementById('channel-pic-progress-bar');
        progressDiv.classList.remove('hidden');
        progressBar.style.width = '0%';
        try {
          const xhr = new XMLHttpRequest();
          xhr.open('POST', `https://api.cloudinary.com/v1_1/${cloudinaryConfig.cloudName}/image/upload`);
          const formData = new FormData();
          formData.append('file', file);
          formData.append('upload_preset', cloudinaryConfig.uploadPreset);
          await new Promise((resolve, reject) => {
            xhr.upload.addEventListener('progress', (e) => {
              if (e.lengthComputable) {
                const percent = Math.round((e.loaded / e.total) * 100);
                progressBar.style.width = percent + '%';
              }
            });
            xhr.onload = () => {
              if (xhr.status === 200) {
                const data = JSON.parse(xhr.responseText);
                picUrl = data.secure_url;
                resolve();
              } else {
                reject(new Error(`Upload failed: ${xhr.statusText}`));
              }
            };
            xhr.onerror = reject;
            xhr.send(formData);
          });
        } catch (error) {
          console.error('Upload failed:', error);
          showAlert('Failed to upload image. Please try again.');
          createBtn.disabled = false;
          createBtn.textContent = 'Create Channel';
          progressDiv.classList.add('hidden');
          return;
        } finally {
          progressDiv.classList.add('hidden');
        }
      }

      try {
        const channelId = push(ref(db, 'channels')).key;
        if (!channelId) throw new Error('Failed to generate channel ID');
        const initialMessage = `Welcome to ${name}!`;
        const encrypted = await encryptMessage(initialMessage, channelId);
        const channelData = {
          name,
          description: desc,
          creatorUid: currentUser.uid,
          profilePic: picUrl || null,
          category,
          lastMessage: encrypted,
          lastMessageTime: Date.now(),
          createdAt: Date.now(),
          followerCount: 1
        };
        await set(ref(db, `channels/${channelId}`), channelData);
        await set(ref(db, `users/${currentUser.uid}/followedChannels/${channelId}`), true);
        showAlert('Channel created!');
        closeBottomSheet();
        document.getElementById('channel-name').value = '';
        document.getElementById('channel-desc').value = '';
        fileInput.value = '';
        document.querySelector('#channel-category-grid .category-btn').classList.add('active');
        document.querySelectorAll('#channel-category-grid .category-btn:not(:first-child)').forEach(btn => btn.classList.remove('active'));
        await loadChannels();
      } catch (error) {
        console.error('Error creating channel:', error);
        showAlert(`Failed to create channel: ${error.message}`);
      } finally {
        createBtn.disabled = false;
        createBtn.textContent = 'Create Channel';
      }
    }

    async function pinChannel(channelId) {
      try {
        await set(ref(db, `users/${currentUser.uid}/pinnedChannels/${channelId}`), Date.now());
        showAlert('Channel chat pinned.');
        await loadChannels();
      } catch (error) {
        console.error('Error pinning channel:', error);
        showAlert(`Failed to pin channel: ${error.message}`);
      }
    }

    async function unpinChannel(channelId) {
      try {
        await remove(ref(db, `users/${currentUser.uid}/pinnedChannels/${channelId}`));
        showAlert('Channel chat unpinned.');
        await loadChannels();
      } catch (error) {
        console.error('Error unpinning channel:', error);
        showAlert(`Failed to unpin channel: ${error.message}`);
      }
    }

    async function encryptMessage(message, chatId) {
      try {
        const encoder = new TextEncoder();
        const keyMaterial = await crypto.subtle.importKey(
          "raw",
          encoder.encode("grochat-secret-key-2025"),
          { name: "PBKDF2" },
          false,
          ["deriveBits", "deriveKey"]
        );
        const salt = encoder.encode(chatId);
        const key = await crypto.subtle.deriveKey(
          {
            name: "PBKDF2",
            salt: salt,
            iterations: 100000,
            hash: "SHA-256"
          },
          keyMaterial,
          { name: "AES-GCM", length: 256 },
          true,
          ["encrypt"]
        );
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const data = encoder.encode(message);
        const encrypted = await crypto.subtle.encrypt(
          { name: "AES-GCM", iv: iv },
          key,
          data
        );
        const ivB64 = btoa(String.fromCharCode(...iv));
        const ciphertextB64 = btoa(String.fromCharCode(...new Uint8Array(encrypted)));
        return JSON.stringify({ iv: ivB64, ciphertext: ciphertextB64 });
      } catch (error) {
        console.error('Encryption failed:', error);
        throw error;
      }
    }

    // Tab switching
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', async () => {
        const oldSection = document.querySelector('.tab-section.active');
        const newSectionId = btn.dataset.tab + '-section';
        const newSection = document.getElementById(newSectionId);
        if (oldSection.id === newSectionId) return;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        oldSection.style.opacity = '0';
        setTimeout(() => {
          oldSection.classList.remove('active');
          newSection.classList.add('active');
          newSection.style.opacity = '1';
          const fab = document.getElementById('create-channel-fab');
          if (btn.dataset.tab === 'channels') {
            fab.style.display = 'block';
            if (!newSection.dataset.loaded) {
              loadChannels();
              setupChannelSearch();
              setupCategoryFilter();
              newSection.dataset.loaded = 'true';
            }
          } else {
            fab.style.display = 'none';
            if (!newSection.dataset.loaded) {
              loadAllUsers();
              setupSearch();
              newSection.dataset.loaded = 'true';
            }
          }
        }, 300);
      });
    });

    // FAB
    document.getElementById('create-channel-fab').addEventListener('click', () => {
      showBottomSheet('create-channel-sheet');
      setupCreateCategory();
    });

    // Context menus
    document.getElementById('context-menu').addEventListener('click', (e) => {
      if (e.target.id === 'context-menu') hideContextMenu();
    });
    document.querySelectorAll('#context-menu .context-option').forEach(opt => {
      opt.addEventListener('click', (e) => {
        e.stopPropagation();
        const action = opt.dataset.action;
        if (action === 'delete') deleteChats(currentUid);
        else if (action === 'block') blockFriend(currentUid);
        else if (action === 'pin') pinFriend(currentUid);
        hideContextMenu();
      });
    });

    document.getElementById('channel-context-menu').addEventListener('click', (e) => {
      if (e.target.id === 'channel-context-menu') hideContextMenu();
    });
    document.querySelectorAll('#channel-context-menu .channel-context-option').forEach(opt => {
      opt.addEventListener('click', (e) => {
        e.stopPropagation();
        const action = opt.dataset.action;
        if (action === 'pin') pinChannel(currentChannelId);
        else if (action === 'unpin') unpinChannel(currentChannelId);
        hideContextMenu();
      });
    });

    onAuthStateChanged(auth, async (user) => {
      currentUser = user;
      if (user) {
        // Set up profile pic
        const profilePic = document.getElementById('user-profile-pic');
        if (user.photoURL) {
          profilePic.innerHTML = `<img src="${user.photoURL}" alt="Profile">`;
        } else {
          const initial = user.displayName ? user.displayName[0].toUpperCase() : 'U';
          profilePic.textContent = initial;
        }
        profilePic.onclick = () => {
          window.location.href = 'profile.html';
        };

        // Presence
        const connectedRef = ref(db, '.info/connected');
        onValue(connectedRef, (snap) => {
          if (snap.val() === true) {
            const userStatusRef = ref(db, `userStatuses/${user.uid}`);
            set(userStatusRef, true);
            onDisconnect(userStatusRef).set(false);
          }
        });

        await loadFollows();
        await loadBlocked();
        // Initial load for chats tab
        loadAllUsers();
        setupSearch();
        document.getElementById('chats-section').dataset.loaded = 'true';
      } else {
        window.location.href = 'login.html';
      }
    });
  </script>
</body>
</html>
