<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Morabaraba</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --twitter-blue: #1DA1F2;
      --text-dark: #0F1419;
      --text-light: #536471;
      --border: #D8D9DB;
      --white: #FFFFFF;
      --background: #000000;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background: var(--background);
      min-height: 100vh;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      transition: opacity 0.5s ease;
    }

    .game-container {
      text-align: center;
      position: relative;
      z-index: 10;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .board-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      margin: 0 auto;
      width: 100%;
      height: 80%;
    }

    svg.board {
      width: 100%;
      height: 100%;
      background: var(--white);
      border: 2px solid var(--border);
      border-radius: 8px;
      animation: fadeInScale 1.2s ease-out forwards;
    }

    .node {
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .node:hover {
      transform: scale(1.2);
    }

    .cow-player1 {
      fill: var(--twitter-blue);
      animation: slideBlinkPlayer1 1.5s ease-in-out infinite;
    }

    .cow-player2 {
      fill: #FF4500;
    }

    .selected {
      fill: yellow;
      animation: none;
    }

    .game-text {
      color: var(--white);
      font-weight: 700;
      font-size: 1.5rem;
      letter-spacing: 0.5px;
      animation: fadeInUp 1s ease-out 0.5s forwards;
      opacity: 0;
    }

    .controls {
      display: flex;
      gap: 1rem;
      justify-content: center;
      margin-top: 1rem;
    }

    .control-btn {
      padding: 0.5rem 1rem;
      background: var(--twitter-blue);
      color: var(--white);
      border: none;
      border-radius: 20px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .control-btn:hover {
      background: #1a91da;
      transform: scale(1.05);
    }

    .custom-alert {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--white);
      padding: 1.5rem 2rem;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      color: var(--text-dark);
      font-weight: 500;
      text-align: center;
      max-width: 90%;
      width: 320px;
      animation: fadeIn 0.3s ease-out forwards;
      border: 1px solid var(--border);
    }

    .custom-alert.active {
      display: block;
    }

    .custom-alert .close-btn {
      position: absolute;
      top: 0.75rem;
      right: 0.75rem;
      width: 24px;
      height: 24px;
      background: none;
      border: none;
      color: var(--twitter-blue);
      cursor: pointer;
      transition: transform 0.2s ease, color 0.2s ease;
    }

    .custom-alert .close-btn:hover {
      transform: scale(1.2);
      color: #1a91da;
    }

    .custom-alert .close-btn svg {
      width: 100%;
      height: 100%;
    }

    @keyframes slideBlinkPlayer1 {
      0%, 100% { transform: translateX(0); opacity: 1; }
      25% { transform: translateX(2px); opacity: 0.5; }
      50% { transform: translateX(0); opacity: 1; }
      75% { transform: translateX(-2px); opacity: 0.5; }
    }

    @keyframes fadeInScale {
      0% { opacity: 0; transform: scale(0.7); }
      100% { opacity: 1; transform: scale(1); }
    }

    @keyframes fadeInUp {
      0% { opacity: 0; transform: translateY(20px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    @keyframes fadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    @media (max-width: 640px) {
      .game-text {
        font-size: 1.25rem;
      }

      .control-btn {
        padding: 0.4rem 0.8rem;
        font-size: 0.9rem;
      }

      .custom-alert {
        width: 85%;
        padding: 1rem;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="board-container">
      <svg class="board" viewBox="0 0 200 200">
        <!-- Outer Square -->
        <line x1="10" y1="10" x2="190" y2="10" stroke="black" stroke-width="2" />
        <line x1="10" y1="10" x2="10" y2="190" stroke="black" stroke-width="2" />
        <line x1="190" y1="10" x2="190" y2="190" stroke="black" stroke-width="2" />
        <line x1="10" y1="190" x2="190" y2="190" stroke="black" stroke-width="2" />
        <!-- Middle Square -->
        <line x1="50" y1="50" x2="150" y2="50" stroke="black" stroke-width="2" />
        <line x1="50" y1="50" x2="50" y2="150" stroke="black" stroke-width="2" />
        <line x1="150" y1="50" x2="150" y2="150" stroke="black" stroke-width="2" />
        <line x1="50" y1="150" x2="150" y2="150" stroke="black" stroke-width="2" />
        <!-- Inner Square -->
        <line x1="90" y1="90" x2="110" y2="90" stroke="black" stroke-width="2" />
        <line x1="90" y1="90" x2="90" y2="110" stroke="black" stroke-width="2" />
        <line x1="110" y1="90" x2="110" y2="110" stroke="black" stroke-width="2" />
        <line x1="90" y1="110" x2="110" y2="110" stroke="black" stroke-width="2" />
        <!-- Connecting Lines -->
        <line x1="100" y1="10" x2="100" y2="90" stroke="black" stroke-width="2" />
        <line x1="10" y1="100" x2="90" y2="100" stroke="black" stroke-width="2" />
        <line x1="110" y1="100" x2="190" y2="100" stroke="black" stroke-width="2" />
        <line x1="100" y1="110" x2="100" y2="190" stroke="black" stroke-width="2" />
        <!-- Nodes (24 points, adjusted to avoid overlaps) -->
        <circle class="node" id="n0" cx="10" cy="10" r="6" fill="gray" onclick="handleNodeClick(0)" />
        <circle class="node" id="n1" cx="100" cy="10" r="6" fill="gray" onclick="handleNodeClick(1)" />
        <circle class="node" id="n2" cx="190" cy="10" r="6" fill="gray" onclick="handleNodeClick(2)" />
        <circle class="node" id="n3" cx="50" cy="50" r="6" fill="gray" onclick="handleNodeClick(3)" />
        <circle class="node" id="n4" cx="100" cy="50" r="6" fill="gray" onclick="handleNodeClick(4)" />
        <circle class="node" id="n5" cx="150" cy="50" r="6" fill="gray" onclick="handleNodeClick(5)" />
        <circle class="node" id="n6" cx="90" cy="90" r="6" fill="gray" onclick="handleNodeClick(6)" />
        <circle class="node" id="n7" cx="110" cy="90" r="6" fill="gray" onclick="handleNodeClick(7)" />
        <circle class="node" id="n8" cx="10" cy="100" r="6" fill="gray" onclick="handleNodeClick(8)" />
        <circle class="node" id="n9" cx="50" cy="100" r="6" fill="gray" onclick="handleNodeClick(9)" />
        <circle class="node" id="n10" cx="150" cy="100" r="6" fill="gray" onclick="handleNodeClick(10)" />
        <circle class="node" id="n11" cx="190" cy="100" r="6" fill="gray" onclick="handleNodeClick(11)" />
        <circle class="node" id="n12" cx="90" cy="110" r="6" fill="gray" onclick="handleNodeClick(12)" />
        <circle class="node" id="n13" cx="110" cy="110" r="6" fill="gray" onclick="handleNodeClick(13)" />
        <circle class="node" id="n14" cx="10" cy="190" r="6" fill="gray" onclick="handleNodeClick(14)" />
        <circle class="node" id="n15" cx="100" cy="190" r="6" fill="gray" onclick="handleNodeClick(15)" />
        <circle class="node" id="n16" cx="190" cy="190" r="6" fill="gray" onclick="handleNodeClick(16)" />
        <circle class="node" id="n17" cx="50" cy="150" r="6" fill="gray" onclick="handleNodeClick(17)" />
        <circle class="node" id="n18" cx="100" cy="150" r="6" fill="gray" onclick="handleNodeClick(18)" />
        <circle class="node" id="n19" cx="150" cy="150" r="6" fill="gray" onclick="handleNodeClick(19)" />
        <circle class="node" id="n20" cx="85" cy="105" r="6" fill="gray" onclick="handleNodeClick(20)" />
        <circle class="node" id="n21" cx="95" cy="105" r="6" fill="gray" onclick="handleNodeClick(21)" />
        <circle class="node" id="n22" cx="115" cy="105" r="6" fill="gray" onclick="handleNodeClick(22)" />
        <circle class="node" id="n23" cx="105" cy="115" r="6" fill="gray" onclick="handleNodeClick(23)" />
      </svg>
      <p class="game-text" id="game-status">Player 1's Turn (Place a cow)</p>
    </div>
    <div class="controls">
      <button class="control-btn" onclick="resetGame()">Reset Game</button>
    </div>
  </div>

  <div id="custom-alert" class="custom-alert">
    <button class="close-btn" onclick="hideAlert()">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6" y1="6" x2="18" y2="18"></line>
      </svg>
    </button>
    <p id="alert-message"></p>
  </div>

  <script>
    let gameState = {
      board: Array(24).fill(null),
      phase: 'placing',
      currentPlayer: 1,
      cowsPlaced: { 1: 0, 2: 0 },
      cowsLeft: { 1: 12, 2: 12 },
      selectedNode: null,
      mills: [],
      isAITurn: false,
    };

    const mills = [
      [0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11], [12, 13, 14], [15, 16, 17], [18, 19, 20], [21, 22, 23],
      [0, 8, 14], [3, 9, 15], [6, 10, 16], [1, 4, 7], [17, 20, 23], [5, 11, 19], [2, 12, 18], [13, 15, 22]
    ];

    const adjacent = [
      [1, 8], [0, 2, 4], [1, 12], [4, 9], [1, 3, 5, 7], [4, 11], [7, 10], [4, 6, 8], [0, 7, 14], [3, 10, 15],
      [6, 9, 11, 16], [5, 10, 19], [2, 13, 18], [12, 14, 15], [8, 13, 16], [9, 13, 17], [10, 14, 19], [15, 18],
      [12, 17, 19], [11, 16, 18], [17, 21], [20, 22, 23], [21, 23], [21, 22]
    ];

    function handleNodeClick(nodeIndex) {
      if (gameState.currentPlayer !== 1 || gameState.isAITurn) {
        showAlert("Please wait for your turn!");
        return;
      }
      if (gameState.phase === 'placing') {
        placeCow(nodeIndex);
      } else if (gameState.phase === 'moving') {
        moveCow(nodeIndex);
      } else if (gameState.phase === 'removing') {
        removeOpponentCow(nodeIndex);
      }
    }

    function placeCow(nodeIndex) {
      if (gameState.board[nodeIndex] !== null) {
        showAlert("That position is already occupied!");
        return;
      }
      gameState.board[nodeIndex] = gameState.currentPlayer;
      gameState.cowsPlaced[gameState.currentPlayer]++;
      gameState.cowsLeft[gameState.currentPlayer]--;
      updateBoard();
      if (checkMill(nodeIndex)) {
        gameState.phase = 'removing';
        updateStatus(`Player ${gameState.currentPlayer}, remove an opponent's cow`);
        return;
      }
      if (gameState.cowsPlaced[1] === 12 && gameState.cowsPlaced[2] === 12) {
        gameState.phase = 'moving';
      }
      switchPlayer();
      if (gameState.currentPlayer === 2) {
        gameState.isAITurn = true;
        setTimeout(aiMove, 1000);
      }
    }

    function moveCow(nodeIndex) {
      if (gameState.selectedNode === null) {
        if (gameState.board[nodeIndex] === gameState.currentPlayer) {
          gameState.selectedNode = nodeIndex;
          updateBoard();
          updateStatus(`Player ${gameState.currentPlayer}, select an adjacent empty node to move to`);
        }
      } else {
        if (gameState.board[nodeIndex] === null && adjacent[gameState.selectedNode].includes(nodeIndex)) {
          gameState.board[nodeIndex] = gameState.currentPlayer;
          gameState.board[gameState.selectedNode] = null;
          gameState.selectedNode = null;
          updateBoard();
          if (checkMill(nodeIndex)) {
            gameState.phase = 'removing';
            updateStatus(`Player ${gameState.currentPlayer}, remove an opponent's cow`);
            return;
          }
          if (checkWin()) return;
          switchPlayer();
          if (gameState.currentPlayer === 2) {
            gameState.isAITurn = true;
            setTimeout(aiMove, 1000);
          }
        } else {
          showAlert("Invalid move! Select an adjacent empty node.");
          gameState.selectedNode = null;
          updateBoard();
        }
      }
    }

    function removeOpponentCow(nodeIndex) {
      if (gameState.board[nodeIndex] !== 3 - gameState.currentPlayer) {
        showAlert("Select an opponent's cow to remove!");
        return;
      }
      const opponent = 3 - gameState.currentPlayer;
      const nonMillNodes = gameState.board.map((val, idx) => val === opponent && !isInMill(idx) ? idx : null).filter(val => val !== null);
      const canRemoveFromMill = nonMillNodes.length === 0;
      if (!canRemoveFromMill && isInMill(nodeIndex)) {
        showAlert("Cannot remove a cow in a mill! Choose another.");
        return;
      }
      gameState.board[nodeIndex] = null;
      gameState.cowsLeft[opponent]--;
      gameState.phase = gameState.cowsPlaced[1] < 12 || gameState.cowsPlaced[2] < 12 ? 'placing' : 'moving';
      updateBoard();
      if (checkWin()) return;
      switchPlayer();
      if (gameState.currentPlayer === 2) {
        gameState.isAITurn = true;
        setTimeout(aiMove, 1000);
      }
    }

    function checkMill(nodeIndex) {
      const player = gameState.board[nodeIndex];
      for (const mill of mills) {
        if (mill.includes(nodeIndex) && mill.every(i => gameState.board[i] === player)) {
          if (!gameState.mills.some(m => JSON.stringify(m) === JSON.stringify(mill))) {
            gameState.mills.push(mill);
            return true;
          }
        }
      }
      return false;
    }

    function isInMill(nodeIndex) {
      const player = gameState.board[nodeIndex];
      for (const mill of mills) {
        if (mill.includes(nodeIndex) && mill.every(i => gameState.board[i] === player)) {
          return true;
        }
      }
      return false;
    }

    function checkWin() {
      const opponent = 3 - gameState.currentPlayer;
      if (gameState.cowsLeft[opponent] < 3 && gameState.phase !== 'placing') {
        showAlert(`Player ${gameState.currentPlayer} wins!`, false);
        return true;
      }
      const hasMoves = gameState.board.some((val, idx) => val === opponent && adjacent[idx].some(adj => gameState.board[adj] === null));
      if (!hasMoves && gameState.phase !== 'placing') {
        showAlert(`Player ${gameState.currentPlayer} wins! Opponent has no moves.`, false);
        return true;
      }
      return false;
    }

    function aiMove() {
      if (gameState.phase === 'placing') {
        let emptyNodes = gameState.board.map((val, idx) => val === null ? idx : null).filter(val => val !== null);
        if (emptyNodes.length === 0) {
          gameState.isAITurn = false;
          switchPlayer();
          return;
        }
        let nodeIndex = emptyNodes[Math.floor(Math.random() * emptyNodes.length)];
        placeCow(nodeIndex);
      } else if (gameState.phase === 'moving') {
        let playerNodes = gameState.board.map((val, idx) => val === 2 ? idx : null).filter(val => val !== null);
        if (playerNodes.length === 0) {
          gameState.isAITurn = false;
          switchPlayer();
          return;
        }
        let fromNode = playerNodes[Math.floor(Math.random() * playerNodes.length)];
        let adjNodes = adjacent[fromNode].filter(i => gameState.board[i] === null);
        if (adjNodes.length > 0) {
          let toNode = adjNodes[Math.floor(Math.random() * adjNodes.length)];
          gameState.selectedNode = fromNode;
          moveCow(toNode);
        } else {
          gameState.isAITurn = false;
          switchPlayer();
        }
      } else if (gameState.phase === 'removing') {
        const opponent = 1; // Since AI is player 2
        let opponentNodes = gameState.board.map((val, idx) => val === opponent && !isInMill(idx) ? idx : null).filter(val => val !== null);
        let canRemoveFromMill = opponentNodes.length === 0;
        if (canRemoveFromMill) {
          opponentNodes = gameState.board.map((val, idx) => val === opponent ? idx : null).filter(val => val !== null);
        }
        if (opponentNodes.length > 0) {
          let nodeIndex = opponentNodes[Math.floor(Math.random() * opponentNodes.length)];
          removeOpponentCow(nodeIndex);
        } else {
          gameState.phase = 'moving';
          gameState.isAITurn = false;
          switchPlayer();
        }
      }
      gameState.isAITurn = false;
    }

    function switchPlayer() {
      gameState.currentPlayer = 3 - gameState.currentPlayer;
      gameState.selectedNode = null;
      updateBoard();
      updateStatus(`Player ${gameState.currentPlayer}'s Turn (${gameState.phase === 'placing' ? 'Place' : 'Move'} a cow)`);
    }

    function updateBoard() {
      for (let i = 0; i < 24; i++) {
        const node = document.getElementById(`n${i}`);
        node.classList.remove('cow-player1', 'cow-player2', 'selected');
        if (gameState.board[i] === 1) {
          node.classList.add('cow-player1');
        } else if (gameState.board[i] === 2) {
          node.classList.add('cow-player2');
        } else {
          node.setAttribute('fill', 'gray');
        }
        if (gameState.selectedNode === i) {
          node.classList.add('selected');
        }
      }
    }

    function updateStatus(message) {
      document.getElementById('game-status').textContent = message;
    }

    function showAlert(message, autoHide = true) {
      document.getElementById('alert-message').textContent = message;
      document.getElementById('custom-alert').classList.add('active');
      if (autoHide) {
        setTimeout(hideAlert, 3000);
      }
    }

    function hideAlert() {
      document.getElementById('custom-alert').classList.remove('active');
    }

    function resetGame() {
      gameState = {
        board: Array(24).fill(null),
        phase: 'placing',
        currentPlayer: 1,
        cowsPlaced: { 1: 0, 2: 0 },
        cowsLeft: { 1: 12, 2: 12 },
        selectedNode: null,
        mills: [],
        isAITurn: false,
      };
      updateBoard();
      updateStatus(`Player 1's Turn (Place a cow)`);
      hideAlert();
    }

    document.addEventListener('DOMContentLoaded', () => {
      updateBoard();
    });
  </script>
</body>
</html>
