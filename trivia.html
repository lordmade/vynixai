<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>Global Chat - Vynix</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js"></script>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
    :root {
      --bg: #ffffff;
      --card-bg: #f7f9fa;
      --text-primary: #0f1419;
      --text-secondary: #536471;
      --border: #e1e8ed;
      --accent: #ff2a6d;
      --header-bg: #ffffff;
      --chat-bubble-sent: #ff2a6d;
      --chat-bubble-received: #f7f9fa;
      --status-online: #128c7e;
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
      --glow: 0 0 10px rgba(255, 42, 109, .35);
    }
    body.dark {
      --bg: #000000;
      --card-bg: #16181c;
      --text-primary: #ffffff;
      --text-secondary: #71767b;
      --border: #2f3336;
      --header-bg: #000000;
      --chat-bubble-received: #16181c;
    }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text-primary);
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      touch-action: manipulation;
      line-height: 1.4;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: var(--header-bg);
      z-index: 100;
      padding: 12px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 64px;
      box-shadow: var(--shadow-sm);
      transition: background-color 0.3s ease;
    }
    .header-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .back-btn {
      background: none;
      border: none;
      color: var(--text-primary);
      font-size: 24px;
      cursor: pointer;
      padding: 8px;
      border-radius: 50%;
      transition: background 0.2s ease;
    }
    .back-btn:hover {
      background: rgba(255, 42, 109, 0.1);
    }
    .room-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .room-name-header {
      font-weight: 700;
      font-size: 18px;
      color: var(--text-primary);
    }
    .room-participants {
      font-size: 12px;
      color: var(--text-secondary);
    }
    .main-content {
      padding: 84px 20px 120px;
      max-width: 800px;
      margin: 0 auto;
      width: 100%;
    }
    .messages-container {
      flex: 1;
      overflow-y: auto;
      padding-bottom: 20px;
      max-height: calc(100vh - 200px);
    }
    .message-date {
      text-align: center;
      margin: 20px 0;
      color: var(--text-secondary);
      font-size: 13px;
    }
    .message-item {
      display: flex;
      margin-bottom: 16px;
      animation: fadeIn 0.3s ease;
      position: relative;
    }
    .message-bubble-wrapper {
      max-width: 75%;
      display: flex;
      flex-direction: column;
    }
    .message-sent .message-bubble-wrapper {
      align-items: flex-end;
    }
    .sender-name {
      font-size: 12px;
      color: var(--accent);
      margin-bottom: 4px;
      font-weight: 600;
    }
    .message-sent .sender-name {
      color: #ff8fab;
      text-align: right;
    }
    .message-bubble {
      padding: 12px 16px;
      border-radius: 20px;
      word-wrap: break-word;
      line-height: 1.4;
      position: relative;
      cursor: pointer;
      user-select: none; /* Prevent text selection on long press */
    }
    .message-received .message-bubble {
      background: var(--chat-bubble-received);
      color: var(--text-primary);
      border-bottom-left-radius: 4px;
      border: 1px solid var(--border);
    }
    .message-sent .message-bubble {
      background: var(--chat-bubble-sent);
      color: #ffffff;
      border-bottom-right-radius: 4px;
      box-shadow: var(--glow);
    }
    .message-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      object-fit: cover;
      background: var(--accent);
      color: #ffffff;
      font-size: 16px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 12px;
      flex-shrink: 0;
    }
    .message-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 50%;
    }
    .message-time {
      font-size: 12px;
      color: var(--text-secondary);
      margin-top: 4px;
      text-align: right;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 4px;
    }
    .message-sent .message-time {
      color: rgba(255, 255, 255, 0.8);
    }
    .status-icon {
      font-size: 16px;
    }
    .status-sent {
      color: rgba(255, 255, 255, 0.7);
    }
    .input-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--card-bg);
      border-top: 1px solid var(--border);
      padding: 12px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 10;
      box-shadow: var(--shadow-sm);
    }
    .input-group {
      flex: 1;
      display: flex;
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 24px;
      overflow: hidden;
    }
    .input-group textarea {
      flex: 1;
      background: none;
      border: none;
      outline: none;
      padding: 12px 20px;
      color: var(--text-primary);
      font-size: 16px;
      resize: none;
      max-height: 120px;
      font-family: inherit;
    }
    .input-group textarea::placeholder {
      color: var(--text-secondary);
    }
    .input-icon {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 20px;
      cursor: pointer;
      padding: 12px;
      transition: color 0.2s ease;
      min-width: 44px;
    }
    .input-icon:hover {
      color: var(--accent);
    }
    .send-btn {
      background: var(--accent);
      color: #ffffff;
      border: none;
      border-radius: 50%;
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 20px;
      font-weight: bold;
      transition: all 0.2s ease;
      box-shadow: var(--glow);
    }
    .send-btn:hover {
      transform: scale(1.05);
    }
    .edit-indicator {
      font-size: 10px;
      color: var(--text-secondary);
      margin-top: 2px;
    }
    .message-sent .edit-indicator {
      color: rgba(255, 255, 255, 0.8);
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    #horizontal-spinner {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
    }
    #horizontal-spinner.active {
      display: block;
    }
    #spinner-segment {
      width: 40px;
      height: 4px;
      background: var(--accent);
      border-radius: 2px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    #alert-message {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--card-bg);
      color: var(--text-primary);
      padding: 12px 16px;
      border-radius: 20px;
      border: 1px solid var(--border);
      transform: translateX(100%);
      transition: transform 0.3s ease;
      z-index: 1000;
      max-width: 300px;
    }
    #alert-message.active {
      transform: translateX(0);
    }
    #media-progress {
      width: 100%;
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      overflow: hidden;
      margin: 8px 0;
      display: none;
    }
    #media-progress-bar {
      height: 100%;
      background: var(--accent);
      width: 0%;
      transition: width 0.3s ease;
    }
    
    /* Reaction Picker Styles */
    #reaction-picker {
      position: fixed;
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 24px;
      padding: 8px;
      box-shadow: var(--shadow-md);
      z-index: 1002;
      display: none;
      gap: 8px;
      transform: translateY(-10px);
      opacity: 0;
      transition: all 0.2s ease;
    }
    
    #reaction-picker.active {
      display: flex;
      transform: translateY(0);
      opacity: 1;
    }
    
    .reaction-btn {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      padding: 4px;
      border-radius: 50%;
      transition: transform 0.1s ease, background 0.2s ease;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .reaction-btn:hover {
      transform: scale(1.2);
      background: rgba(255, 42, 109, 0.1);
    }
    
    .reaction-btn:active {
      transform: scale(0.9);
    }
    
    /* Reactions Display on Messages */
    .message-reactions {
      display: flex;
      gap: 4px;
      margin-top: 4px;
      flex-wrap: wrap;
    }
    
    .reaction {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: rgba(0, 0, 0, 0.05);
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .message-sent .reaction {
      background: rgba(255, 255, 255, 0.2);
    }
    
    .reaction-count {
      font-size: 10px;
      font-weight: 600;
    }
    
    .reaction.user-reacted {
      background: var(--accent);
      color: #ffffff;
    }
    
    /* Dark mode adjustments */
    body.dark .reaction {
      background: rgba(255, 255, 255, 0.1);
    }
    
    body.dark .message-sent .reaction {
      background: rgba(0, 0, 0, 0.2);
    }
    
    @media (max-width: 768px) {
      .main-content {
        padding: 84px 16px 120px;
      }
      .message-bubble-wrapper {
        max-width: 85%;
      }
      #reaction-picker {
        gap: 4px;
        padding: 6px;
      }
      .reaction-btn {
        font-size: 20px;
        width: 36px;
        height: 36px;
      }
    }
  </style>
</head>
<body class="light">
  <header class="header">
    <div class="header-left">
      <button class="back-btn material-icons" onclick="location.href='index.html'">arrow_back</button>
      <div class="room-info">
        <div class="room-name-header">Global Chat</div>
        <div class="room-participants" id="online-count">Loading...</div>
      </div>
    </div>
  </header>

  <main class="main-content" id="main-content">
    <div class="messages-container" id="messages-container"></div>
  </main>

  <div class="input-bar">
    <button class="input-icon material-icons" title="Attach" onclick="attachFile()">attach_file</button>
    <div class="input-group">
      <textarea id="message-input" placeholder="Message to everyone..." onkeypress="handleKeyPress(event)"></textarea>
    </div>
    <button class="send-btn material-icons" id="send-btn" title="Send">send</button>
  </div>

  <div id="horizontal-spinner">
    <div id="spinner-segment"></div>
  </div>
  <div id="alert-message" class="alert" role="alert" aria-live="polite"></div>

  <!-- Reaction Picker -->
  <div id="reaction-picker">
    <button class="reaction-btn" data-emoji="‚ù§Ô∏è">‚ù§Ô∏è</button>
    <button class="reaction-btn" data-emoji="üòÇ">üòÇ</button>
    <button class="reaction-btn" data-emoji="üòÆ">üòÆ</button>
    <button class="reaction-btn" data-emoji="üò¢">üò¢</button>
    <button class="reaction-btn" data-emoji="üò°">üò°</button>
    <button class="reaction-btn" data-emoji="üëç">üëç</button>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js';
    import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js';
    import { getDatabase, ref, get, set, push, update, off, query, orderByChild, limitToLast, remove } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js';
    
    const firebaseConfig = {
      apiKey: "AIzaSyBOyZ3As4GTuNvjemvPF_SpsC6m6vqtNhc",
      authDomain: "fire-b-a8878.firebaseapp.com",
      databaseURL: "https://fire-b-a8878.firebaseio.com",
      projectId: "fire-b-a8878",
      storageBucket: "fire-b-a8878.firebasestorage.app",
      messagingSenderId: "658673187627",
      appId: "1:658673187627:web:6e4c29af661785f0afa36e"
    };
    
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getDatabase(app);
    
    let currentUser;
    let roomId = 'global-room';
    let messagesListener;
    let participantsListener;
    let allMessages = [];
    let participants = new Map();
    
    const verifiedIcon = `<span class="material-icons" style="font-size: 14px; color: var(--accent); vertical-align: middle;">verified</span>`;
    
    // Long press handling
    let longPressTimer = null;
    let currentMessageId = null;
    let touchStartY = 0;
    
    // Reaction picker
    const reactionPicker = document.getElementById('reaction-picker');
    const reactionButtons = document.querySelectorAll('.reaction-btn');
    
    const decrypt = async (enc, roomId) => {
      try {
        const { iv, ciphertext } = JSON.parse(enc);
        const ivBuf = Uint8Array.from(atob(iv), c => c.charCodeAt(0));
        const cipherBuf = Uint8Array.from(atob(ciphertext), c => c.charCodeAt(0));
        const encoder = new TextEncoder();
        const keyMat = await crypto.subtle.importKey('raw', encoder.encode('vynix-2025'), { name: 'PBKDF2' }, false, ['deriveKey']);
        const key = await crypto.subtle.deriveKey(
          { name: 'PBKDF2', salt: encoder.encode(roomId), iterations: 100000, hash: 'SHA-256' },
          keyMat, { name: 'AES-GCM', length: 256 }, true, ['decrypt']
        );
        const dec = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: ivBuf }, key, cipherBuf);
        return new TextDecoder().decode(dec);
      } catch { return '‚Ä¶'; }
    };
    
    const encrypt = async (message, roomId) => {
      try {
        const encoder = new TextEncoder();
        const keyMat = await crypto.subtle.importKey('raw', encoder.encode('vynix-2025'), { name: 'PBKDF2' }, false, ['deriveKey']);
        const key = await crypto.subtle.deriveKey(
          { name: 'PBKDF2', salt: encoder.encode(roomId), iterations: 100000, hash: 'SHA-256' },
          keyMat, { name: 'AES-GCM', length: 256 }, true, ['encrypt']
        );
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const data = encoder.encode(message);
        const encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, key, data);
        const ivB64 = btoa(String.fromCharCode(...iv));
        const ciphertextB64 = btoa(String.fromCharCode(...new Uint8Array(encrypted)));
        return JSON.stringify({ iv: ivB64, ciphertext: ciphertextB64 });
      } catch (error) {
        console.error('Encryption failed:', error);
        throw error;
      }
    };
    
    const showSpinner = () => document.getElementById('horizontal-spinner').classList.add('active');
    const hideSpinner = () => document.getElementById('horizontal-spinner').classList.remove('active');
    const showAlert = (message) => {
      const alert = document.getElementById('alert-message');
      alert.textContent = message;
      alert.classList.add('active');
      setTimeout(() => alert.classList.remove('active'), 3000);
    };
    
    const formatTime = (timestamp) => {
      const now = Date.now();
      const diff = now - timestamp;
      const minutes = Math.floor(diff / 60000);
      const hours = Math.floor(diff / 3600000);
      const days = Math.floor(diff / 86400000);
      
      if (days > 0) return new Date(timestamp).toLocaleDateString('en-US', { weekday: 'long' });
      if (hours > 0) return `${hours}h`;
      if (minutes > 0) return `${minutes}m`;
      return 'Just now';
    };
    
    const updateOnlineCount = () => {
      const onlineCount = Array.from(participants.values()).filter(p => p.status === 'online').length;
      document.getElementById('online-count').textContent = `${onlineCount} online`;
    };
    
    const loadParticipants = () => {
      const participantsRef = ref(db, `rooms/${roomId}/participants`);
      participantsListener = onValue(participantsRef, async (snapshot) => {
        if (snapshot.exists()) {
          participants.clear();
          const participantData = snapshot.val();
          
          const userPromises = Object.keys(participantData).map(async (userId) => {
            const userRef = ref(db, `users/${userId}`);
            const userSnap = await get(userRef);
            if (userSnap.exists()) {
              participants.set(userId, {
                ...userSnap.val(),
                status: participantData[userId].status || 'offline'
              });
            }
          });
          
          await Promise.all(userPromises);
          updateOnlineCount();
        } else {
          updateOnlineCount();
        }
      });
    };
    
    // Long press handlers - NOW TARGETING BUBBLES
    function setupMessageInteractions() {
      const messagesContainer = document.getElementById('messages-container');
      
      messagesContainer.addEventListener('touchstart', handlePressStart, { passive: false });
      messagesContainer.addEventListener('touchend', handlePressEnd);
      messagesContainer.addEventListener('touchmove', handlePressEnd);
      messagesContainer.addEventListener('touchcancel', handlePressEnd);
      messagesContainer.addEventListener('mousedown', handlePressStart);
      messagesContainer.addEventListener('mouseup', handlePressEnd);
      messagesContainer.addEventListener('mouseleave', handlePressEnd);
    }
    
    function handlePressStart(e) {
      // FIX: Target the bubble specifically
      const bubble = e.target.closest('.message-bubble');
      if (!bubble) return;
      
      // Prevent text selection
      e.preventDefault();
      
      const messageItem = bubble.closest('.message-item');
      if (!messageItem) return;
      
      const messageId = messageItem.dataset.messageId;
      if (!messageId) return;
      
      currentMessageId = messageId;
      
      // Start timer
      longPressTimer = setTimeout(() => {
        showReactionPicker(e, bubble);
      }, 500);
    }
    
    function handlePressEnd(e) {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    }
    
    function showReactionPicker(e, bubble) {
      const rect = bubble.getBoundingClientRect();
      const top = Math.max(10, rect.top - 70); // Position above bubble, prevent top overflow
      const left = Math.min(rect.left + rect.width / 2, window.innerWidth - 150); // Center above bubble
      
      reactionPicker.style.top = `${top}px`;
      reactionPicker.style.left = `${left}px`;
      reactionPicker.style.transform = 'translateX(-50%)';
      reactionPicker.classList.add('active');
      
      // Auto-hide after 3 seconds
      setTimeout(() => {
        if (reactionPicker.classList.contains('active')) {
          hideReactionPicker();
        }
      }, 3000);
    }
    
    function hideReactionPicker() {
      reactionPicker.classList.remove('active');
      currentMessageId = null;
    }
    
    // Reaction button handlers
    reactionButtons.forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const emoji = btn.dataset.emoji;
        await addReaction(currentMessageId, emoji);
        hideReactionPicker();
      });
    });
    
    async function addReaction(messageId, emoji) {
      try {
        await set(ref(db, `rooms/${roomId}/messages/${messageId}/reactions/${currentUser.uid}`), emoji);
      } catch (error) {
        console.error('Failed to add reaction:', error);
        showAlert('Failed to add reaction');
      }
    }
    
    window.toggleReaction = async (messageId, emoji) => {
      try {
        const reactionRef = ref(db, `rooms/${roomId}/messages/${messageId}/reactions/${currentUser.uid}`);
        const currentReaction = (await get(reactionRef)).val();
        
        if (currentReaction === emoji) {
          await remove(reactionRef);
        } else {
          await set(reactionRef, emoji);
        }
      } catch (error) {
        console.error('Failed to toggle reaction:', error);
        showAlert('Failed to update reaction');
      }
    };
    
    const renderMessage = async (message) => {
      // FIX: Fetch sender data if not in cache
      let sender = participants.get(message.senderId);
      
      if (!sender && message.senderId) {
        try {
          const userRef = ref(db, `users/${message.senderId}`);
          const userSnap = await get(userRef);
          if (userSnap.exists()) {
            sender = userSnap.val();
            participants.set(message.senderId, sender);
          }
        } catch (e) {
          console.warn('Failed to fetch user:', e);
        }
      }
      
      if (!sender) {
        sender = { 
          displayName: 'Anonymous', 
          photoURL: null, 
          verified: false,
          status: 'offline'
        };
      }
      
      const isSent = message.senderId === currentUser.uid;
      let displayContent;
      const isViewOnce = message.viewOnce;
      const isViewed = isViewOnce && !isSent && message.viewedBy?.[currentUser.uid];
      
      if (isViewOnce && isViewed) {
        const placeholder = message.type === 'image' ? 'Photo' : message.type === 'video' ? 'Video' : 'Message';
        displayContent = `<div style="padding:12px 16px; font-style:italic; color:var(--text-secondary);">${placeholder} viewed</div>`;
      } else {
        if (message.type === 'text') {
          displayContent = message.decrypted;
          if (message.edited) displayContent += `<div class="edit-indicator">edited</div>`;
        } else if (message.type === 'image') {
          displayContent = `<img src="${message.message}" alt="Photo" style="max-width: 200px; border-radius: 10px; cursor: pointer;" onclick="window.open('${message.message}')">`;
        } else if (message.type === 'video') {
          displayContent = `<video src="${message.message}" controls style="max-width: 200px; border-radius: 10px;"></video>`;
        } else {
          displayContent = message.decrypted || 'Media';
        }
      }
      
      const bubbleClass = isSent ? 'message-sent' : 'message-received';
      const time = formatTime(message.timestamp);
      let statusHtml = '';
      if (isSent) {
        statusHtml = '<span class="material-icons status-icon status-sent">done_all</span>';
      }
      
      const senderNameHtml = !isSent 
        ? `<div class="sender-name">${sender.displayName || 'Anonymous'} ${sender.verified ? verifiedIcon : ''}</div>` 
        : '';
      
      // Render reactions
      const reactions = message.reactions || {};
      const reactionCounts = {};
      const userReaction = reactions[currentUser.uid];
      
      Object.values(reactions).forEach(emoji => {
        reactionCounts[emoji] = (reactionCounts[emoji] || 0) + 1;
      });
      
      const reactionsHtml = Object.entries(reactionCounts)
        .map(([emoji, count]) => `
          <div class="reaction ${userReaction === emoji ? 'user-reacted' : ''}" 
               onclick="toggleReaction('${message.id}', '${emoji}')">
            ${emoji}
            <span class="reaction-count">${count}</span>
          </div>
        `).join('');
      
      const avatarInitial = sender.displayName?.[0]?.toUpperCase() || 'U';
      const avatarContent = sender.photoURL 
        ? `<img src="${sender.photoURL}" alt="${sender.displayName}" loading="lazy">` 
        : avatarInitial;
      
      return `
        <div class="message-item ${bubbleClass}" data-message-id="${message.id}" data-sender-id="${message.senderId}" data-type="${message.type}" data-content="${message.type === 'text' ? message.decrypted : ''}">
          <div class="message-avatar">${avatarContent}</div>
          <div class="message-bubble-wrapper">
            ${senderNameHtml}
            <div class="message-bubble">
              ${displayContent}
              <div class="message-time">${time} ${statusHtml}</div>
              ${reactionsHtml ? `<div class="message-reactions">${reactionsHtml}</div>` : ''}
            </div>
          </div>
        </div>
      `;
    };
    
    const updateMessages = async (messages) => {
      const container = document.getElementById('messages-container');
      container.innerHTML = '';
      let lastDate = null;
      
      for (const msg of messages) {
        const msgDate = new Date(msg.timestamp).toLocaleDateString('en-US', { weekday: 'long' });
        if (msgDate !== lastDate) {
          container.innerHTML += `<div class="message-date">${msgDate}</div>`;
          lastDate = msgDate;
        }
        container.innerHTML += await renderMessage(msg);
      }
      
      if (messages.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: var(--text-secondary); margin-top: 40px;">No messages yet. Be the first to say hi!</p>';
      }
      container.scrollTop = container.scrollHeight;
    };
    
    const setupMessagesListener = () => {
      if (messagesListener) off(messagesListener);
      
      const messagesRef = ref(db, `rooms/${roomId}/messages`);
      const orderedRef = query(messagesRef, orderByChild('timestamp'), limitToLast(100));
      
      messagesListener = onValue(orderedRef, async (snapshot) => {
        if (snapshot.exists()) {
          allMessages = Object.entries(snapshot.val())
            .map(([id, m]) => ({ id, ...m }))
            .sort((a, b) => a.timestamp - b.timestamp);
          
          // Decrypt messages
          for (const msg of allMessages) {
            if (msg.type === 'text' && !msg.decrypted) {
              msg.decrypted = await decrypt(msg.message, roomId);
            }
          }
          
          await updateMessages(allMessages);
        } else {
          allMessages = [];
          document.getElementById('messages-container').innerHTML = '<p style="text-align: center; color: var(--text-secondary); margin-top: 40px;">No messages yet. Be the first to say hi!</p>';
        }
      });
    };
    
    window.sendMessage = async () => {
      const input = document.getElementById('message-input');
      const text = input.value.trim();
      if (!text) return;
      
      try {
        showSpinner();
        const encrypted = await encrypt(text, roomId);
        const messagesRef = ref(db, `rooms/${roomId}/messages`);
        const newMessageRef = push(messagesRef);
        const timestamp = Date.now();
        
        await set(newMessageRef, {
          senderId: currentUser.uid,
          message: encrypted,
          type: 'text',
          timestamp: timestamp,
          status: 'sent'
        });
        
        // Update user activity
        await update(ref(db, `rooms/${roomId}/participants/${currentUser.uid}`), {
          lastActive: timestamp,
          status: 'online'
        });
        
        input.value = '';
        input.style.height = 'auto';
      } catch (error) {
        console.error('Failed to send message:', error);
        showAlert('Failed to send message.');
      } finally {
        hideSpinner();
      }
    };
    
    window.attachFile = async () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*,video/*';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        showSpinner();
        const progressDiv = document.getElementById('media-progress');
        const progressBar = document.getElementById('media-progress-bar');
        progressDiv.style.display = 'block';
        
        try {
          const xhr = new XMLHttpRequest();
          xhr.open('POST', 'https://api.cloudinary.com/v1_1/dqkujefxj/upload');
          const formData = new FormData();
          formData.append('file', file);
          formData.append('upload_preset', 'banter_box');
          
          await new Promise((resolve, reject) => {
            xhr.upload.addEventListener('progress', (ev) => {
              if (ev.lengthComputable) {
                progressBar.style.width = Math.round((ev.loaded / ev.total) * 100) + '%';
              }
            });
            xhr.onload = () => {
              if (xhr.status === 200) resolve(JSON.parse(xhr.responseText));
              else reject(new Error(`Upload failed: ${xhr.statusText}`));
            };
            xhr.onerror = reject;
            xhr.send(formData);
          });
          
          const { secure_url } = JSON.parse(xhr.responseText);
          const type = file.type.startsWith('image/') ? 'image' : 'video';
          await sendMediaMessage(secure_url, type);
        } catch (error) {
          console.error('Failed to send media:', error);
          showAlert('Failed to send media.');
        } finally {
          hideSpinner();
          progressDiv.style.display = 'none';
          progressBar.style.width = '0%';
        }
      };
      input.click();
    };
    
    async function sendMediaMessage(url, type) {
      try {
        const messagesRef = ref(db, `rooms/${roomId}/messages`);
        const newMessageRef = push(messagesRef);
        const timestamp = Date.now();
        
        await set(newMessageRef, {
          senderId: currentUser.uid,
          message: url,
          type: type,
          timestamp: timestamp,
          status: 'sent'
        });
        
        // Update user activity
        await update(ref(db, `rooms/${roomId}/participants/${currentUser.uid}`), {
          lastActive: timestamp,
          status: 'online'
        });
      } catch (error) {
        console.error('Failed to send media message:', error);
        showAlert('Failed to send media message.');
      }
    }
    
    window.handleKeyPress = (event) => {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
      }
    };
    
    const setupInput = () => {
      const input = document.getElementById('message-input');
      const sendBtn = document.getElementById('send-btn');
      
      sendBtn.onclick = sendMessage;
      
      input.addEventListener('input', () => {
        input.style.height = 'auto';
        input.style.height = Math.min(input.scrollHeight, 120) + 'px';
      });
    };
    
    onAuthStateChanged(auth, async (user) => {
      currentUser = user;
      if (!user) {
        location.href = 'login.html';
        return;
      }
      
      showSpinner();
      
      try {
        // Add current user to participants immediately
        const userRef = ref(db, `users/${currentUser.uid}`);
        const userSnap = await get(userRef);
        if (userSnap.exists()) {
          participants.set(currentUser.uid, {
            ...userSnap.val(),
            status: 'online'
          });
        }
        
        // Join global room
        await set(ref(db, `rooms/${roomId}/participants/${currentUser.uid}`), {
          joinedAt: Date.now(),
          lastActive: Date.now(),
          status: 'online'
        });
        
        // Setup presence
        const myStatusRef = ref(db, `rooms/${roomId}/participants/${currentUser.uid}/status`);
        window.addEventListener('beforeunload', () => {
          set(myStatusRef, 'offline');
        });
        
        setInterval(() => {
          set(myStatusRef, 'online');
        }, 60000);
        
        loadParticipants();
        setupMessagesListener();
        setupInput();
        setupMessageInteractions();
        
        // Hide reaction picker when clicking outside
        document.addEventListener('click', (e) => {
          if (!reactionPicker.contains(e.target) && !e.target.closest('.message-bubble')) {
            hideReactionPicker();
          }
        });
        
      } catch (error) {
        console.error('Failed to initialize chat:', error);
        showAlert('Failed to load global chat');
      } finally {
        hideSpinner();
      }
    });
    
    window.addEventListener('beforeunload', () => {
      if (messagesListener) off(messagesListener);
      if (participantsListener) off(participantsListener);
      if (currentUser && roomId) {
        set(ref(db, `rooms/${roomId}/participants/${currentUser.uid}/status`), 'offline');
      }
    });
  </script>
</body>
</html>
